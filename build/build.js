var demo = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/@mapwhit/tilerenderer/src/util/polyfill.js
  var require_polyfill = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/polyfill.js"() {
      if (typeof Promise.withResolvers !== "function") {
        Promise.withResolvers = function() {
          let resolve;
          let reject;
          const promise = new Promise((res, rej) => {
            resolve = res;
            reject = rej;
          });
          return { promise, resolve, reject };
        };
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/package.json
  var require_package = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/package.json"(exports, module) {
      module.exports = {
        version: "0.51.0"
      };
    }
  });

  // node_modules/@mapwhit/events/lib/events.js
  var events_exports = {};
  __export(events_exports, {
    ErrorEvent: () => ErrorEvent,
    Event: () => Event,
    Evented: () => Evented
  });
  function listeners({ once } = {}) {
    const bag = /* @__PURE__ */ new Map();
    return {
      add,
      remove,
      fire,
      listens
    };
    function add(type, listener) {
      const list = bag.get(type);
      if (!list) {
        bag.set(type, [listener]);
      } else if (!list.includes(listener)) {
        list.push(listener);
      }
    }
    function remove(type, listener) {
      const list = bag.get(type);
      if (!list) {
        return;
      }
      const index = list.indexOf(listener);
      if (index !== -1) {
        list.splice(index, 1);
      }
      if (list.length === 0) {
        bag.delete(type);
      }
    }
    function fire(type, thisArg, data) {
      let list = bag.get(type);
      if (!list || list.length === 0) {
        return;
      }
      if (once) {
        bag.delete(type);
      } else {
        list = list.slice();
      }
      for (const listener of list) {
        listener.call(thisArg, data);
      }
    }
    function listens(type) {
      return bag.get(type)?.length > 0;
    }
  }
  var Event, ErrorEvent, Evented;
  var init_events = __esm({
    "node_modules/@mapwhit/events/lib/events.js"() {
      Event = class {
        constructor(type, data) {
          Object.assign(this, data);
          this.type = type;
        }
      };
      ErrorEvent = class extends Event {
        constructor(error, data) {
          super("error", Object.assign({ error }, data));
        }
      };
      Evented = class {
        #listeners;
        #oneTimeListeners;
        #parent;
        #parentData;
        /**
         * Adds a listener to a specified event type.
         *
         * @param {string} type The event type to add a listen for.
         * @param {Function} listener The function to be called when the event is fired.
         *   The listener function is called with the data object passed to `fire`,
         *   extended with `target` and `type` properties.
         * @returns {Object} `this`
         */
        on(type, listener) {
          this.#listeners ??= listeners();
          this.#listeners.add(type, listener);
          return this;
        }
        /**
         * Removes a previously registered event listener.
         *
         * @param {string} type The event type to remove listeners for.
         * @param {Function} listener The listener function to remove.
         * @returns {Object} `this`
         */
        off(type, listener) {
          this.#listeners?.remove(type, listener);
          this.#oneTimeListeners?.remove(type, listener);
          return this;
        }
        /**
         * Adds a listener that will be called only once to a specified event type.
         *
         * The listener will be called first time the event fires after the listener is registered.
         *
         * @param {string} type The event type to listen for.
         * @param {Function} listener The function to be called when the event is fired the first time.
         * @returns {Object} `this`
         */
        once(type, listener) {
          this.#oneTimeListeners ??= listeners({ once: true });
          this.#oneTimeListeners.add(type, listener);
          return this;
        }
        fire(event, ...args) {
          if (typeof event === "string") {
            event = new Event(event, ...args);
          }
          const { type } = event;
          if (this.listens(type)) {
            event.target = this;
            this.#listeners?.fire(type, this, event);
            this.#oneTimeListeners?.fire(type, this, event);
            const parent = this.#parent;
            if (parent) {
              const data = typeof this.#parentData === "function" ? this.#parentData() : this.#parentData;
              Object.assign(event, data);
              parent.fire(event);
            }
          } else if (event instanceof ErrorEvent) {
            console.error(event.error);
          }
          return this;
        }
        /**
         * Returns a true if this instance of Evented or any forwardeed instances of Evented have a listener for the specified type.
         *
         * @param {string} type The event type
         * @returns {boolean} `true` if there is at least one registered listener for specified event type, `false` otherwise
         */
        listens(type) {
          return this.#listeners?.listens(type) || this.#oneTimeListeners?.listens(type) || this.#parent?.listens(type);
        }
        /**
         * Bubble all events fired by this instance of Evented to this parent instance of Evented.
         *
         * @returns {Object} `this`
         */
        setEventedParent(parent, data) {
          this.#parent = parent;
          this.#parentData = data;
          return this;
        }
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/browser.js
  var require_browser = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/browser.js"(exports, module) {
      var now = () => performance.now();
      var raf = typeof window === "object" ? window.requestAnimationFrame : (fn) => setTimeout(fn, 0);
      var cancel = typeof window === "object" ? window.cancelAnimationFrame : (id) => clearTimeout(id);
      var exported = {
        /**
         * Provides a function that outputs milliseconds: either performance.now()
         * or a fallback to Date.now()
         */
        now,
        frame(fn) {
          return raf(fn);
        },
        cancelFrame(id) {
          return cancel(id);
        },
        getImageData(img) {
          const canvas = window.document.createElement("canvas");
          const context = canvas.getContext("2d");
          if (!context) {
            throw new Error("failed to create canvas 2d context");
          }
          canvas.width = img.width;
          canvas.height = img.height;
          context.drawImage(img, 0, 0, img.width, img.height);
          return context.getImageData(0, 0, img.width, img.height);
        },
        resolveURL(path) {
          const a = window.document.createElement("a");
          a.href = path;
          return a.href;
        },
        hardwareConcurrency: typeof window === "object" ? window.navigator.hardwareConcurrency : 4,
        get devicePixelRatio() {
          return typeof window === "object" ? window.devicePixelRatio : 1;
        }
      };
      module.exports = exported;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/rtl_text_plugin.js
  var require_rtl_text_plugin = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/rtl_text_plugin.js"(exports, module) {
      var { Event: Event3, Evented: Evented3 } = (init_events(), __toCommonJS(events_exports));
      var browser = require_browser();
      var pluginRequested = false;
      var pluginURL = null;
      var foregroundLoadComplete = false;
      var evented = new Evented3();
      var _completionCallback;
      function registerForPluginAvailability(callback) {
        if (pluginURL) {
          callback({ pluginURL, completionCallback: _completionCallback });
        } else {
          evented.once("pluginAvailable", callback);
        }
        return callback;
      }
      function clearRTLTextPlugin() {
        pluginRequested = false;
        pluginURL = null;
      }
      function setRTLTextPlugin(url, callback) {
        if (pluginRequested) {
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        }
        pluginRequested = true;
        pluginURL = browser.resolveURL(url);
        _completionCallback = (error) => {
          if (error) {
            clearRTLTextPlugin();
            if (callback) {
              callback(error);
            }
          } else {
            foregroundLoadComplete = true;
          }
        };
        evented.fire(new Event3("pluginAvailable", { pluginURL, completionCallback: _completionCallback }));
      }
      var plugin = {
        applyArabicShaping: null,
        processBidirectionalText: null,
        processStyledBidirectionalText: null,
        isLoaded: function() {
          return foregroundLoadComplete || // Foreground: loaded if the completion callback returned successfully
          plugin.applyArabicShaping != null;
        }
      };
      module.exports = {
        registerForPluginAvailability,
        clearRTLTextPlugin,
        setRTLTextPlugin,
        plugin,
        evented
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/object.js
  var require_object = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/object.js"(exports, module) {
      function values(obj) {
        const result = [];
        for (const k in obj) {
          result.push(obj[k]);
        }
        return result;
      }
      function keysDifference(obj, other) {
        const difference = [];
        for (const i in obj) {
          if (!(i in other)) {
            difference.push(i);
          }
        }
        return difference;
      }
      function pick(src, properties) {
        const result = {};
        for (let i = 0; i < properties.length; i++) {
          const k = properties[i];
          if (k in src) {
            result[k] = src[k];
          }
        }
        return result;
      }
      function bindAll(fns, context) {
        fns.forEach((fn) => {
          if (!context[fn]) {
            return;
          }
          context[fn] = context[fn].bind(context);
        });
      }
      function mapObject(input, iterator, context) {
        const output = {};
        for (const key in input) {
          output[key] = iterator.call(context || this, input[key], key, input);
        }
        return output;
      }
      function filterObject(input, iterator, context) {
        const output = {};
        for (const key in input) {
          if (iterator.call(context || this, input[key], key, input)) {
            output[key] = input[key];
          }
        }
        return output;
      }
      function deepEqual(a, b) {
        if (Array.isArray(a)) {
          if (!Array.isArray(b) || a.length !== b.length) return false;
          for (let i = 0; i < a.length; i++) {
            if (!deepEqual(a[i], b[i])) return false;
          }
          return true;
        }
        if (typeof a === "object" && a !== null && b !== null) {
          if (!(typeof b === "object")) return false;
          const keys = Object.keys(a);
          if (keys.length !== Object.keys(b).length) return false;
          for (const key in a) {
            if (!deepEqual(a[key], b[key])) return false;
          }
          return true;
        }
        return a === b;
      }
      function clone(input) {
        if (Array.isArray(input)) {
          return input.map(clone);
        }
        if (typeof input === "object" && input) {
          return mapObject(input, clone);
        }
        return input;
      }
      function arraysIntersect(a, b) {
        for (let l = 0; l < a.length; l++) {
          if (b.indexOf(a[l]) >= 0) return true;
        }
        return false;
      }
      module.exports = {
        values,
        keysDifference,
        pick,
        bindAll,
        mapObject,
        filterObject,
        deepEqual,
        clone,
        arraysIntersect
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/warn.js
  var require_warn = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/warn.js"(exports, module) {
      var warnOnceHistory = {};
      function once(message) {
        if (!warnOnceHistory[message]) {
          console.warn(message);
          warnOnceHistory[message] = true;
        }
      }
      function noop() {
      }
      module.exports = {
        once: typeof console !== "undefined" ? once : noop
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/dom.js
  var require_dom = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/dom.js"(exports, module) {
      var DOM = {};
      module.exports = DOM;
      DOM.create = function(tagName, className, container) {
        const el = window.document.createElement(tagName);
        if (className) el.className = className;
        if (container) container.appendChild(el);
        return el;
      };
      DOM.createNS = function(namespaceURI, tagName) {
        const el = window.document.createElementNS(namespaceURI, tagName);
        return el;
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/loader/image.js
  var require_image = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/loader/image.js"(exports, module) {
      module.exports = image;
      function image(data) {
        if (!data) {
          throw new Error("image data not loaded");
        }
        return data.byteLength === 0 ? transparentImage() : imageFromData({ data });
      }
      async function imageFromData(imgData) {
        const { promise, resolve } = Promise.withResolvers();
        const blob = new window.Blob([imgData.data], { type: imgData.type || "image/png" });
        const img = new window.Image();
        img.onload = () => {
          resolve(img);
          window.URL.revokeObjectURL(img.src);
        };
        img.src = await window.URL.createObjectURL(blob);
        return promise;
      }
      var transparentPngUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function transparentImage() {
        const { promise, resolve } = Promise.withResolvers();
        const img = new window.Image();
        img.onload = () => resolve(img);
        img.src = transparentPngUrl;
        return promise;
      }
    }
  });

  // node_modules/@pirxpilot/nanoassert/index.js
  var require_nanoassert = __commonJS({
    "node_modules/@pirxpilot/nanoassert/index.js"(exports, module) {
      module.exports = assert;
      assert.notEqual = notEqual;
      assert.notOk = notOk;
      assert.equal = equal;
      assert.ok = assert;
      function equal(a, b, m) {
        doAssert(equal, a == b, m);
      }
      function notEqual(a, b, m) {
        doAssert(notEqual, a != b, m);
      }
      function notOk(t, m) {
        doAssert(notOk, !t, m);
      }
      function assert(t, m) {
        doAssert(assert, t, m);
      }
      var AssertionError = class extends Error {
      };
      function doAssert(fn, t, m) {
        if (!t) {
          const err = new AssertionError(m);
          Error.captureStackTrace?.(err, fn);
          throw err;
        }
      }
    }
  });

  // node_modules/@mapbox/unitbezier/index.js
  var require_unitbezier = __commonJS({
    "node_modules/@mapbox/unitbezier/index.js"(exports, module) {
      "use strict";
      module.exports = UnitBezier2;
      function UnitBezier2(p1x, p1y, p2x, p2y) {
        this.cx = 3 * p1x;
        this.bx = 3 * (p2x - p1x) - this.cx;
        this.ax = 1 - this.cx - this.bx;
        this.cy = 3 * p1y;
        this.by = 3 * (p2y - p1y) - this.cy;
        this.ay = 1 - this.cy - this.by;
        this.p1x = p1x;
        this.p1y = p1y;
        this.p2x = p2x;
        this.p2y = p2y;
      }
      UnitBezier2.prototype = {
        sampleCurveX: function(t) {
          return ((this.ax * t + this.bx) * t + this.cx) * t;
        },
        sampleCurveY: function(t) {
          return ((this.ay * t + this.by) * t + this.cy) * t;
        },
        sampleCurveDerivativeX: function(t) {
          return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
        },
        solveCurveX: function(x, epsilon) {
          if (epsilon === void 0) epsilon = 1e-6;
          if (x < 0) return 0;
          if (x > 1) return 1;
          var t = x;
          for (var i = 0; i < 8; i++) {
            var x2 = this.sampleCurveX(t) - x;
            if (Math.abs(x2) < epsilon) return t;
            var d2 = this.sampleCurveDerivativeX(t);
            if (Math.abs(d2) < 1e-6) break;
            t = t - x2 / d2;
          }
          var t0 = 0;
          var t1 = 1;
          t = x;
          for (i = 0; i < 20; i++) {
            x2 = this.sampleCurveX(t);
            if (Math.abs(x2 - x) < epsilon) break;
            if (x > x2) {
              t0 = t;
            } else {
              t1 = t;
            }
            t = (t1 - t0) * 0.5 + t0;
          }
          return t;
        },
        solve: function(x, epsilon) {
          return this.sampleCurveY(this.solveCurveX(x, epsilon));
        }
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/geo/coordinate.js
  var require_coordinate = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/geo/coordinate.js"(exports, module) {
      var Coordinate = class _Coordinate {
        constructor(column, row, zoom) {
          this.column = column;
          this.row = row;
          this.zoom = zoom;
        }
        /**
         * Create a clone of this coordinate that can be mutated without
         * changing the original coordinate
         *
         * @returns {Coordinate} clone
         * @private
         * var coord = new Coordinate(0, 0, 0);
         * var c2 = coord.clone();
         * // since coord is cloned, modifying a property of c2 does
         * // not modify it.
         * c2.zoom = 2;
         */
        clone() {
          return new _Coordinate(this.column, this.row, this.zoom);
        }
        /**
         * Zoom this coordinate to a given zoom level. This returns a new
         * coordinate object, not mutating the old one.
         *
         * @param {number} zoom
         * @returns {Coordinate} zoomed coordinate
         * @private
         * @example
         * var coord = new Coordinate(0, 0, 0);
         * var c2 = coord.zoomTo(1);
         * c2 // equals new Coordinate(0, 0, 1);
         */
        zoomTo(zoom) {
          return this.clone()._zoomTo(zoom);
        }
        /**
         * Subtract the column and row values of this coordinate from those
         * of another coordinate. The other coordinat will be zoomed to the
         * same level as `this` before the subtraction occurs
         *
         * @param {Coordinate} c other coordinate
         * @returns {Coordinate} result
         * @private
         */
        sub(c) {
          return this.clone()._sub(c);
        }
        _zoomTo(zoom) {
          const scale = 2 ** (zoom - this.zoom);
          this.column *= scale;
          this.row *= scale;
          this.zoom = zoom;
          return this;
        }
        _sub(c) {
          c = c.zoomTo(this.zoom);
          this.column -= c.column;
          this.row -= c.row;
          return this;
        }
      };
      module.exports = Coordinate;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/util.js
  var require_util = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/util.js"(exports, module) {
      var UnitBezier2 = require_unitbezier();
      var Coordinate = require_coordinate();
      function easeCubicInOut(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        const t2 = t * t;
        const t3 = t2 * t;
        return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
      }
      function bezier2(p1x, p1y, p2x, p2y) {
        const bezier3 = new UnitBezier2(p1x, p1y, p2x, p2y);
        return function(t) {
          return bezier3.solve(t);
        };
      }
      var ease2 = bezier2(0.25, 0.1, 0.25, 1);
      function clamp(n, min, max) {
        return Math.min(max, Math.max(min, n));
      }
      function wrap(n, min, max) {
        const d = max - min;
        const w = ((n - min) % d + d) % d + min;
        return w === min ? max : w;
      }
      function getCoordinatesCenter(coords) {
        let minX = Number.POSITIVE_INFINITY;
        let minY = Number.POSITIVE_INFINITY;
        let maxX = Number.NEGATIVE_INFINITY;
        let maxY = Number.NEGATIVE_INFINITY;
        for (let i = 0; i < coords.length; i++) {
          minX = Math.min(minX, coords[i].column);
          minY = Math.min(minY, coords[i].row);
          maxX = Math.max(maxX, coords[i].column);
          maxY = Math.max(maxY, coords[i].row);
        }
        const dx = maxX - minX;
        const dy = maxY - minY;
        const dMax = Math.max(dx, dy);
        const zoom = Math.max(0, Math.floor(-Math.log(dMax) / Math.LN2));
        return new Coordinate((minX + maxX) / 2, (minY + maxY) / 2, 0).zoomTo(zoom);
      }
      function isCounterClockwise(a, b, c) {
        return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);
      }
      function calculateSignedArea(ring) {
        let sum = 0;
        const len = ring.length;
        let p2 = ring[len - 1];
        for (const p1 of ring) {
          sum += (p2.x - p1.x) * (p1.y + p2.y);
          p2 = p1;
        }
        return sum;
      }
      function isClosedPolygon(points) {
        if (points.length < 4) return false;
        const p1 = points[0];
        const p2 = points[points.length - 1];
        if (Math.abs(p1.x - p2.x) > 0 || Math.abs(p1.y - p2.y) > 0) {
          return false;
        }
        return Math.abs(calculateSignedArea(points)) > 0.01;
      }
      function sphericalToCartesian([r, azimuthal, polar]) {
        azimuthal += 90;
        azimuthal *= Math.PI / 180;
        polar *= Math.PI / 180;
        return {
          x: r * Math.cos(azimuthal) * Math.sin(polar),
          y: r * Math.sin(azimuthal) * Math.sin(polar),
          z: r * Math.cos(polar)
        };
      }
      module.exports = {
        easeCubicInOut,
        bezier: bezier2,
        ease: ease2,
        clamp,
        wrap,
        getCoordinatesCenter,
        isCounterClockwise,
        calculateSignedArea,
        isClosedPolygon,
        sphericalToCartesian
      };
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/parsing_error.js
  var require_parsing_error = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/parsing_error.js"(exports, module) {
      var ParsingError = class extends Error {
        constructor(key, message) {
          super(message);
          this.message = message;
          this.key = key;
        }
      };
      module.exports = ParsingError;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/scope.js
  var require_scope = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/scope.js"(exports, module) {
      var Scope = class _Scope {
        constructor(parent, bindings = []) {
          this.parent = parent;
          this.bindings = {};
          for (const [name, expression] of bindings) {
            this.bindings[name] = expression;
          }
        }
        concat(bindings) {
          return new _Scope(this, bindings);
        }
        get(name) {
          if (this.bindings[name]) {
            return this.bindings[name];
          }
          if (this.parent) {
            return this.parent.get(name);
          }
          throw new Error(`${name} not found in scope.`);
        }
        has(name) {
          if (this.bindings[name]) return true;
          return this.parent ? this.parent.has(name) : false;
        }
      };
      module.exports = Scope;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/types.js
  var require_types = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/types.js"(exports, module) {
      var NullType = { kind: "null" };
      var NumberType = { kind: "number" };
      var StringType = { kind: "string" };
      var BooleanType = { kind: "boolean" };
      var ColorType = { kind: "color" };
      var ObjectType = { kind: "object" };
      var ValueType = { kind: "value" };
      var ErrorType = { kind: "error" };
      var CollatorType = { kind: "collator" };
      var FormattedType = { kind: "formatted" };
      function array(itemType, N) {
        return {
          kind: "array",
          itemType,
          N
        };
      }
      function toString(type) {
        if (type.kind === "array") {
          const itemType = toString(type.itemType);
          return typeof type.N === "number" ? `array<${itemType}, ${type.N}>` : type.itemType.kind === "value" ? "array" : `array<${itemType}>`;
        }
        return type.kind;
      }
      var valueMemberTypes = [
        NullType,
        NumberType,
        StringType,
        BooleanType,
        ColorType,
        FormattedType,
        ObjectType,
        array(ValueType)
      ];
      function checkSubtype(expected, t) {
        if (t.kind === "error") {
          return null;
        }
        if (expected.kind === "array") {
          if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== "number" || expected.N === t.N)) {
            return null;
          }
        } else if (expected.kind === t.kind) {
          return null;
        } else if (expected.kind === "value") {
          for (const memberType of valueMemberTypes) {
            if (!checkSubtype(memberType, t)) {
              return null;
            }
          }
        }
        return `Expected ${toString(expected)} but found ${toString(t)} instead.`;
      }
      module.exports = {
        NullType,
        NumberType,
        StringType,
        BooleanType,
        ColorType,
        FormattedType,
        ObjectType,
        ValueType,
        ErrorType,
        CollatorType,
        array,
        toString,
        checkSubtype
      };
    }
  });

  // node_modules/csscolorparser/csscolorparser.js
  var require_csscolorparser = __commonJS({
    "node_modules/csscolorparser/csscolorparser.js"(exports) {
      var kCSSColorTable = {
        "transparent": [0, 0, 0, 0],
        "aliceblue": [240, 248, 255, 1],
        "antiquewhite": [250, 235, 215, 1],
        "aqua": [0, 255, 255, 1],
        "aquamarine": [127, 255, 212, 1],
        "azure": [240, 255, 255, 1],
        "beige": [245, 245, 220, 1],
        "bisque": [255, 228, 196, 1],
        "black": [0, 0, 0, 1],
        "blanchedalmond": [255, 235, 205, 1],
        "blue": [0, 0, 255, 1],
        "blueviolet": [138, 43, 226, 1],
        "brown": [165, 42, 42, 1],
        "burlywood": [222, 184, 135, 1],
        "cadetblue": [95, 158, 160, 1],
        "chartreuse": [127, 255, 0, 1],
        "chocolate": [210, 105, 30, 1],
        "coral": [255, 127, 80, 1],
        "cornflowerblue": [100, 149, 237, 1],
        "cornsilk": [255, 248, 220, 1],
        "crimson": [220, 20, 60, 1],
        "cyan": [0, 255, 255, 1],
        "darkblue": [0, 0, 139, 1],
        "darkcyan": [0, 139, 139, 1],
        "darkgoldenrod": [184, 134, 11, 1],
        "darkgray": [169, 169, 169, 1],
        "darkgreen": [0, 100, 0, 1],
        "darkgrey": [169, 169, 169, 1],
        "darkkhaki": [189, 183, 107, 1],
        "darkmagenta": [139, 0, 139, 1],
        "darkolivegreen": [85, 107, 47, 1],
        "darkorange": [255, 140, 0, 1],
        "darkorchid": [153, 50, 204, 1],
        "darkred": [139, 0, 0, 1],
        "darksalmon": [233, 150, 122, 1],
        "darkseagreen": [143, 188, 143, 1],
        "darkslateblue": [72, 61, 139, 1],
        "darkslategray": [47, 79, 79, 1],
        "darkslategrey": [47, 79, 79, 1],
        "darkturquoise": [0, 206, 209, 1],
        "darkviolet": [148, 0, 211, 1],
        "deeppink": [255, 20, 147, 1],
        "deepskyblue": [0, 191, 255, 1],
        "dimgray": [105, 105, 105, 1],
        "dimgrey": [105, 105, 105, 1],
        "dodgerblue": [30, 144, 255, 1],
        "firebrick": [178, 34, 34, 1],
        "floralwhite": [255, 250, 240, 1],
        "forestgreen": [34, 139, 34, 1],
        "fuchsia": [255, 0, 255, 1],
        "gainsboro": [220, 220, 220, 1],
        "ghostwhite": [248, 248, 255, 1],
        "gold": [255, 215, 0, 1],
        "goldenrod": [218, 165, 32, 1],
        "gray": [128, 128, 128, 1],
        "green": [0, 128, 0, 1],
        "greenyellow": [173, 255, 47, 1],
        "grey": [128, 128, 128, 1],
        "honeydew": [240, 255, 240, 1],
        "hotpink": [255, 105, 180, 1],
        "indianred": [205, 92, 92, 1],
        "indigo": [75, 0, 130, 1],
        "ivory": [255, 255, 240, 1],
        "khaki": [240, 230, 140, 1],
        "lavender": [230, 230, 250, 1],
        "lavenderblush": [255, 240, 245, 1],
        "lawngreen": [124, 252, 0, 1],
        "lemonchiffon": [255, 250, 205, 1],
        "lightblue": [173, 216, 230, 1],
        "lightcoral": [240, 128, 128, 1],
        "lightcyan": [224, 255, 255, 1],
        "lightgoldenrodyellow": [250, 250, 210, 1],
        "lightgray": [211, 211, 211, 1],
        "lightgreen": [144, 238, 144, 1],
        "lightgrey": [211, 211, 211, 1],
        "lightpink": [255, 182, 193, 1],
        "lightsalmon": [255, 160, 122, 1],
        "lightseagreen": [32, 178, 170, 1],
        "lightskyblue": [135, 206, 250, 1],
        "lightslategray": [119, 136, 153, 1],
        "lightslategrey": [119, 136, 153, 1],
        "lightsteelblue": [176, 196, 222, 1],
        "lightyellow": [255, 255, 224, 1],
        "lime": [0, 255, 0, 1],
        "limegreen": [50, 205, 50, 1],
        "linen": [250, 240, 230, 1],
        "magenta": [255, 0, 255, 1],
        "maroon": [128, 0, 0, 1],
        "mediumaquamarine": [102, 205, 170, 1],
        "mediumblue": [0, 0, 205, 1],
        "mediumorchid": [186, 85, 211, 1],
        "mediumpurple": [147, 112, 219, 1],
        "mediumseagreen": [60, 179, 113, 1],
        "mediumslateblue": [123, 104, 238, 1],
        "mediumspringgreen": [0, 250, 154, 1],
        "mediumturquoise": [72, 209, 204, 1],
        "mediumvioletred": [199, 21, 133, 1],
        "midnightblue": [25, 25, 112, 1],
        "mintcream": [245, 255, 250, 1],
        "mistyrose": [255, 228, 225, 1],
        "moccasin": [255, 228, 181, 1],
        "navajowhite": [255, 222, 173, 1],
        "navy": [0, 0, 128, 1],
        "oldlace": [253, 245, 230, 1],
        "olive": [128, 128, 0, 1],
        "olivedrab": [107, 142, 35, 1],
        "orange": [255, 165, 0, 1],
        "orangered": [255, 69, 0, 1],
        "orchid": [218, 112, 214, 1],
        "palegoldenrod": [238, 232, 170, 1],
        "palegreen": [152, 251, 152, 1],
        "paleturquoise": [175, 238, 238, 1],
        "palevioletred": [219, 112, 147, 1],
        "papayawhip": [255, 239, 213, 1],
        "peachpuff": [255, 218, 185, 1],
        "peru": [205, 133, 63, 1],
        "pink": [255, 192, 203, 1],
        "plum": [221, 160, 221, 1],
        "powderblue": [176, 224, 230, 1],
        "purple": [128, 0, 128, 1],
        "rebeccapurple": [102, 51, 153, 1],
        "red": [255, 0, 0, 1],
        "rosybrown": [188, 143, 143, 1],
        "royalblue": [65, 105, 225, 1],
        "saddlebrown": [139, 69, 19, 1],
        "salmon": [250, 128, 114, 1],
        "sandybrown": [244, 164, 96, 1],
        "seagreen": [46, 139, 87, 1],
        "seashell": [255, 245, 238, 1],
        "sienna": [160, 82, 45, 1],
        "silver": [192, 192, 192, 1],
        "skyblue": [135, 206, 235, 1],
        "slateblue": [106, 90, 205, 1],
        "slategray": [112, 128, 144, 1],
        "slategrey": [112, 128, 144, 1],
        "snow": [255, 250, 250, 1],
        "springgreen": [0, 255, 127, 1],
        "steelblue": [70, 130, 180, 1],
        "tan": [210, 180, 140, 1],
        "teal": [0, 128, 128, 1],
        "thistle": [216, 191, 216, 1],
        "tomato": [255, 99, 71, 1],
        "turquoise": [64, 224, 208, 1],
        "violet": [238, 130, 238, 1],
        "wheat": [245, 222, 179, 1],
        "white": [255, 255, 255, 1],
        "whitesmoke": [245, 245, 245, 1],
        "yellow": [255, 255, 0, 1],
        "yellowgreen": [154, 205, 50, 1]
      };
      function clamp_css_byte(i) {
        i = Math.round(i);
        return i < 0 ? 0 : i > 255 ? 255 : i;
      }
      function clamp_css_float(f) {
        return f < 0 ? 0 : f > 1 ? 1 : f;
      }
      function parse_css_int(str) {
        if (str[str.length - 1] === "%")
          return clamp_css_byte(parseFloat(str) / 100 * 255);
        return clamp_css_byte(parseInt(str));
      }
      function parse_css_float(str) {
        if (str[str.length - 1] === "%")
          return clamp_css_float(parseFloat(str) / 100);
        return clamp_css_float(parseFloat(str));
      }
      function css_hue_to_rgb(m1, m2, h) {
        if (h < 0) h += 1;
        else if (h > 1) h -= 1;
        if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
        if (h * 2 < 1) return m2;
        if (h * 3 < 2) return m1 + (m2 - m1) * (2 / 3 - h) * 6;
        return m1;
      }
      function parseCSSColor(css_str) {
        var str = css_str.replace(/ /g, "").toLowerCase();
        if (str in kCSSColorTable) return kCSSColorTable[str].slice();
        if (str[0] === "#") {
          if (str.length === 4) {
            var iv = parseInt(str.substr(1), 16);
            if (!(iv >= 0 && iv <= 4095)) return null;
            return [
              (iv & 3840) >> 4 | (iv & 3840) >> 8,
              iv & 240 | (iv & 240) >> 4,
              iv & 15 | (iv & 15) << 4,
              1
            ];
          } else if (str.length === 7) {
            var iv = parseInt(str.substr(1), 16);
            if (!(iv >= 0 && iv <= 16777215)) return null;
            return [
              (iv & 16711680) >> 16,
              (iv & 65280) >> 8,
              iv & 255,
              1
            ];
          }
          return null;
        }
        var op = str.indexOf("("), ep = str.indexOf(")");
        if (op !== -1 && ep + 1 === str.length) {
          var fname = str.substr(0, op);
          var params = str.substr(op + 1, ep - (op + 1)).split(",");
          var alpha = 1;
          switch (fname) {
            case "rgba":
              if (params.length !== 4) return null;
              alpha = parse_css_float(params.pop());
            // Fall through.
            case "rgb":
              if (params.length !== 3) return null;
              return [
                parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha
              ];
            case "hsla":
              if (params.length !== 4) return null;
              alpha = parse_css_float(params.pop());
            // Fall through.
            case "hsl":
              if (params.length !== 3) return null;
              var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360;
              var s = parse_css_float(params[1]);
              var l = parse_css_float(params[2]);
              var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
              var m1 = l * 2 - m2;
              return [
                clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255),
                alpha
              ];
            default:
              return null;
          }
        }
        return null;
      }
      try {
        exports.parseCSSColor = parseCSSColor;
      } catch (e) {
      }
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/util/color.js
  var require_color = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/util/color.js"(exports, module) {
      var { parseCSSColor } = require_csscolorparser();
      var Color = class _Color {
        constructor(r, g, b, a = 1) {
          this.r = r;
          this.g = g;
          this.b = b;
          this.a = a;
        }
        /**
         * Parses valid CSS color strings and returns a `Color` instance.
         * @returns A `Color` instance, or `undefined` if the input is not a valid color string.
         */
        static parse(input) {
          if (!input) {
            return void 0;
          }
          if (input instanceof _Color) {
            return input;
          }
          if (typeof input !== "string") {
            return void 0;
          }
          const rgba = parseCSSColor(input);
          if (!rgba) {
            return void 0;
          }
          return new _Color(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);
        }
        /**
         * Returns an RGBA string representing the color value.
         *
         * @returns An RGBA string.
         * @example
         * var purple = new Color.parse('purple');
         * purple.toString; // = "rgba(128,0,128,1)"
         * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');
         * translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
         */
        toString() {
          const [r, g, b, a] = this.toArray();
          return `rgba(${Math.round(r)},${Math.round(g)},${Math.round(b)},${a})`;
        }
        toArray() {
          const { r, g, b, a } = this;
          return a === 0 ? [0, 0, 0, 0] : [r * 255 / a, g * 255 / a, b * 255 / a, a];
        }
      };
      Color.black = new Color(0, 0, 0, 1);
      Color.white = new Color(1, 1, 1, 1);
      Color.transparent = new Color(0, 0, 0, 0);
      Color.red = new Color(1, 0, 0, 1);
      module.exports = Color;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/types/collator.js
  var require_collator = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/types/collator.js"(exports, module) {
      var Collator = class {
        constructor(caseSensitive, diacriticSensitive, locale) {
          if (caseSensitive) this.sensitivity = diacriticSensitive ? "variant" : "case";
          else this.sensitivity = diacriticSensitive ? "accent" : "base";
          this.locale = locale;
          this.collator = new Intl.Collator(this.locale ? this.locale : [], {
            sensitivity: this.sensitivity,
            usage: "search"
          });
        }
        compare(lhs, rhs) {
          return this.collator.compare(lhs, rhs);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      };
      module.exports = { Collator };
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/types/formatted.js
  var require_formatted = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/types/formatted.js"(exports, module) {
      var FormattedSection = class {
        constructor(text, scale, fontStack = null) {
          this.text = text;
          this.scale = scale;
          this.fontStack = fontStack;
        }
      };
      var Formatted = class _Formatted {
        constructor(sections) {
          this.sections = sections;
        }
        static fromString(unformatted) {
          return new _Formatted([new FormattedSection(unformatted, null, null)]);
        }
        toString() {
          return this.sections.map((section) => section.text).join("");
        }
        serialize() {
          const serialized = ["format"];
          for (const section of this.sections) {
            serialized.push(section.text);
            const options = {};
            if (section.fontStack) {
              options["text-font"] = ["literal", section.fontStack.split(",")];
            }
            if (section.scale) {
              options["font-scale"] = section.scale;
            }
            serialized.push(options);
          }
          return serialized;
        }
      };
      module.exports = { Formatted, FormattedSection };
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/values.js
  var require_values = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/values.js"(exports, module) {
      var assert = require_nanoassert();
      var Color = require_color();
      var { Collator } = require_collator();
      var { Formatted } = require_formatted();
      var {
        NullType,
        NumberType,
        StringType,
        BooleanType,
        ColorType,
        ObjectType,
        ValueType,
        CollatorType,
        FormattedType,
        array
      } = require_types();
      function validateRGBA(r, g, b, a) {
        if (!(typeof r === "number" && r >= 0 && r <= 255 && typeof g === "number" && g >= 0 && g <= 255 && typeof b === "number" && b >= 0 && b <= 255)) {
          const value = typeof a === "number" ? [r, g, b, a] : [r, g, b];
          return `Invalid rgba value [${value.join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        if (!(typeof a === "undefined" || typeof a === "number" && a >= 0 && a <= 1)) {
          return `Invalid rgba value [${[r, g, b, a].join(", ")}]: 'a' must be between 0 and 1.`;
        }
        return null;
      }
      function isValue(mixed) {
        if (mixed === null) {
          return true;
        }
        if (typeof mixed === "string") {
          return true;
        }
        if (typeof mixed === "boolean") {
          return true;
        }
        if (typeof mixed === "number") {
          return true;
        }
        if (mixed instanceof Color) {
          return true;
        }
        if (mixed instanceof Collator) {
          return true;
        }
        if (mixed instanceof Formatted) {
          return true;
        }
        if (Array.isArray(mixed)) {
          for (const item of mixed) {
            if (!isValue(item)) {
              return false;
            }
          }
          return true;
        }
        if (typeof mixed === "object") {
          for (const key in mixed) {
            if (!isValue(mixed[key])) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      function typeOf(value) {
        if (value === null) {
          return NullType;
        }
        if (typeof value === "string") {
          return StringType;
        }
        if (typeof value === "boolean") {
          return BooleanType;
        }
        if (typeof value === "number") {
          return NumberType;
        }
        if (value instanceof Color) {
          return ColorType;
        }
        if (value instanceof Collator) {
          return CollatorType;
        }
        if (value instanceof Formatted) {
          return FormattedType;
        }
        if (Array.isArray(value)) {
          const length = value.length;
          let itemType;
          for (const item of value) {
            const t = typeOf(item);
            if (!itemType) {
              itemType = t;
            } else if (itemType === t) {
            } else {
              itemType = ValueType;
              break;
            }
          }
          return array(itemType || ValueType, length);
        }
        assert(typeof value === "object");
        return ObjectType;
      }
      function toString(value) {
        const type = typeof value;
        if (value === null) {
          return "";
        }
        if (type === "string" || type === "number" || type === "boolean") {
          return String(value);
        }
        if (value instanceof Color || value instanceof Formatted) {
          return value.toString();
        }
        return JSON.stringify(value);
      }
      module.exports = {
        toString,
        Color,
        Collator,
        validateRGBA,
        isValue,
        typeOf
      };
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/literal.js
  var require_literal = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/literal.js"(exports, module) {
      var assert = require_nanoassert();
      var { isValue, typeOf, Color } = require_values();
      var { Formatted } = require_formatted();
      var Literal = class _Literal {
        constructor(type, value) {
          this.type = type;
          this.value = value;
        }
        static parse(args, context) {
          if (args.length !== 2)
            return context.error(`'literal' expression requires exactly one argument, but found ${args.length - 1} instead.`);
          if (!isValue(args[1])) return context.error("invalid value");
          const value = args[1];
          let type = typeOf(value);
          const expected = context.expectedType;
          if (type.kind === "array" && type.N === 0 && expected && expected.kind === "array" && (typeof expected.N !== "number" || expected.N === 0)) {
            type = expected;
          }
          return new _Literal(type, value);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        possibleOutputs() {
          return [this.value];
        }
        serialize() {
          if (this.type.kind === "array" || this.type.kind === "object") {
            return ["literal", this.value];
          }
          if (this.value instanceof Color) {
            return ["rgba"].concat(this.value.toArray());
          }
          if (this.value instanceof Formatted) {
            return this.value.serialize();
          }
          assert(
            this.value === null || typeof this.value === "string" || typeof this.value === "number" || typeof this.value === "boolean"
          );
          return this.value;
        }
      };
      module.exports = Literal;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/runtime_error.js
  var require_runtime_error = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/runtime_error.js"(exports, module) {
      var RuntimeError = class {
        constructor(message) {
          this.name = "ExpressionEvaluationError";
          this.message = message;
        }
        toJSON() {
          return this.message;
        }
      };
      module.exports = RuntimeError;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/assertion.js
  var require_assertion = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/assertion.js"(exports, module) {
      var assert = require_nanoassert();
      var {
        ObjectType,
        ValueType,
        StringType,
        NumberType,
        BooleanType,
        checkSubtype,
        toString,
        array
      } = require_types();
      var RuntimeError = require_runtime_error();
      var { typeOf } = require_values();
      var types = {
        string: StringType,
        number: NumberType,
        boolean: BooleanType,
        object: ObjectType
      };
      var Assertion = class _Assertion {
        constructor(type, args) {
          this.type = type;
          this.args = args;
        }
        static parse(args, context) {
          if (args.length < 2) return context.error("Expected at least one argument.");
          let i = 1;
          let type;
          const name = args[0];
          if (name === "array") {
            let itemType;
            if (args.length > 2) {
              const type2 = args[1];
              if (typeof type2 !== "string" || !(type2 in types) || type2 === "object")
                return context.error('The item type argument of "array" must be one of string, number, boolean', 1);
              itemType = types[type2];
              i++;
            } else {
              itemType = ValueType;
            }
            let N;
            if (args.length > 3) {
              if (args[2] !== null && (typeof args[2] !== "number" || args[2] < 0 || args[2] !== Math.floor(args[2]))) {
                return context.error('The length argument to "array" must be a positive integer literal', 2);
              }
              N = args[2];
              i++;
            }
            type = array(itemType, N);
          } else {
            assert(types[name], name);
            type = types[name];
          }
          const parsed = [];
          for (; i < args.length; i++) {
            const input = context.parse(args[i], i, ValueType);
            if (!input) return null;
            parsed.push(input);
          }
          return new _Assertion(type, parsed);
        }
        evaluate(ctx) {
          for (let i = 0; i < this.args.length; i++) {
            const value = this.args[i].evaluate(ctx);
            const error = checkSubtype(this.type, typeOf(value));
            if (!error) {
              return value;
            }
            if (i === this.args.length - 1) {
              throw new RuntimeError(
                `Expected value to be of type ${toString(this.type)}, but found ${toString(typeOf(value))} instead.`
              );
            }
          }
          assert(false);
          return null;
        }
        eachChild(fn) {
          this.args.forEach(fn);
        }
        possibleOutputs() {
          return [].concat(...this.args.map((arg) => arg.possibleOutputs()));
        }
        serialize() {
          const type = this.type;
          const serialized = [type.kind];
          if (type.kind === "array") {
            const itemType = type.itemType;
            if (itemType.kind === "string" || itemType.kind === "number" || itemType.kind === "boolean") {
              serialized.push(itemType.kind);
              const N = type.N;
              if (typeof N === "number" || this.args.length > 1) {
                serialized.push(N);
              }
            }
          }
          return serialized.concat(this.args.map((arg) => arg.serialize()));
        }
      };
      module.exports = Assertion;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/format.js
  var require_format = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/format.js"(exports, module) {
      var { NumberType, ValueType, FormattedType, array, StringType } = require_types();
      var { Formatted, FormattedSection } = require_formatted();
      var { toString } = require_values();
      var FormatExpression = class _FormatExpression {
        constructor(sections) {
          this.type = FormattedType;
          this.sections = sections;
        }
        static parse(args, context) {
          if (args.length < 3) {
            return context.error("Expected at least two arguments.");
          }
          if ((args.length - 1) % 2 !== 0) {
            return context.error("Expected an even number of arguments.");
          }
          const sections = [];
          for (let i = 1; i < args.length - 1; i += 2) {
            const text = context.parse(args[i], 1, ValueType);
            if (!text) return null;
            const kind = text.type.kind;
            if (kind !== "string" && kind !== "value" && kind !== "null")
              return context.error("Formatted text type must be 'string', 'value', or 'null'.");
            const options = args[i + 1];
            if (typeof options !== "object" || Array.isArray(options))
              return context.error("Format options argument must be an object.");
            let scale = null;
            if (options["font-scale"]) {
              scale = context.parse(options["font-scale"], 1, NumberType);
              if (!scale) return null;
            }
            let font = null;
            if (options["text-font"]) {
              font = context.parse(options["text-font"], 1, array(StringType));
              if (!font) return null;
            }
            sections.push({ text, scale, font });
          }
          return new _FormatExpression(sections);
        }
        evaluate(ctx) {
          return new Formatted(
            this.sections.map(
              (section) => new FormattedSection(
                toString(section.text.evaluate(ctx)),
                section.scale ? section.scale.evaluate(ctx) : null,
                section.font ? section.font.evaluate(ctx).join(",") : null
              )
            )
          );
        }
        eachChild(fn) {
          for (const section of this.sections) {
            fn(section.text);
            if (section.scale) {
              fn(section.scale);
            }
            if (section.font) {
              fn(section.font);
            }
          }
        }
        possibleOutputs() {
          return [void 0];
        }
        serialize() {
          const serialized = ["format"];
          for (const section of this.sections) {
            serialized.push(section.text.serialize());
            const options = {};
            if (section.scale) {
              options["font-scale"] = section.scale.serialize();
            }
            if (section.font) {
              options["text-font"] = section.font.serialize();
            }
            serialized.push(options);
          }
          return serialized;
        }
      };
      module.exports = { Formatted, FormatExpression };
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/coercion.js
  var require_coercion = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/coercion.js"(exports, module) {
      var assert = require_nanoassert();
      var { BooleanType, ColorType, NumberType, StringType, ValueType } = require_types();
      var { Color, toString: valueToString, validateRGBA } = require_values();
      var RuntimeError = require_runtime_error();
      var { FormatExpression } = require_format();
      var { Formatted } = require_formatted();
      var types = {
        "to-boolean": BooleanType,
        "to-color": ColorType,
        "to-number": NumberType,
        "to-string": StringType
      };
      var Coercion = class _Coercion {
        constructor(type, args) {
          this.type = type;
          this.args = args;
        }
        static parse(args, context) {
          if (args.length < 2) return context.error("Expected at least one argument.");
          const name = args[0];
          assert(types[name], name);
          if ((name === "to-boolean" || name === "to-string") && args.length !== 2)
            return context.error("Expected one argument.");
          const type = types[name];
          const parsed = [];
          for (let i = 1; i < args.length; i++) {
            const input = context.parse(args[i], i, ValueType);
            if (!input) return null;
            parsed.push(input);
          }
          return new _Coercion(type, parsed);
        }
        evaluate(ctx) {
          if (this.type.kind === "boolean") {
            return Boolean(this.args[0].evaluate(ctx));
          }
          if (this.type.kind === "color") {
            let input;
            let error;
            for (const arg of this.args) {
              input = arg.evaluate(ctx);
              error = null;
              if (input instanceof Color) {
                return input;
              }
              if (typeof input === "string") {
                const c = ctx.parseColor(input);
                if (c) return c;
              } else if (Array.isArray(input)) {
                if (input.length < 3 || input.length > 4) {
                  error = `Invalid rbga value ${JSON.stringify(input)}: expected an array containing either three or four numeric values.`;
                } else {
                  error = validateRGBA(input[0], input[1], input[2], input[3]);
                }
                if (!error) {
                  return new Color(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);
                }
              }
            }
            throw new RuntimeError(
              error || `Could not parse color from value '${typeof input === "string" ? input : JSON.stringify(input)}'`
            );
          }
          if (this.type.kind === "number") {
            let value = null;
            for (const arg of this.args) {
              value = arg.evaluate(ctx);
              if (value === null) return 0;
              const num = Number(value);
              if (isNaN(num)) continue;
              return num;
            }
            throw new RuntimeError(`Could not convert ${JSON.stringify(value)} to number.`);
          }
          if (this.type.kind === "formatted") {
            return Formatted.fromString(valueToString(this.args[0].evaluate(ctx)));
          }
          return valueToString(this.args[0].evaluate(ctx));
        }
        eachChild(fn) {
          this.args.forEach(fn);
        }
        possibleOutputs() {
          return [].concat(...this.args.map((arg) => arg.possibleOutputs()));
        }
        serialize() {
          if (this.type.kind === "formatted") {
            return new FormatExpression([{ text: this.args[0], scale: null, font: null }]).serialize();
          }
          const serialized = [`to-${this.type.kind}`];
          this.eachChild((child) => {
            serialized.push(child.serialize());
          });
          return serialized;
        }
      };
      module.exports = Coercion;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/evaluation_context.js
  var require_evaluation_context = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/evaluation_context.js"(exports, module) {
      var { Color } = require_values();
      var geometryTypes = ["Unknown", "Point", "LineString", "Polygon"];
      var EvaluationContext = class {
        constructor() {
          this.globals = null;
          this.feature = null;
          this.featureState = null;
          this._parseColorCache = {};
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type === "number" ? geometryTypes[this.feature.type] : this.feature.type : null;
        }
        properties() {
          return this.feature?.properties || {};
        }
        parseColor(input) {
          let cached = this._parseColorCache[input];
          if (!cached) {
            cached = this._parseColorCache[input] = Color.parse(input);
          }
          return cached;
        }
      };
      module.exports = EvaluationContext;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/collator.js
  var require_collator2 = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/collator.js"(exports, module) {
      var { StringType, BooleanType, CollatorType } = require_types();
      var { Collator } = require_collator();
      var CollatorExpression = class _CollatorExpression {
        constructor(caseSensitive, diacriticSensitive, locale) {
          this.type = CollatorType;
          this.locale = locale;
          this.caseSensitive = caseSensitive;
          this.diacriticSensitive = diacriticSensitive;
        }
        static parse(args, context) {
          if (args.length !== 2) return context.error("Expected one argument.");
          const options = args[1];
          if (typeof options !== "object" || Array.isArray(options))
            return context.error("Collator options argument must be an object.");
          const caseSensitive = context.parse(
            options["case-sensitive"] === void 0 ? false : options["case-sensitive"],
            1,
            BooleanType
          );
          if (!caseSensitive) return null;
          const diacriticSensitive = context.parse(
            options["diacritic-sensitive"] === void 0 ? false : options["diacritic-sensitive"],
            1,
            BooleanType
          );
          if (!diacriticSensitive) return null;
          let locale = null;
          if (options["locale"]) {
            locale = context.parse(options["locale"], 1, StringType);
            if (!locale) return null;
          }
          return new _CollatorExpression(caseSensitive, diacriticSensitive, locale);
        }
        evaluate(ctx) {
          return new Collator(
            this.caseSensitive.evaluate(ctx),
            this.diacriticSensitive.evaluate(ctx),
            this.locale ? this.locale.evaluate(ctx) : null
          );
        }
        eachChild(fn) {
          fn(this.caseSensitive);
          fn(this.diacriticSensitive);
          if (this.locale) {
            fn(this.locale);
          }
        }
        possibleOutputs() {
          return [void 0];
        }
        serialize() {
          const options = {};
          options["case-sensitive"] = this.caseSensitive.serialize();
          options["diacritic-sensitive"] = this.diacriticSensitive.serialize();
          if (this.locale) {
            options["locale"] = this.locale.serialize();
          }
          return ["collator", options];
        }
      };
      module.exports = {
        Collator,
        CollatorExpression
      };
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/compound_expression.js
  var require_compound_expression = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/compound_expression.js"(exports, module) {
      var { toString } = require_types();
      var assert = require_nanoassert();
      var CompoundExpression = class _CompoundExpression {
        constructor(name, type, evaluate, args) {
          this.name = name;
          this.type = type;
          this._evaluate = evaluate;
          this.args = args;
        }
        evaluate(ctx) {
          return this._evaluate(ctx, this.args);
        }
        eachChild(fn) {
          this.args.forEach(fn);
        }
        possibleOutputs() {
          return [void 0];
        }
        serialize() {
          return [this.name].concat(this.args.map((arg) => arg.serialize()));
        }
        static parse(args, context) {
          const ParsingContext = require_parsing_context();
          const op = args[0];
          const definition = _CompoundExpression.definitions[op];
          if (!definition) {
            return context.error(`Unknown expression "${op}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          const type = Array.isArray(definition) ? definition[0] : definition.type;
          const availableOverloads = Array.isArray(definition) ? [[definition[1], definition[2]]] : definition.overloads;
          const overloads = availableOverloads.filter(
            ([signature]) => !Array.isArray(signature) || // varags
            signature.length === args.length - 1
            // correct param count
          );
          let signatureContext = null;
          for (const [params, evaluate] of overloads) {
            signatureContext = new ParsingContext(context.registry, context.path, null, context.scope);
            const parsedArgs = [];
            let argParseFailed = false;
            for (let i = 1; i < args.length; i++) {
              const arg = args[i];
              const expectedType = Array.isArray(params) ? params[i - 1] : params.type;
              const parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);
              if (!parsed) {
                argParseFailed = true;
                break;
              }
              parsedArgs.push(parsed);
            }
            if (argParseFailed) {
              continue;
            }
            if (Array.isArray(params)) {
              if (params.length !== parsedArgs.length) {
                signatureContext.error(`Expected ${params.length} arguments, but found ${parsedArgs.length} instead.`);
                continue;
              }
            }
            for (let i = 0; i < parsedArgs.length; i++) {
              const expected = Array.isArray(params) ? params[i] : params.type;
              const arg = parsedArgs[i];
              signatureContext.concat(i + 1).checkSubtype(expected, arg.type);
            }
            if (signatureContext.errors.length === 0) {
              return new _CompoundExpression(op, type, evaluate, parsedArgs);
            }
          }
          assert(!signatureContext || signatureContext.errors.length > 0);
          if (overloads.length === 1) {
            context.errors.push.apply(context.errors, signatureContext.errors);
          } else {
            const expected = overloads.length ? overloads : availableOverloads;
            const signatures = expected.map(([params]) => stringifySignature(params)).join(" | ");
            const actualTypes = [];
            for (let i = 1; i < args.length; i++) {
              const parsed = context.parse(args[i], 1 + actualTypes.length);
              if (!parsed) return null;
              actualTypes.push(toString(parsed.type));
            }
            context.error(`Expected arguments of type ${signatures}, but found (${actualTypes.join(", ")}) instead.`);
          }
          return null;
        }
        static register(registry, definitions) {
          assert(!_CompoundExpression.definitions);
          _CompoundExpression.definitions = definitions;
          for (const name in definitions) {
            registry[name] = _CompoundExpression;
          }
        }
      };
      function stringifySignature(signature) {
        if (Array.isArray(signature)) {
          return `(${signature.map(toString).join(", ")})`;
        }
        return `(${toString(signature.type)}...)`;
      }
      module.exports = CompoundExpression;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/is_constant.js
  var require_is_constant = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/is_constant.js"(exports, module) {
      var CompoundExpression = require_compound_expression();
      function isFeatureConstant(e) {
        if (e instanceof CompoundExpression) {
          if (e.name === "get" && e.args.length === 1) {
            return false;
          }
          if (e.name === "feature-state") {
            return false;
          }
          if (e.name === "has" && e.args.length === 1) {
            return false;
          }
          if (e.name === "properties" || e.name === "geometry-type" || e.name === "id") {
            return false;
          }
          if (/^filter-/.test(e.name)) {
            return false;
          }
        }
        let result = true;
        e.eachChild((arg) => {
          if (result && !isFeatureConstant(arg)) {
            result = false;
          }
        });
        return result;
      }
      function isStateConstant(e) {
        if (e instanceof CompoundExpression) {
          if (e.name === "feature-state") {
            return false;
          }
        }
        let result = true;
        e.eachChild((arg) => {
          if (result && !isStateConstant(arg)) {
            result = false;
          }
        });
        return result;
      }
      function isGlobalPropertyConstant(e, properties) {
        if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) {
          return false;
        }
        let result = true;
        e.eachChild((arg) => {
          if (result && !isGlobalPropertyConstant(arg, properties)) {
            result = false;
          }
        });
        return result;
      }
      module.exports = {
        isFeatureConstant,
        isGlobalPropertyConstant,
        isStateConstant
      };
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/var.js
  var require_var = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/var.js"(exports, module) {
      var Var = class _Var {
        constructor(name, boundExpression) {
          this.type = boundExpression.type;
          this.name = name;
          this.boundExpression = boundExpression;
        }
        static parse(args, context) {
          if (args.length !== 2 || typeof args[1] !== "string")
            return context.error(`'var' expression requires exactly one string literal argument.`);
          const name = args[1];
          if (!context.scope.has(name)) {
            return context.error(
              `Unknown variable "${name}". Make sure "${name}" has been bound in an enclosing "let" expression before using it.`,
              1
            );
          }
          return new _Var(name, context.scope.get(name));
        }
        evaluate(ctx) {
          return this.boundExpression.evaluate(ctx);
        }
        eachChild() {
        }
        possibleOutputs() {
          return [void 0];
        }
        serialize() {
          return ["var", this.name];
        }
      };
      module.exports = Var;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/parsing_context.js
  var require_parsing_context = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/parsing_context.js"(exports, module) {
      var assert = require_nanoassert();
      var Scope = require_scope();
      var { checkSubtype } = require_types();
      var ParsingError = require_parsing_error();
      var Literal = require_literal();
      var Assertion = require_assertion();
      var Coercion = require_coercion();
      var EvaluationContext = require_evaluation_context();
      var { CollatorExpression } = require_collator2();
      var { isGlobalPropertyConstant, isFeatureConstant } = require_is_constant();
      var Var = require_var();
      var ParsingContext = class _ParsingContext {
        // The expected type of this expression. Provided only to allow Expression
        // implementations to infer argument types: Expression#parse() need not
        // check that the output type of the parsed expression matches
        // `expectedType`.
        constructor(registry, path = [], expectedType, scope = new Scope(), errors = []) {
          this.registry = registry;
          this.path = path;
          this.key = path.map((part) => `[${part}]`).join("");
          this.scope = scope;
          this.errors = errors;
          this.expectedType = expectedType;
        }
        /**
         * @param expr the JSON expression to parse
         * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed
         * @param options
         * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.
         * @private
         */
        parse(expr, index, expectedType, bindings, options = {}) {
          if (index) {
            return this.concat(index, expectedType, bindings)._parse(expr, options);
          }
          return this._parse(expr, options);
        }
        _parse(expr, options) {
          if (expr === null || typeof expr === "string" || typeof expr === "boolean" || typeof expr === "number") {
            expr = ["literal", expr];
          }
          function annotate(parsed, type, typeAnnotation) {
            if (typeAnnotation === "assert") {
              return new Assertion(type, [parsed]);
            }
            if (typeAnnotation === "coerce") {
              return new Coercion(type, [parsed]);
            }
            return parsed;
          }
          if (Array.isArray(expr)) {
            if (expr.length === 0) {
              return this.error(
                `Expected an array with at least one element. If you wanted a literal array, use ["literal", []].`
              );
            }
            const op = expr[0];
            if (typeof op !== "string") {
              this.error(
                `Expression name must be a string, but found ${typeof op} instead. If you wanted a literal array, use ["literal", [...]].`,
                0
              );
              return null;
            }
            const Expr = this.registry[op];
            if (Expr) {
              let parsed = Expr.parse(expr, this);
              if (!parsed) return null;
              if (this.expectedType) {
                const expected = this.expectedType;
                const actual = parsed.type;
                if ((expected.kind === "string" || expected.kind === "number" || expected.kind === "boolean" || expected.kind === "object" || expected.kind === "array") && actual.kind === "value") {
                  parsed = annotate(parsed, expected, options.typeAnnotation || "assert");
                } else if ((expected.kind === "color" || expected.kind === "formatted") && (actual.kind === "value" || actual.kind === "string")) {
                  parsed = annotate(parsed, expected, options.typeAnnotation || "coerce");
                } else if (this.checkSubtype(expected, actual)) {
                  return null;
                }
              }
              if (!(parsed instanceof Literal) && isConstant(parsed)) {
                const ec = new EvaluationContext();
                try {
                  parsed = new Literal(parsed.type, parsed.evaluate(ec));
                } catch (e) {
                  this.error(e.message);
                  return null;
                }
              }
              return parsed;
            }
            return this.error(`Unknown expression "${op}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          if (typeof expr === "undefined") {
            return this.error(`'undefined' value invalid. Use null instead.`);
          }
          if (typeof expr === "object") {
            return this.error(`Bare objects invalid. Use ["literal", {...}] instead.`);
          }
          return this.error(`Expected an array, but found ${typeof expr} instead.`);
        }
        /**
         * Returns a copy of this context suitable for parsing the subexpression at
         * index `index`, optionally appending to 'let' binding map.
         *
         * Note that `errors` property, intended for collecting errors while
         * parsing, is copied by reference rather than cloned.
         * @private
         */
        concat(index, expectedType, bindings) {
          const path = typeof index === "number" ? this.path.concat(index) : this.path;
          const scope = bindings ? this.scope.concat(bindings) : this.scope;
          return new _ParsingContext(this.registry, path, expectedType || null, scope, this.errors);
        }
        /**
         * Push a parsing (or type checking) error into the `this.errors`
         * @param error The message
         * @param keys Optionally specify the source of the error at a child
         * of the current expression at `this.key`.
         * @private
         */
        error(error, ...keys) {
          const key = `${this.key}${keys.map((k) => `[${k}]`).join("")}`;
          this.errors.push(new ParsingError(key, error));
        }
        /**
         * Returns null if `t` is a subtype of `expected`; otherwise returns an
         * error message and also pushes it to `this.errors`.
         */
        checkSubtype(expected, t) {
          const error = checkSubtype(expected, t);
          if (error) this.error(error);
          return error;
        }
      };
      module.exports = ParsingContext;
      function isConstant(expression) {
        const CompoundExpression = require_compound_expression();
        if (expression instanceof Var) {
          return isConstant(expression.boundExpression);
        }
        if (expression instanceof CompoundExpression && expression.name === "error") {
          return false;
        }
        if (expression instanceof CollatorExpression) {
          return false;
        }
        const isTypeAnnotation = expression instanceof Coercion || expression instanceof Assertion;
        let childrenConstant = true;
        expression.eachChild((child) => {
          if (isTypeAnnotation) {
            childrenConstant = childrenConstant && isConstant(child);
          } else {
            childrenConstant = childrenConstant && child instanceof Literal;
          }
        });
        if (!childrenConstant) {
          return false;
        }
        return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, ["zoom", "heatmap-density", "line-progress", "is-supported-script"]);
      }
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/stops.js
  var require_stops = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/stops.js"(exports, module) {
      var RuntimeError = require_runtime_error();
      function findStopLessThanOrEqualTo(stops, input) {
        const n = stops.length;
        let lowerIndex = 0;
        let upperIndex = n - 1;
        let currentIndex = 0;
        let currentValue;
        let upperValue;
        while (lowerIndex <= upperIndex) {
          currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
          currentValue = stops[currentIndex];
          upperValue = stops[currentIndex + 1];
          if (input === currentValue || input > currentValue && input < upperValue) {
            return currentIndex;
          }
          if (currentValue < input) {
            lowerIndex = currentIndex + 1;
          } else if (currentValue > input) {
            upperIndex = currentIndex - 1;
          } else {
            throw new RuntimeError("Input is not a number.");
          }
        }
        return Math.max(currentIndex - 1, 0);
      }
      module.exports = {
        findStopLessThanOrEqualTo
      };
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/step.js
  var require_step = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/step.js"(exports, module) {
      var { NumberType } = require_types();
      var { findStopLessThanOrEqualTo } = require_stops();
      var Step = class _Step {
        constructor(type, input, stops) {
          this.type = type;
          this.input = input;
          this.labels = [];
          this.outputs = [];
          for (const [label, expression] of stops) {
            this.labels.push(label);
            this.outputs.push(expression);
          }
        }
        static parse(args, context) {
          let [, input, ...rest] = args;
          if (args.length - 1 < 4) {
            return context.error(`Expected at least 4 arguments, but found only ${args.length - 1}.`);
          }
          if ((args.length - 1) % 2 !== 0) {
            return context.error("Expected an even number of arguments.");
          }
          input = context.parse(input, 1, NumberType);
          if (!input) return null;
          const stops = [];
          let outputType = null;
          if (context.expectedType && context.expectedType.kind !== "value") {
            outputType = context.expectedType;
          }
          rest.unshift(Number.NEGATIVE_INFINITY);
          for (let i = 0; i < rest.length; i += 2) {
            const label = rest[i];
            const value = rest[i + 1];
            const labelKey = i + 1;
            const valueKey = i + 2;
            if (typeof label !== "number") {
              return context.error(
                'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                labelKey
              );
            }
            if (stops.length && stops[stops.length - 1][0] >= label) {
              return context.error(
                'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',
                labelKey
              );
            }
            const parsed = context.parse(value, valueKey, outputType);
            if (!parsed) return null;
            outputType = outputType || parsed.type;
            stops.push([label, parsed]);
          }
          return new _Step(outputType, input, stops);
        }
        evaluate(ctx) {
          const labels = this.labels;
          const outputs = this.outputs;
          if (labels.length === 1) {
            return outputs[0].evaluate(ctx);
          }
          const value = this.input.evaluate(ctx);
          if (value <= labels[0]) {
            return outputs[0].evaluate(ctx);
          }
          const stopCount = labels.length;
          if (value >= labels[stopCount - 1]) {
            return outputs[stopCount - 1].evaluate(ctx);
          }
          const index = findStopLessThanOrEqualTo(labels, value);
          return outputs[index].evaluate(ctx);
        }
        eachChild(fn) {
          fn(this.input);
          for (const expression of this.outputs) {
            fn(expression);
          }
        }
        possibleOutputs() {
          return [].concat(...this.outputs.map((output) => output.possibleOutputs()));
        }
        serialize() {
          const serialized = ["step", this.input.serialize()];
          for (let i = 0; i < this.labels.length; i++) {
            if (i > 0) {
              serialized.push(this.labels[i]);
            }
            serialized.push(this.outputs[i].serialize());
          }
          return serialized;
        }
      };
      module.exports = Step;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/util/interpolate.js
  var require_interpolate = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/util/interpolate.js"(exports, module) {
      var Color = require_color();
      function number(a, b, t) {
        return a * (1 - t) + b * t;
      }
      function color(from, to, t) {
        return new Color(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));
      }
      function array(from, to, t) {
        return from.map((d, i) => {
          return number(d, to[i], t);
        });
      }
      module.exports = {
        number,
        color,
        array
      };
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/util/color_spaces.js
  var require_color_spaces = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/util/color_spaces.js"(exports, module) {
      var Color = require_color();
      var { number: interpolateNumber } = require_interpolate();
      var Xn = 0.95047;
      var Yn = 1;
      var Zn = 1.08883;
      var t0 = 4 / 29;
      var t1 = 6 / 29;
      var t2 = 3 * t1 * t1;
      var t3 = t1 * t1 * t1;
      var deg2rad = Math.PI / 180;
      var rad2deg = 180 / Math.PI;
      function xyz2lab(t) {
        return t > t3 ? t ** (1 / 3) : t / t2 + t0;
      }
      function lab2xyz(t) {
        return t > t1 ? t * t * t : t2 * (t - t0);
      }
      function xyz2rgb(x) {
        return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * x ** (1 / 2.4) - 0.055);
      }
      function rgb2xyz(x) {
        x /= 255;
        return x <= 0.04045 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
      }
      function rgbToLab(rgbColor) {
        const b = rgb2xyz(rgbColor.r);
        const a = rgb2xyz(rgbColor.g);
        const l = rgb2xyz(rgbColor.b);
        const x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn);
        const y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn);
        const z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);
        return {
          l: 116 * y - 16,
          a: 500 * (x - y),
          b: 200 * (y - z),
          alpha: rgbColor.a
        };
      }
      function labToRgb(labColor) {
        let y = (labColor.l + 16) / 116;
        let x = isNaN(labColor.a) ? y : y + labColor.a / 500;
        let z = isNaN(labColor.b) ? y : y - labColor.b / 200;
        y = Yn * lab2xyz(y);
        x = Xn * lab2xyz(x);
        z = Zn * lab2xyz(z);
        return new Color(
          xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z),
          // D65 -> sRGB
          xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z),
          xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z),
          labColor.alpha
        );
      }
      function interpolateLab(from, to, t) {
        return {
          l: interpolateNumber(from.l, to.l, t),
          a: interpolateNumber(from.a, to.a, t),
          b: interpolateNumber(from.b, to.b, t),
          alpha: interpolateNumber(from.alpha, to.alpha, t)
        };
      }
      function rgbToHcl(rgbColor) {
        const { l, a, b } = rgbToLab(rgbColor);
        const h = Math.atan2(b, a) * rad2deg;
        return {
          h: h < 0 ? h + 360 : h,
          c: Math.sqrt(a * a + b * b),
          l,
          alpha: rgbColor.a
        };
      }
      function hclToRgb(hclColor) {
        const h = hclColor.h * deg2rad;
        const c = hclColor.c;
        const l = hclColor.l;
        return labToRgb({
          l,
          a: Math.cos(h) * c,
          b: Math.sin(h) * c,
          alpha: hclColor.alpha
        });
      }
      function interpolateHue(a, b, t) {
        const d = b - a;
        return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);
      }
      function interpolateHcl(from, to, t) {
        return {
          h: interpolateHue(from.h, to.h, t),
          c: interpolateNumber(from.c, to.c, t),
          l: interpolateNumber(from.l, to.l, t),
          alpha: interpolateNumber(from.alpha, to.alpha, t)
        };
      }
      var lab = {
        forward: rgbToLab,
        reverse: labToRgb,
        interpolate: interpolateLab
      };
      var hcl = {
        forward: rgbToHcl,
        reverse: hclToRgb,
        interpolate: interpolateHcl
      };
      module.exports = {
        lab,
        hcl
      };
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/interpolate.js
  var require_interpolate2 = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/interpolate.js"(exports, module) {
      var UnitBezier2 = require_unitbezier();
      var interpolate2 = require_interpolate();
      var { toString, ColorType, NumberType } = require_types();
      var { findStopLessThanOrEqualTo } = require_stops();
      var { hcl, lab } = require_color_spaces();
      var Interpolate = class _Interpolate {
        constructor(type, operator, interpolation, input, stops) {
          this.type = type;
          this.operator = operator;
          this.interpolation = interpolation;
          this.input = input;
          this.labels = [];
          this.outputs = [];
          for (const [label, expression] of stops) {
            this.labels.push(label);
            this.outputs.push(expression);
          }
        }
        static interpolationFactor(interpolation, input, lower, upper) {
          let t = 0;
          if (interpolation.name === "exponential") {
            t = exponentialInterpolation(input, interpolation.base, lower, upper);
          } else if (interpolation.name === "linear") {
            t = exponentialInterpolation(input, 1, lower, upper);
          } else if (interpolation.name === "cubic-bezier") {
            const c = interpolation.controlPoints;
            const ub = new UnitBezier2(c[0], c[1], c[2], c[3]);
            t = ub.solve(exponentialInterpolation(input, 1, lower, upper));
          }
          return t;
        }
        static parse(args, context) {
          let [operator, interpolation, input, ...rest] = args;
          if (!Array.isArray(interpolation) || interpolation.length === 0) {
            return context.error("Expected an interpolation type expression.", 1);
          }
          if (interpolation[0] === "linear") {
            interpolation = { name: "linear" };
          } else if (interpolation[0] === "exponential") {
            const base = interpolation[1];
            if (typeof base !== "number") return context.error("Exponential interpolation requires a numeric base.", 1, 1);
            interpolation = {
              name: "exponential",
              base
            };
          } else if (interpolation[0] === "cubic-bezier") {
            const controlPoints = interpolation.slice(1);
            if (controlPoints.length !== 4 || controlPoints.some((t) => typeof t !== "number" || t < 0 || t > 1)) {
              return context.error(
                "Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",
                1
              );
            }
            interpolation = {
              name: "cubic-bezier",
              controlPoints
            };
          } else {
            return context.error(`Unknown interpolation type ${String(interpolation[0])}`, 1, 0);
          }
          if (args.length - 1 < 4) {
            return context.error(`Expected at least 4 arguments, but found only ${args.length - 1}.`);
          }
          if ((args.length - 1) % 2 !== 0) {
            return context.error("Expected an even number of arguments.");
          }
          input = context.parse(input, 2, NumberType);
          if (!input) return null;
          const stops = [];
          let outputType = null;
          if (operator === "interpolate-hcl" || operator === "interpolate-lab") {
            outputType = ColorType;
          } else if (context.expectedType && context.expectedType.kind !== "value") {
            outputType = context.expectedType;
          }
          for (let i = 0; i < rest.length; i += 2) {
            const label = rest[i];
            const value = rest[i + 1];
            const labelKey = i + 3;
            const valueKey = i + 4;
            if (typeof label !== "number") {
              return context.error(
                'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                labelKey
              );
            }
            if (stops.length && stops[stops.length - 1][0] >= label) {
              return context.error(
                'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',
                labelKey
              );
            }
            const parsed = context.parse(value, valueKey, outputType);
            if (!parsed) return null;
            outputType = outputType || parsed.type;
            stops.push([label, parsed]);
          }
          if (outputType.kind !== "number" && outputType.kind !== "color" && !(outputType.kind === "array" && outputType.itemType.kind === "number" && typeof outputType.N === "number")) {
            return context.error(`Type ${toString(outputType)} is not interpolatable.`);
          }
          return new _Interpolate(outputType, operator, interpolation, input, stops);
        }
        evaluate(ctx) {
          const labels = this.labels;
          const outputs = this.outputs;
          if (labels.length === 1) {
            return outputs[0].evaluate(ctx);
          }
          const value = this.input.evaluate(ctx);
          if (value <= labels[0]) {
            return outputs[0].evaluate(ctx);
          }
          const stopCount = labels.length;
          if (value >= labels[stopCount - 1]) {
            return outputs[stopCount - 1].evaluate(ctx);
          }
          const index = findStopLessThanOrEqualTo(labels, value);
          const lower = labels[index];
          const upper = labels[index + 1];
          const t = _Interpolate.interpolationFactor(this.interpolation, value, lower, upper);
          const outputLower = outputs[index].evaluate(ctx);
          const outputUpper = outputs[index + 1].evaluate(ctx);
          if (this.operator === "interpolate") {
            return interpolate2[this.type.kind.toLowerCase()](outputLower, outputUpper, t);
          }
          if (this.operator === "interpolate-hcl") {
            return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));
          }
          return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));
        }
        eachChild(fn) {
          fn(this.input);
          for (const expression of this.outputs) {
            fn(expression);
          }
        }
        possibleOutputs() {
          return [].concat(...this.outputs.map((output) => output.possibleOutputs()));
        }
        serialize() {
          let interpolation;
          if (this.interpolation.name === "linear") {
            interpolation = ["linear"];
          } else if (this.interpolation.name === "exponential") {
            if (this.interpolation.base === 1) {
              interpolation = ["linear"];
            } else {
              interpolation = ["exponential", this.interpolation.base];
            }
          } else {
            interpolation = ["cubic-bezier"].concat(this.interpolation.controlPoints);
          }
          const serialized = [this.operator, interpolation, this.input.serialize()];
          for (let i = 0; i < this.labels.length; i++) {
            serialized.push(this.labels[i], this.outputs[i].serialize());
          }
          return serialized;
        }
      };
      function exponentialInterpolation(input, base, lowerValue, upperValue) {
        const difference = upperValue - lowerValue;
        const progress = input - lowerValue;
        if (difference === 0) {
          return 0;
        }
        if (base === 1) {
          return progress / difference;
        }
        return (base ** progress - 1) / (base ** difference - 1);
      }
      module.exports = Interpolate;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/coalesce.js
  var require_coalesce = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/coalesce.js"(exports, module) {
      var assert = require_nanoassert();
      var { checkSubtype, ValueType } = require_types();
      var Coalesce = class _Coalesce {
        constructor(type, args) {
          this.type = type;
          this.args = args;
        }
        static parse(args, context) {
          if (args.length < 2) {
            return context.error("Expectected at least one argument.");
          }
          let outputType = null;
          const expectedType = context.expectedType;
          if (expectedType && expectedType.kind !== "value") {
            outputType = expectedType;
          }
          const parsedArgs = [];
          for (const arg of args.slice(1)) {
            const parsed = context.parse(arg, 1 + parsedArgs.length, outputType, void 0, { typeAnnotation: "omit" });
            if (!parsed) return null;
            outputType = outputType || parsed.type;
            parsedArgs.push(parsed);
          }
          assert(outputType);
          const needsAnnotation = expectedType && parsedArgs.some((arg) => checkSubtype(expectedType, arg.type));
          return needsAnnotation ? new _Coalesce(ValueType, parsedArgs) : new _Coalesce(outputType, parsedArgs);
        }
        evaluate(ctx) {
          let result = null;
          for (const arg of this.args) {
            result = arg.evaluate(ctx);
            if (result !== null) break;
          }
          return result;
        }
        eachChild(fn) {
          this.args.forEach(fn);
        }
        possibleOutputs() {
          return [].concat(...this.args.map((arg) => arg.possibleOutputs()));
        }
        serialize() {
          const serialized = ["coalesce"];
          this.eachChild((child) => {
            serialized.push(child.serialize());
          });
          return serialized;
        }
      };
      module.exports = Coalesce;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/let.js
  var require_let = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/let.js"(exports, module) {
      var Let = class _Let {
        constructor(bindings, result) {
          this.type = result.type;
          this.bindings = [].concat(bindings);
          this.result = result;
        }
        evaluate(ctx) {
          return this.result.evaluate(ctx);
        }
        eachChild(fn) {
          for (const binding of this.bindings) {
            fn(binding[1]);
          }
          fn(this.result);
        }
        static parse(args, context) {
          if (args.length < 4) return context.error(`Expected at least 3 arguments, but found ${args.length - 1} instead.`);
          const bindings = [];
          for (let i = 1; i < args.length - 1; i += 2) {
            const name = args[i];
            if (typeof name !== "string") {
              return context.error(`Expected string, but found ${typeof name} instead.`, i);
            }
            if (/[^a-zA-Z0-9_]/.test(name)) {
              return context.error(`Variable names must contain only alphanumeric characters or '_'.`, i);
            }
            const value = context.parse(args[i + 1], i + 1);
            if (!value) return null;
            bindings.push([name, value]);
          }
          const result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);
          if (!result) return null;
          return new _Let(bindings, result);
        }
        possibleOutputs() {
          return this.result.possibleOutputs();
        }
        serialize() {
          const serialized = ["let"];
          for (const [name, expr] of this.bindings) {
            serialized.push(name, expr.serialize());
          }
          serialized.push(this.result.serialize());
          return serialized;
        }
      };
      module.exports = Let;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/at.js
  var require_at = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/at.js"(exports, module) {
      var { array, ValueType, NumberType } = require_types();
      var RuntimeError = require_runtime_error();
      var At = class _At {
        constructor(type, index, input) {
          this.type = type;
          this.index = index;
          this.input = input;
        }
        static parse(args, context) {
          if (args.length !== 3) return context.error(`Expected 2 arguments, but found ${args.length - 1} instead.`);
          const index = context.parse(args[1], 1, NumberType);
          const input = context.parse(args[2], 2, array(context.expectedType || ValueType));
          if (!index || !input) return null;
          const t = input.type;
          return new _At(t.itemType, index, input);
        }
        evaluate(ctx) {
          const index = this.index.evaluate(ctx);
          const array2 = this.input.evaluate(ctx);
          if (index < 0) {
            throw new RuntimeError(`Array index out of bounds: ${index} < 0.`);
          }
          if (index >= array2.length) {
            throw new RuntimeError(`Array index out of bounds: ${index} > ${array2.length - 1}.`);
          }
          if (index !== Math.floor(index)) {
            throw new RuntimeError(`Array index must be an integer, but found ${index} instead.`);
          }
          return array2[index];
        }
        eachChild(fn) {
          fn(this.index);
          fn(this.input);
        }
        possibleOutputs() {
          return [void 0];
        }
        serialize() {
          return ["at", this.index.serialize(), this.input.serialize()];
        }
      };
      module.exports = At;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/match.js
  var require_match = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/match.js"(exports, module) {
      var assert = require_nanoassert();
      var { typeOf } = require_values();
      var { ValueType } = require_types();
      var Match = class _Match {
        constructor(inputType, outputType, input, cases, outputs, otherwise) {
          this.inputType = inputType;
          this.type = outputType;
          this.input = input;
          this.cases = cases;
          this.outputs = outputs;
          this.otherwise = otherwise;
        }
        static parse(args, context) {
          if (args.length < 5) return context.error(`Expected at least 4 arguments, but found only ${args.length - 1}.`);
          if (args.length % 2 !== 1) return context.error("Expected an even number of arguments.");
          let inputType;
          let outputType;
          if (context.expectedType && context.expectedType.kind !== "value") {
            outputType = context.expectedType;
          }
          const cases = {};
          const outputs = [];
          for (let i = 2; i < args.length - 1; i += 2) {
            let labels = args[i];
            const value = args[i + 1];
            if (!Array.isArray(labels)) {
              labels = [labels];
            }
            const labelContext = context.concat(i);
            if (labels.length === 0) {
              return labelContext.error("Expected at least one branch label.");
            }
            for (const label of labels) {
              if (typeof label !== "number" && typeof label !== "string") {
                return labelContext.error("Branch labels must be numbers or strings.");
              }
              if (typeof label === "number" && Math.abs(label) > Number.MAX_SAFE_INTEGER) {
                return labelContext.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              }
              if (typeof label === "number" && Math.floor(label) !== label) {
                return labelContext.error("Numeric branch labels must be integer values.");
              }
              if (!inputType) {
                inputType = typeOf(label);
              } else if (labelContext.checkSubtype(inputType, typeOf(label))) {
                return null;
              }
              if (typeof cases[String(label)] !== "undefined") {
                return labelContext.error("Branch labels must be unique.");
              }
              cases[String(label)] = outputs.length;
            }
            const result = context.parse(value, i, outputType);
            if (!result) return null;
            outputType = outputType || result.type;
            outputs.push(result);
          }
          const input = context.parse(args[1], 1, ValueType);
          if (!input) return null;
          const otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
          if (!otherwise) return null;
          assert(inputType && outputType);
          if (input.type.kind !== "value" && context.concat(1).checkSubtype(inputType, input.type)) {
            return null;
          }
          return new _Match(inputType, outputType, input, cases, outputs, otherwise);
        }
        evaluate(ctx) {
          const input = this.input.evaluate(ctx);
          const output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;
          return output.evaluate(ctx);
        }
        eachChild(fn) {
          fn(this.input);
          this.outputs.forEach(fn);
          fn(this.otherwise);
        }
        possibleOutputs() {
          return [].concat(...this.outputs.map((out) => out.possibleOutputs())).concat(this.otherwise.possibleOutputs());
        }
        serialize() {
          const serialized = ["match", this.input.serialize()];
          const sortedLabels = Object.keys(this.cases).sort();
          const groupedByOutput = [];
          const outputLookup = {};
          for (const label of sortedLabels) {
            const outputIndex = outputLookup[this.cases[label]];
            if (outputIndex === void 0) {
              outputLookup[this.cases[label]] = groupedByOutput.length;
              groupedByOutput.push([this.cases[label], [label]]);
            } else {
              groupedByOutput[outputIndex][1].push(label);
            }
          }
          const coerceLabel = (label) => this.inputType.kind === "number" ? Number(label) : label;
          for (const [outputIndex, labels] of groupedByOutput) {
            if (labels.length === 1) {
              serialized.push(coerceLabel(labels[0]));
            } else {
              serialized.push(labels.map(coerceLabel));
            }
            serialized.push(this.outputs[outputIndex].serialize());
          }
          serialized.push(this.otherwise.serialize());
          return serialized;
        }
      };
      module.exports = Match;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/case.js
  var require_case = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/case.js"(exports, module) {
      var assert = require_nanoassert();
      var { BooleanType } = require_types();
      var Case = class _Case {
        constructor(type, branches, otherwise) {
          this.type = type;
          this.branches = branches;
          this.otherwise = otherwise;
        }
        static parse(args, context) {
          if (args.length < 4) return context.error(`Expected at least 3 arguments, but found only ${args.length - 1}.`);
          if (args.length % 2 !== 0) return context.error("Expected an odd number of arguments.");
          let outputType;
          if (context.expectedType && context.expectedType.kind !== "value") {
            outputType = context.expectedType;
          }
          const branches = [];
          for (let i = 1; i < args.length - 1; i += 2) {
            const test = context.parse(args[i], i, BooleanType);
            if (!test) return null;
            const result = context.parse(args[i + 1], i + 1, outputType);
            if (!result) return null;
            branches.push([test, result]);
            outputType = outputType || result.type;
          }
          const otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
          if (!otherwise) return null;
          assert(outputType);
          return new _Case(outputType, branches, otherwise);
        }
        evaluate(ctx) {
          for (const [test, expression] of this.branches) {
            if (test.evaluate(ctx)) {
              return expression.evaluate(ctx);
            }
          }
          return this.otherwise.evaluate(ctx);
        }
        eachChild(fn) {
          for (const [test, expression] of this.branches) {
            fn(test);
            fn(expression);
          }
          fn(this.otherwise);
        }
        possibleOutputs() {
          return [].concat(...this.branches.map((branch) => branch[1].possibleOutputs())).concat(this.otherwise.possibleOutputs());
        }
        serialize() {
          const serialized = ["case"];
          this.eachChild((child) => {
            serialized.push(child.serialize());
          });
          return serialized;
        }
      };
      module.exports = Case;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/comparison.js
  var require_comparison = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/comparison.js"(exports, module) {
      var { toString, ValueType, BooleanType, CollatorType } = require_types();
      var Assertion = require_assertion();
      var { typeOf } = require_values();
      var RuntimeError = require_runtime_error();
      function isComparableType(op, type) {
        if (op === "==" || op === "!=") {
          return type.kind === "boolean" || type.kind === "string" || type.kind === "number" || type.kind === "null" || type.kind === "value";
        }
        return type.kind === "string" || type.kind === "number" || type.kind === "value";
      }
      function eq(ctx, a, b) {
        return a === b;
      }
      function neq(ctx, a, b) {
        return a !== b;
      }
      function lt(ctx, a, b) {
        return a < b;
      }
      function gt(ctx, a, b) {
        return a > b;
      }
      function lteq(ctx, a, b) {
        return a <= b;
      }
      function gteq(ctx, a, b) {
        return a >= b;
      }
      function eqCollate(ctx, a, b, c) {
        return c.compare(a, b) === 0;
      }
      function neqCollate(ctx, a, b, c) {
        return !eqCollate(ctx, a, b, c);
      }
      function ltCollate(ctx, a, b, c) {
        return c.compare(a, b) < 0;
      }
      function gtCollate(ctx, a, b, c) {
        return c.compare(a, b) > 0;
      }
      function lteqCollate(ctx, a, b, c) {
        return c.compare(a, b) <= 0;
      }
      function gteqCollate(ctx, a, b, c) {
        return c.compare(a, b) >= 0;
      }
      function makeComparison(op, compareBasic, compareWithCollator) {
        const isOrderComparison = op !== "==" && op !== "!=";
        return class Comparison {
          constructor(lhs, rhs, collator) {
            this.type = BooleanType;
            this.lhs = lhs;
            this.rhs = rhs;
            this.collator = collator;
            this.hasUntypedArgument = lhs.type.kind === "value" || rhs.type.kind === "value";
          }
          static parse(args, context) {
            if (args.length !== 3 && args.length !== 4) return context.error("Expected two or three arguments.");
            const op2 = args[0];
            let lhs = context.parse(args[1], 1, ValueType);
            if (!lhs) return null;
            if (!isComparableType(op2, lhs.type)) {
              return context.concat(1).error(`"${op2}" comparisons are not supported for type '${toString(lhs.type)}'.`);
            }
            let rhs = context.parse(args[2], 2, ValueType);
            if (!rhs) return null;
            if (!isComparableType(op2, rhs.type)) {
              return context.concat(2).error(`"${op2}" comparisons are not supported for type '${toString(rhs.type)}'.`);
            }
            if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== "value" && rhs.type.kind !== "value") {
              return context.error(`Cannot compare types '${toString(lhs.type)}' and '${toString(rhs.type)}'.`);
            }
            if (isOrderComparison) {
              if (lhs.type.kind === "value" && rhs.type.kind !== "value") {
                lhs = new Assertion(rhs.type, [lhs]);
              } else if (lhs.type.kind !== "value" && rhs.type.kind === "value") {
                rhs = new Assertion(lhs.type, [rhs]);
              }
            }
            let collator = null;
            if (args.length === 4) {
              if (lhs.type.kind !== "string" && rhs.type.kind !== "string" && lhs.type.kind !== "value" && rhs.type.kind !== "value") {
                return context.error("Cannot use collator to compare non-string types.");
              }
              collator = context.parse(args[3], 3, CollatorType);
              if (!collator) return null;
            }
            return new Comparison(lhs, rhs, collator);
          }
          evaluate(ctx) {
            const lhs = this.lhs.evaluate(ctx);
            const rhs = this.rhs.evaluate(ctx);
            if (isOrderComparison && this.hasUntypedArgument) {
              const lt2 = typeOf(lhs);
              const rt = typeOf(rhs);
              if (lt2.kind !== rt.kind || !(lt2.kind === "string" || lt2.kind === "number")) {
                throw new RuntimeError(
                  `Expected arguments for "${op}" to be (string, string) or (number, number), but found (${lt2.kind}, ${rt.kind}) instead.`
                );
              }
            }
            if (this.collator && !isOrderComparison && this.hasUntypedArgument) {
              const lt2 = typeOf(lhs);
              const rt = typeOf(rhs);
              if (lt2.kind !== "string" || rt.kind !== "string") {
                return compareBasic(ctx, lhs, rhs);
              }
            }
            return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);
          }
          eachChild(fn) {
            fn(this.lhs);
            fn(this.rhs);
            if (this.collator) {
              fn(this.collator);
            }
          }
          possibleOutputs() {
            return [true, false];
          }
          serialize() {
            const serialized = [op];
            this.eachChild((child) => {
              serialized.push(child.serialize());
            });
            return serialized;
          }
        };
      }
      module.exports = {
        Equals: makeComparison("==", eq, eqCollate),
        NotEquals: makeComparison("!=", neq, neqCollate),
        LessThan: makeComparison("<", lt, ltCollate),
        GreaterThan: makeComparison(">", gt, gtCollate),
        LessThanOrEqual: makeComparison("<=", lteq, lteqCollate),
        GreaterThanOrEqual: makeComparison(">=", gteq, gteqCollate)
      };
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/length.js
  var require_length = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/length.js"(exports, module) {
      var { NumberType, toString } = require_types();
      var { typeOf } = require_values();
      var RuntimeError = require_runtime_error();
      var Length = class _Length {
        constructor(input) {
          this.type = NumberType;
          this.input = input;
        }
        static parse(args, context) {
          if (args.length !== 2) return context.error(`Expected 1 argument, but found ${args.length - 1} instead.`);
          const input = context.parse(args[1], 1);
          if (!input) return null;
          if (input.type.kind !== "array" && input.type.kind !== "string" && input.type.kind !== "value")
            return context.error(`Expected argument of type string or array, but found ${toString(input.type)} instead.`);
          return new _Length(input);
        }
        evaluate(ctx) {
          const input = this.input.evaluate(ctx);
          if (typeof input === "string") {
            return input.length;
          }
          if (Array.isArray(input)) {
            return input.length;
          }
          throw new RuntimeError(
            `Expected value to be of type string or array, but found ${toString(typeOf(input))} instead.`
          );
        }
        eachChild(fn) {
          fn(this.input);
        }
        possibleOutputs() {
          return [void 0];
        }
        serialize() {
          const serialized = ["length"];
          this.eachChild((child) => {
            serialized.push(child.serialize());
          });
          return serialized;
        }
      };
      module.exports = Length;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/definitions/index.js
  var require_definitions = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/definitions/index.js"(exports, module) {
      var {
        NumberType,
        StringType,
        BooleanType,
        ColorType,
        ObjectType,
        ValueType,
        ErrorType,
        CollatorType,
        array,
        toString: typeToString
      } = require_types();
      var { typeOf, Color, validateRGBA, toString: valueToString } = require_values();
      var CompoundExpression = require_compound_expression();
      var RuntimeError = require_runtime_error();
      var Let = require_let();
      var Var = require_var();
      var Literal = require_literal();
      var Assertion = require_assertion();
      var Coercion = require_coercion();
      var At = require_at();
      var Match = require_match();
      var Case = require_case();
      var Step = require_step();
      var Interpolate = require_interpolate2();
      var Coalesce = require_coalesce();
      var { Equals, NotEquals, LessThan, GreaterThan, LessThanOrEqual, GreaterThanOrEqual } = require_comparison();
      var { CollatorExpression } = require_collator2();
      var { FormatExpression } = require_format();
      var Length = require_length();
      var expressions = {
        // special forms
        "==": Equals,
        "!=": NotEquals,
        ">": GreaterThan,
        "<": LessThan,
        ">=": GreaterThanOrEqual,
        "<=": LessThanOrEqual,
        array: Assertion,
        at: At,
        boolean: Assertion,
        case: Case,
        coalesce: Coalesce,
        collator: CollatorExpression,
        format: FormatExpression,
        interpolate: Interpolate,
        "interpolate-hcl": Interpolate,
        "interpolate-lab": Interpolate,
        length: Length,
        let: Let,
        literal: Literal,
        match: Match,
        number: Assertion,
        object: Assertion,
        step: Step,
        string: Assertion,
        "to-boolean": Coercion,
        "to-color": Coercion,
        "to-number": Coercion,
        "to-string": Coercion,
        var: Var
      };
      function rgba(ctx, [r, g, b, a]) {
        r = r.evaluate(ctx);
        g = g.evaluate(ctx);
        b = b.evaluate(ctx);
        const alpha = a ? a.evaluate(ctx) : 1;
        const error = validateRGBA(r, g, b, alpha);
        if (error) throw new RuntimeError(error);
        return new Color(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);
      }
      function has(key, obj) {
        return key in obj;
      }
      function get(key, obj) {
        const v = obj[key];
        return typeof v === "undefined" ? null : v;
      }
      function binarySearch(v, a, i, j) {
        while (i <= j) {
          const m = i + j >> 1;
          if (a[m] === v) return true;
          if (a[m] > v) j = m - 1;
          else i = m + 1;
        }
        return false;
      }
      function varargs(type) {
        return { type };
      }
      CompoundExpression.register(expressions, {
        error: [
          ErrorType,
          [StringType],
          (ctx, [v]) => {
            throw new RuntimeError(v.evaluate(ctx));
          }
        ],
        typeof: [StringType, [ValueType], (ctx, [v]) => typeToString(typeOf(v.evaluate(ctx)))],
        "to-rgba": [
          array(NumberType, 4),
          [ColorType],
          (ctx, [v]) => {
            return v.evaluate(ctx).toArray();
          }
        ],
        rgb: [ColorType, [NumberType, NumberType, NumberType], rgba],
        rgba: [ColorType, [NumberType, NumberType, NumberType, NumberType], rgba],
        has: {
          type: BooleanType,
          overloads: [
            [[StringType], (ctx, [key]) => has(key.evaluate(ctx), ctx.properties())],
            [[StringType, ObjectType], (ctx, [key, obj]) => has(key.evaluate(ctx), obj.evaluate(ctx))]
          ]
        },
        get: {
          type: ValueType,
          overloads: [
            [[StringType], (ctx, [key]) => get(key.evaluate(ctx), ctx.properties())],
            [[StringType, ObjectType], (ctx, [key, obj]) => get(key.evaluate(ctx), obj.evaluate(ctx))]
          ]
        },
        "feature-state": [ValueType, [StringType], (ctx, [key]) => get(key.evaluate(ctx), ctx.featureState || {})],
        properties: [ObjectType, [], (ctx) => ctx.properties()],
        "geometry-type": [StringType, [], (ctx) => ctx.geometryType()],
        id: [ValueType, [], (ctx) => ctx.id()],
        zoom: [NumberType, [], (ctx) => ctx.globals.zoom],
        "heatmap-density": [NumberType, [], (ctx) => ctx.globals.heatmapDensity || 0],
        "line-progress": [NumberType, [], (ctx) => ctx.globals.lineProgress || 0],
        "+": [
          NumberType,
          varargs(NumberType),
          (ctx, args) => {
            let result = 0;
            for (const arg of args) {
              result += arg.evaluate(ctx);
            }
            return result;
          }
        ],
        "*": [
          NumberType,
          varargs(NumberType),
          (ctx, args) => {
            let result = 1;
            for (const arg of args) {
              result *= arg.evaluate(ctx);
            }
            return result;
          }
        ],
        "-": {
          type: NumberType,
          overloads: [
            [[NumberType, NumberType], (ctx, [a, b]) => a.evaluate(ctx) - b.evaluate(ctx)],
            [[NumberType], (ctx, [a]) => -a.evaluate(ctx)]
          ]
        },
        "/": [NumberType, [NumberType, NumberType], (ctx, [a, b]) => a.evaluate(ctx) / b.evaluate(ctx)],
        "%": [NumberType, [NumberType, NumberType], (ctx, [a, b]) => a.evaluate(ctx) % b.evaluate(ctx)],
        ln2: [NumberType, [], () => Math.LN2],
        pi: [NumberType, [], () => Math.PI],
        e: [NumberType, [], () => Math.E],
        "^": [NumberType, [NumberType, NumberType], (ctx, [b, e]) => b.evaluate(ctx) ** e.evaluate(ctx)],
        sqrt: [NumberType, [NumberType], (ctx, [x]) => Math.sqrt(x.evaluate(ctx))],
        log10: [NumberType, [NumberType], (ctx, [n]) => Math.log10(n.evaluate(ctx))],
        ln: [NumberType, [NumberType], (ctx, [n]) => Math.log(n.evaluate(ctx))],
        log2: [NumberType, [NumberType], (ctx, [n]) => Math.log2(n.evaluate(ctx))],
        sin: [NumberType, [NumberType], (ctx, [n]) => Math.sin(n.evaluate(ctx))],
        cos: [NumberType, [NumberType], (ctx, [n]) => Math.cos(n.evaluate(ctx))],
        tan: [NumberType, [NumberType], (ctx, [n]) => Math.tan(n.evaluate(ctx))],
        asin: [NumberType, [NumberType], (ctx, [n]) => Math.asin(n.evaluate(ctx))],
        acos: [NumberType, [NumberType], (ctx, [n]) => Math.acos(n.evaluate(ctx))],
        atan: [NumberType, [NumberType], (ctx, [n]) => Math.atan(n.evaluate(ctx))],
        min: [NumberType, varargs(NumberType), (ctx, args) => Math.min(...args.map((arg) => arg.evaluate(ctx)))],
        max: [NumberType, varargs(NumberType), (ctx, args) => Math.max(...args.map((arg) => arg.evaluate(ctx)))],
        abs: [NumberType, [NumberType], (ctx, [n]) => Math.abs(n.evaluate(ctx))],
        round: [
          NumberType,
          [NumberType],
          (ctx, [n]) => {
            const v = n.evaluate(ctx);
            return v < 0 ? -Math.round(-v) : Math.round(v);
          }
        ],
        floor: [NumberType, [NumberType], (ctx, [n]) => Math.floor(n.evaluate(ctx))],
        ceil: [NumberType, [NumberType], (ctx, [n]) => Math.ceil(n.evaluate(ctx))],
        "filter-==": [BooleanType, [StringType, ValueType], (ctx, [k, v]) => ctx.properties()[k.value] === v.value],
        "filter-id-==": [BooleanType, [ValueType], (ctx, [v]) => ctx.id() === v.value],
        "filter-type-==": [BooleanType, [StringType], (ctx, [v]) => ctx.geometryType() === v.value],
        "filter-<": [
          BooleanType,
          [StringType, ValueType],
          (ctx, [k, v]) => {
            const a = ctx.properties()[k.value];
            const b = v.value;
            return typeof a === typeof b && a < b;
          }
        ],
        "filter-id-<": [
          BooleanType,
          [ValueType],
          (ctx, [v]) => {
            const a = ctx.id();
            const b = v.value;
            return typeof a === typeof b && a < b;
          }
        ],
        "filter->": [
          BooleanType,
          [StringType, ValueType],
          (ctx, [k, v]) => {
            const a = ctx.properties()[k.value];
            const b = v.value;
            return typeof a === typeof b && a > b;
          }
        ],
        "filter-id->": [
          BooleanType,
          [ValueType],
          (ctx, [v]) => {
            const a = ctx.id();
            const b = v.value;
            return typeof a === typeof b && a > b;
          }
        ],
        "filter-<=": [
          BooleanType,
          [StringType, ValueType],
          (ctx, [k, v]) => {
            const a = ctx.properties()[k.value];
            const b = v.value;
            return typeof a === typeof b && a <= b;
          }
        ],
        "filter-id-<=": [
          BooleanType,
          [ValueType],
          (ctx, [v]) => {
            const a = ctx.id();
            const b = v.value;
            return typeof a === typeof b && a <= b;
          }
        ],
        "filter->=": [
          BooleanType,
          [StringType, ValueType],
          (ctx, [k, v]) => {
            const a = ctx.properties()[k.value];
            const b = v.value;
            return typeof a === typeof b && a >= b;
          }
        ],
        "filter-id->=": [
          BooleanType,
          [ValueType],
          (ctx, [v]) => {
            const a = ctx.id();
            const b = v.value;
            return typeof a === typeof b && a >= b;
          }
        ],
        "filter-has": [BooleanType, [ValueType], (ctx, [k]) => k.value in ctx.properties()],
        "filter-has-id": [BooleanType, [], (ctx) => ctx.id() !== null],
        "filter-type-in": [BooleanType, [array(StringType)], (ctx, [v]) => v.value.indexOf(ctx.geometryType()) >= 0],
        "filter-id-in": [BooleanType, [array(ValueType)], (ctx, [v]) => v.value.indexOf(ctx.id()) >= 0],
        "filter-in-small": [
          BooleanType,
          [StringType, array(ValueType)],
          // assumes v is an array literal
          (ctx, [k, v]) => v.value.indexOf(ctx.properties()[k.value]) >= 0
        ],
        "filter-in-large": [
          BooleanType,
          [StringType, array(ValueType)],
          // assumes v is a array literal with values sorted in ascending order and of a single type
          (ctx, [k, v]) => binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1)
        ],
        all: {
          type: BooleanType,
          overloads: [
            [[BooleanType, BooleanType], (ctx, [a, b]) => a.evaluate(ctx) && b.evaluate(ctx)],
            [
              varargs(BooleanType),
              (ctx, args) => {
                for (const arg of args) {
                  if (!arg.evaluate(ctx)) return false;
                }
                return true;
              }
            ]
          ]
        },
        any: {
          type: BooleanType,
          overloads: [
            [[BooleanType, BooleanType], (ctx, [a, b]) => a.evaluate(ctx) || b.evaluate(ctx)],
            [
              varargs(BooleanType),
              (ctx, args) => {
                for (const arg of args) {
                  if (arg.evaluate(ctx)) return true;
                }
                return false;
              }
            ]
          ]
        },
        "!": [BooleanType, [BooleanType], (ctx, [b]) => !b.evaluate(ctx)],
        "is-supported-script": [
          BooleanType,
          [StringType],
          // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant
          (ctx, [s]) => {
            const isSupportedScript = ctx.globals?.isSupportedScript;
            if (isSupportedScript) {
              return isSupportedScript(s.evaluate(ctx));
            }
            return true;
          }
        ],
        upcase: [StringType, [StringType], (ctx, [s]) => s.evaluate(ctx).toUpperCase()],
        downcase: [StringType, [StringType], (ctx, [s]) => s.evaluate(ctx).toLowerCase()],
        concat: [StringType, varargs(ValueType), (ctx, args) => args.map((arg) => valueToString(arg.evaluate(ctx))).join("")],
        "resolved-locale": [StringType, [CollatorType], (ctx, [collator]) => collator.evaluate(ctx).resolvedLocale()]
      });
      module.exports = expressions;
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/util/result.js
  var require_result = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/util/result.js"(exports, module) {
      function success(value) {
        return { result: "success", value };
      }
      function error(value) {
        return { result: "error", value };
      }
      module.exports = {
        success,
        error
      };
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/util/properties.js
  var require_properties = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/util/properties.js"(exports, module) {
      function supportsPropertyExpression({ ["property-type"]: propertyType }) {
        return propertyType === "data-driven" || propertyType === "cross-faded-data-driven";
      }
      function supportsZoomExpression(spec) {
        return !!spec.expression?.parameters.includes("zoom");
      }
      function supportsInterpolation(spec) {
        return !!spec.expression?.interpolated;
      }
      module.exports = {
        supportsPropertyExpression,
        supportsZoomExpression,
        supportsInterpolation
      };
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/util/get_type.js
  var require_get_type = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/util/get_type.js"(exports, module) {
      module.exports = function getType(val) {
        if (val instanceof Number) {
          return "number";
        }
        if (val instanceof String) {
          return "string";
        }
        if (val instanceof Boolean) {
          return "boolean";
        }
        if (Array.isArray(val)) {
          return "array";
        }
        if (val === null) {
          return "null";
        }
        return typeof val;
      };
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/function/index.js
  var require_function = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/function/index.js"(exports, module) {
      var colorSpaces = require_color_spaces();
      var Color = require_color();
      var getType = require_get_type();
      var interpolate2 = require_interpolate();
      var Interpolate = require_interpolate2();
      var { Formatted } = require_formatted();
      var { supportsInterpolation } = require_properties();
      module.exports = {
        isFunction,
        createFunction
      };
      function isFunction(value) {
        return typeof value === "object" && value !== null && !Array.isArray(value);
      }
      function identityFunction(x) {
        return x;
      }
      function createFunction(parameters, propertySpec) {
        const isColor = propertySpec.type === "color";
        const zoomAndFeatureDependent = parameters.stops && typeof parameters.stops[0][0] === "object";
        const featureDependent = zoomAndFeatureDependent || parameters.property !== void 0;
        const zoomDependent = zoomAndFeatureDependent || !featureDependent;
        const type = parameters.type || (supportsInterpolation(propertySpec) ? "exponential" : "interval");
        if (isColor) {
          parameters = { ...parameters };
          if (parameters.stops) {
            parameters.stops = parameters.stops.map((stop) => {
              return [stop[0], Color.parse(stop[1])];
            });
          }
          if (parameters.default) {
            parameters.default = Color.parse(parameters.default);
          } else {
            parameters.default = Color.parse(propertySpec.default);
          }
        }
        if (parameters.colorSpace && parameters.colorSpace !== "rgb" && !colorSpaces[parameters.colorSpace]) {
          throw new Error(`Unknown color space: ${parameters.colorSpace}`);
        }
        let innerFun;
        let hashedStops;
        let categoricalKeyType;
        if (type === "exponential") {
          innerFun = evaluateExponentialFunction;
        } else if (type === "interval") {
          innerFun = evaluateIntervalFunction;
        } else if (type === "categorical") {
          innerFun = evaluateCategoricalFunction;
          hashedStops = /* @__PURE__ */ Object.create(null);
          for (const stop of parameters.stops) {
            hashedStops[stop[0]] = stop[1];
          }
          categoricalKeyType = typeof parameters.stops[0][0];
        } else if (type === "identity") {
          innerFun = evaluateIdentityFunction;
        } else {
          throw new Error(`Unknown function type "${type}"`);
        }
        if (zoomAndFeatureDependent) {
          const featureFunctions = {};
          const zoomStops = [];
          for (let s = 0; s < parameters.stops.length; s++) {
            const stop = parameters.stops[s];
            const zoom = stop[0].zoom;
            if (featureFunctions[zoom] === void 0) {
              featureFunctions[zoom] = {
                zoom,
                type: parameters.type,
                property: parameters.property,
                default: parameters.default,
                stops: []
              };
              zoomStops.push(zoom);
            }
            featureFunctions[zoom].stops.push([stop[0].value, stop[1]]);
          }
          const featureFunctionStops = [];
          for (const z of zoomStops) {
            featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z], propertySpec)]);
          }
          return {
            kind: "composite",
            interpolationFactor: Interpolate.interpolationFactor.bind(void 0, { name: "linear" }),
            zoomStops: featureFunctionStops.map((s) => s[0]),
            evaluate({ zoom }, properties) {
              return evaluateExponentialFunction(
                {
                  stops: featureFunctionStops,
                  base: parameters.base
                },
                propertySpec,
                zoom
              ).evaluate(zoom, properties);
            }
          };
        }
        if (zoomDependent) {
          return {
            kind: "camera",
            interpolationFactor: type === "exponential" ? Interpolate.interpolationFactor.bind(void 0, {
              name: "exponential",
              base: parameters.base !== void 0 ? parameters.base : 1
            }) : () => 0,
            zoomStops: parameters.stops.map((s) => s[0]),
            evaluate: ({ zoom }) => innerFun(parameters, propertySpec, zoom, hashedStops, categoricalKeyType)
          };
        }
        return {
          kind: "source",
          evaluate(_, feature) {
            const value = feature?.properties ? feature.properties[parameters.property] : void 0;
            if (value === void 0) {
              return coalesce(parameters.default, propertySpec.default);
            }
            return innerFun(parameters, propertySpec, value, hashedStops, categoricalKeyType);
          }
        };
      }
      function coalesce(a, b, c) {
        if (a !== void 0) return a;
        if (b !== void 0) return b;
        if (c !== void 0) return c;
      }
      function evaluateCategoricalFunction(parameters, propertySpec, input, hashedStops, keyType) {
        const evaluated = typeof input === keyType ? hashedStops[input] : void 0;
        return coalesce(evaluated, parameters.default, propertySpec.default);
      }
      function evaluateIntervalFunction(parameters, propertySpec, input) {
        if (getType(input) !== "number") return coalesce(parameters.default, propertySpec.default);
        const n = parameters.stops.length;
        if (n === 1) return parameters.stops[0][1];
        if (input <= parameters.stops[0][0]) return parameters.stops[0][1];
        if (input >= parameters.stops[n - 1][0]) return parameters.stops[n - 1][1];
        const index = findStopLessThanOrEqualTo(parameters.stops, input);
        return parameters.stops[index][1];
      }
      function evaluateExponentialFunction(parameters, propertySpec, input) {
        const base = parameters.base !== void 0 ? parameters.base : 1;
        if (getType(input) !== "number") return coalesce(parameters.default, propertySpec.default);
        const n = parameters.stops.length;
        if (n === 1) return parameters.stops[0][1];
        if (input <= parameters.stops[0][0]) return parameters.stops[0][1];
        if (input >= parameters.stops[n - 1][0]) return parameters.stops[n - 1][1];
        const index = findStopLessThanOrEqualTo(parameters.stops, input);
        const t = interpolationFactor(input, base, parameters.stops[index][0], parameters.stops[index + 1][0]);
        const outputLower = parameters.stops[index][1];
        const outputUpper = parameters.stops[index + 1][1];
        let interp = interpolate2[propertySpec.type] || identityFunction;
        if (parameters.colorSpace && parameters.colorSpace !== "rgb") {
          const colorspace = colorSpaces[parameters.colorSpace];
          interp = (a, b) => colorspace.reverse(colorspace.interpolate(colorspace.forward(a), colorspace.forward(b), t));
        }
        if (typeof outputLower.evaluate === "function") {
          return {
            evaluate(...args) {
              const evaluatedLower = outputLower.evaluate.apply(void 0, args);
              const evaluatedUpper = outputUpper.evaluate.apply(void 0, args);
              if (evaluatedLower === void 0 || evaluatedUpper === void 0) {
                return void 0;
              }
              return interp(evaluatedLower, evaluatedUpper, t);
            }
          };
        }
        return interp(outputLower, outputUpper, t);
      }
      function evaluateIdentityFunction(parameters, propertySpec, input) {
        switch (propertySpec.type) {
          case "color":
            input = Color.parse(input);
            break;
          case "formatted":
            input = Formatted.fromString(input.toString());
            break;
          case "enum":
            if (!propertySpec.values.includes(input)) {
              input = void 0;
            }
            break;
          default:
            if (getType(input) !== propertySpec.type) {
              input = void 0;
            }
        }
        return coalesce(input, parameters.default, propertySpec.default);
      }
      function findStopLessThanOrEqualTo(stops, input) {
        const n = stops.length;
        let lowerIndex = 0;
        let upperIndex = n - 1;
        let currentIndex = 0;
        let currentValue;
        let upperValue;
        while (lowerIndex <= upperIndex) {
          currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
          currentValue = stops[currentIndex][0];
          upperValue = stops[currentIndex + 1][0];
          if (input === currentValue || input > currentValue && input < upperValue) {
            return currentIndex;
          }
          if (currentValue < input) {
            lowerIndex = currentIndex + 1;
          } else if (currentValue > input) {
            upperIndex = currentIndex - 1;
          }
        }
        return Math.max(currentIndex - 1, 0);
      }
      function interpolationFactor(input, base, lowerValue, upperValue) {
        const difference = upperValue - lowerValue;
        const progress = input - lowerValue;
        if (difference === 0) {
          return 0;
        }
        if (base === 1) {
          return progress / difference;
        }
        return (base ** progress - 1) / (base ** difference - 1);
      }
    }
  });

  // node_modules/@mapwhit/style-expressions/lib/expression/index.js
  var require_expression = __commonJS({
    "node_modules/@mapwhit/style-expressions/lib/expression/index.js"(exports, module) {
      var assert = require_nanoassert();
      var ParsingError = require_parsing_error();
      var ParsingContext = require_parsing_context();
      var EvaluationContext = require_evaluation_context();
      var CompoundExpression = require_compound_expression();
      var Step = require_step();
      var Interpolate = require_interpolate2();
      var Coalesce = require_coalesce();
      var Let = require_let();
      var definitions = require_definitions();
      var formatted = require_formatted();
      var isConstant = require_is_constant();
      var RuntimeError = require_runtime_error();
      var { success, error } = require_result();
      var properties = require_properties();
      var { supportsPropertyExpression, supportsZoomExpression, supportsInterpolation } = properties;
      var colorSpaces = require_color_spaces();
      var interpolate2 = require_interpolate();
      var StyleExpression = class {
        constructor(expression, propertySpec) {
          this.expression = expression;
          this._warningHistory = {};
          this._evaluator = new EvaluationContext();
          this._defaultValue = getDefaultValue(propertySpec);
          this._enumValues = propertySpec.type === "enum" ? propertySpec.values : null;
        }
        evaluateWithoutErrorHandling(globals, feature, featureState) {
          this._evaluator.globals = globals;
          this._evaluator.feature = feature;
          this._evaluator.featureState = featureState;
          return this.expression.evaluate(this._evaluator);
        }
        evaluate(globals, feature, featureState) {
          this._evaluator.globals = globals;
          this._evaluator.feature = feature || null;
          this._evaluator.featureState = featureState || null;
          try {
            const val = this.expression.evaluate(this._evaluator);
            if (val === null || val === void 0) {
              return this._defaultValue;
            }
            if (this._enumValues && !this._enumValues.includes(val)) {
              throw new RuntimeError(
                `Expected value to be one of ${this._enumValues.map((v) => JSON.stringify(v)).join(", ")}, but found ${JSON.stringify(val)} instead.`
              );
            }
            return val;
          } catch (e) {
            if (!this._warningHistory[e.message]) {
              this._warningHistory[e.message] = true;
              if (typeof console !== "undefined") {
                console.warn(e.message);
              }
            }
            return this._defaultValue;
          }
        }
      };
      function isExpression(expression) {
        return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === "string" && expression[0] in definitions;
      }
      function createExpression(expression, propertySpec) {
        const parser = new ParsingContext(definitions, [], getExpectedType(propertySpec));
        const parsed = parser.parse(
          expression,
          void 0,
          void 0,
          void 0,
          propertySpec.type === "string" ? { typeAnnotation: "coerce" } : void 0
        );
        if (!parsed) {
          assert(parser.errors.length > 0);
          return error(parser.errors);
        }
        return success(new StyleExpression(parsed, propertySpec));
      }
      var ZoomConstantExpression = class {
        constructor(kind, expression) {
          this.kind = kind;
          this._styleExpression = expression;
          this.isStateDependent = kind !== "constant" && !isConstant.isStateConstant(expression.expression);
        }
        evaluateWithoutErrorHandling(globals, feature, featureState) {
          return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState);
        }
        evaluate(globals, feature, featureState) {
          return this._styleExpression.evaluate(globals, feature, featureState);
        }
      };
      var ZoomDependentExpression = class {
        constructor(kind, expression, zoomCurve) {
          this.kind = kind;
          this.zoomStops = zoomCurve.labels;
          this._styleExpression = expression;
          this.isStateDependent = kind !== "camera" && !isConstant.isStateConstant(expression.expression);
          if (zoomCurve instanceof Interpolate) {
            this._interpolationType = zoomCurve.interpolation;
          }
        }
        evaluateWithoutErrorHandling(globals, feature, featureState) {
          return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState);
        }
        evaluate(globals, feature, featureState) {
          return this._styleExpression.evaluate(globals, feature, featureState);
        }
        interpolationFactor(input, lower, upper) {
          if (this._interpolationType) {
            return Interpolate.interpolationFactor(this._interpolationType, input, lower, upper);
          }
          return 0;
        }
      };
      function createPropertyExpression(expression, propertySpec) {
        expression = createExpression(expression, propertySpec);
        if (expression.result === "error") {
          return expression;
        }
        const parsed = expression.value.expression;
        const isFeatureConstant = isConstant.isFeatureConstant(parsed);
        if (!isFeatureConstant && !supportsPropertyExpression(propertySpec)) {
          return error([new ParsingError("", "data expressions not supported")]);
        }
        const isZoomConstant = isConstant.isGlobalPropertyConstant(parsed, ["zoom"]);
        if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {
          return error([new ParsingError("", "zoom expressions not supported")]);
        }
        const zoomCurve = findZoomCurve(parsed);
        if (!zoomCurve && !isZoomConstant) {
          return error([
            new ParsingError(
              "",
              '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
            )
          ]);
        }
        if (zoomCurve instanceof ParsingError) {
          return error([zoomCurve]);
        }
        if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {
          return error([new ParsingError("", '"interpolate" expressions cannot be used with this property')]);
        }
        if (!zoomCurve) {
          return success(
            isFeatureConstant ? new ZoomConstantExpression("constant", expression.value) : new ZoomConstantExpression("source", expression.value)
          );
        }
        return success(
          isFeatureConstant ? new ZoomDependentExpression("camera", expression.value, zoomCurve) : new ZoomDependentExpression("composite", expression.value, zoomCurve)
        );
      }
      var { isFunction, createFunction } = require_function();
      var { Color } = require_values();
      var StylePropertyFunction = class _StylePropertyFunction {
        constructor(parameters, specification) {
          this._parameters = parameters;
          this._specification = specification;
          Object.assign(this, createFunction(this._parameters, this._specification));
        }
        static deserialize(serialized) {
          return new _StylePropertyFunction(serialized._parameters, serialized._specification);
        }
        static serialize(input) {
          return {
            _parameters: input._parameters,
            _specification: input._specification
          };
        }
      };
      function normalizePropertyExpression(value, specification) {
        if (isFunction(value)) {
          return new StylePropertyFunction(value, specification);
        }
        if (isExpression(value)) {
          const expression = createPropertyExpression(value, specification);
          if (expression.result === "error") {
            throw new Error(expression.value.map((err) => `${err.key}: ${err.message}`).join(", "));
          }
          return expression.value;
        }
        let constant = value;
        if (typeof value === "string" && specification.type === "color") {
          constant = Color.parse(value);
        }
        return {
          kind: "constant",
          evaluate: () => constant
        };
      }
      function findZoomCurve(expression) {
        let result = null;
        if (expression instanceof Let) {
          result = findZoomCurve(expression.result);
        } else if (expression instanceof Coalesce) {
          for (const arg of expression.args) {
            result = findZoomCurve(arg);
            if (result) {
              break;
            }
          }
        } else if ((expression instanceof Step || expression instanceof Interpolate) && expression.input instanceof CompoundExpression && expression.input.name === "zoom") {
          result = expression;
        }
        if (result instanceof ParsingError) {
          return result;
        }
        expression.eachChild((child) => {
          const childResult = findZoomCurve(child);
          if (childResult instanceof ParsingError) {
            result = childResult;
          } else if (!result && childResult) {
            result = new ParsingError(
              "",
              '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
            );
          } else if (result && childResult && result !== childResult) {
            result = new ParsingError(
              "",
              'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'
            );
          }
        });
        return result;
      }
      var { ColorType, StringType, NumberType, BooleanType, ValueType, FormattedType, array } = require_types();
      function getExpectedType(spec) {
        const types = {
          color: ColorType,
          string: StringType,
          number: NumberType,
          enum: StringType,
          boolean: BooleanType,
          formatted: FormattedType
        };
        if (spec.type === "array") {
          return array(types[spec.value] || ValueType, spec.length);
        }
        return types[spec.type];
      }
      function getDefaultValue(spec) {
        if (spec.type === "color" && isFunction(spec.default)) {
          return new Color(0, 0, 0, 0);
        }
        if (spec.type === "color") {
          return Color.parse(spec.default) || null;
        }
        if (spec.default === void 0) {
          return null;
        }
        return spec.default;
      }
      module.exports = {
        StyleExpression,
        isExpression,
        createExpression,
        ZoomConstantExpression,
        ZoomDependentExpression,
        createPropertyExpression,
        StylePropertyFunction,
        normalizePropertyExpression,
        Color,
        colorSpaces,
        CompoundExpression,
        definitions,
        interpolate: interpolate2,
        ...formatted,
        ...properties
      };
    }
  });

  // node_modules/@mapwhit/style-expressions/index.js
  var require_style_expressions = __commonJS({
    "node_modules/@mapwhit/style-expressions/index.js"(exports, module) {
      module.exports = require_expression();
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/transfer_registry.js
  var require_transfer_registry = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/transfer_registry.js"(exports, module) {
      var assert = require_nanoassert();
      module.exports = {
        register,
        serialize,
        deserialize
      };
      var registry = /* @__PURE__ */ new Map();
      function register(name, klass, { omit, shallow } = {}) {
        assert(!registry.has(name), `${name} is already registered.`);
        Object.defineProperty(klass, "_classRegistryKey", {
          value: name,
          writeable: false
        });
        registry.set(name, { klass, omit, shallow });
      }
      register("Object", Object);
      function serialize(input, transferables) {
        if (isSerializablePrimitive(input)) {
          return input;
        }
        if (input instanceof ArrayBuffer) {
          transferables?.push(input);
          return input;
        }
        if (ArrayBuffer.isView(input)) {
          transferables?.push(input.buffer);
          return input;
        }
        if (input instanceof ImageData) {
          transferables?.push(input.data.buffer);
          return input;
        }
        if (Array.isArray(input)) {
          return input.map((item) => serialize(item, transferables));
        }
        if (typeof input === "object") {
          const klass = input.constructor;
          const name = klass._classRegistryKey;
          if (!name) {
            throw new Error(`can't serialize object of unregistered class`);
          }
          assert(registry.has(name));
          const properties = klass.serialize ? klass.serialize(input, transferables) : {};
          if (!klass.serialize) {
            const { omit, shallow } = registry.get(name);
            for (const key in input) {
              if (!Object.hasOwn(input, key)) continue;
              if (omit?.includes(key)) continue;
              const value = input[key];
              properties[key] = shallow?.includes(key) ? value : serialize(value, transferables);
            }
            if (input instanceof Error) {
              properties.message = input.message;
            }
          } else {
            assert(!transferables || properties !== transferables[transferables.length - 1]);
          }
          if (properties.$name) {
            throw new Error("$name property is reserved for worker serialization logic.");
          }
          if (name !== "Object") {
            properties.$name = name;
          }
          return properties;
        }
        throw new Error(`can't serialize object of type ${typeof input}`);
      }
      function deserialize(input) {
        if (isSerializablePrimitive(input) || input instanceof ArrayBuffer || ArrayBuffer.isView(input) || input instanceof ImageData) {
          return input;
        }
        if (Array.isArray(input)) {
          return input.map(deserialize);
        }
        if (typeof input === "object") {
          const name = input.$name ?? "Object";
          const { klass, shallow } = registry.get(name);
          if (!klass) {
            throw new Error(`can't deserialize unregistered class ${name}`);
          }
          if (klass.deserialize) {
            return klass.deserialize(input);
          }
          const result = Object.create(klass.prototype);
          for (const key of Object.keys(input)) {
            if (key === "$name") continue;
            const value = input[key];
            result[key] = shallow?.includes(key) ? value : deserialize(value);
          }
          return result;
        }
        throw new Error(`can't deserialize object of type ${typeof input}`);
      }
      function isSerializablePrimitive(input) {
        return input == null || typeof input === "boolean" || typeof input === "number" || typeof input === "string" || input instanceof Date || input instanceof RegExp || input instanceof Boolean || input instanceof Number || input instanceof String;
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/zoom_history.js
  var require_zoom_history = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/zoom_history.js"(exports, module) {
      var ZoomHistory = class {
        constructor() {
          this.first = true;
        }
        update(z, now) {
          const floorZ = Math.floor(z);
          if (this.first) {
            this.first = false;
            this.lastIntegerZoom = floorZ;
            this.lastIntegerZoomTime = 0;
            this.lastZoom = z;
            this.lastFloorZoom = floorZ;
            return true;
          }
          if (this.lastFloorZoom > floorZ) {
            this.lastIntegerZoom = floorZ + 1;
            this.lastIntegerZoomTime = now;
          } else if (this.lastFloorZoom < floorZ) {
            this.lastIntegerZoom = floorZ;
            this.lastIntegerZoomTime = now;
          }
          if (z !== this.lastZoom) {
            this.lastZoom = z;
            this.lastFloorZoom = floorZ;
            return true;
          }
          return false;
        }
      };
      module.exports = ZoomHistory;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/is_char_in_unicode_block.js
  var require_is_char_in_unicode_block = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/is_char_in_unicode_block.js"(exports, module) {
      var unicodeBlockLookup = {
        // 'Basic Latin': (char) => char >= 0x0000 && char <= 0x007F,
        "Latin-1 Supplement": (char) => char >= 128 && char <= 255,
        // 'Latin Extended-A': (char) => char >= 0x0100 && char <= 0x017F,
        // 'Latin Extended-B': (char) => char >= 0x0180 && char <= 0x024F,
        // 'IPA Extensions': (char) => char >= 0x0250 && char <= 0x02AF,
        // 'Spacing Modifier Letters': (char) => char >= 0x02B0 && char <= 0x02FF,
        // 'Combining Diacritical Marks': (char) => char >= 0x0300 && char <= 0x036F,
        // 'Greek and Coptic': (char) => char >= 0x0370 && char <= 0x03FF,
        // 'Cyrillic': (char) => char >= 0x0400 && char <= 0x04FF,
        // 'Cyrillic Supplement': (char) => char >= 0x0500 && char <= 0x052F,
        // 'Armenian': (char) => char >= 0x0530 && char <= 0x058F,
        //'Hebrew': (char) => char >= 0x0590 && char <= 0x05FF,
        Arabic: (char) => char >= 1536 && char <= 1791,
        //'Syriac': (char) => char >= 0x0700 && char <= 0x074F,
        "Arabic Supplement": (char) => char >= 1872 && char <= 1919,
        // 'Thaana': (char) => char >= 0x0780 && char <= 0x07BF,
        // 'NKo': (char) => char >= 0x07C0 && char <= 0x07FF,
        // 'Samaritan': (char) => char >= 0x0800 && char <= 0x083F,
        // 'Mandaic': (char) => char >= 0x0840 && char <= 0x085F,
        // 'Syriac Supplement': (char) => char >= 0x0860 && char <= 0x086F,
        "Arabic Extended-A": (char) => char >= 2208 && char <= 2303,
        // 'Devanagari': (char) => char >= 0x0900 && char <= 0x097F,
        // 'Bengali': (char) => char >= 0x0980 && char <= 0x09FF,
        // 'Gurmukhi': (char) => char >= 0x0A00 && char <= 0x0A7F,
        // 'Gujarati': (char) => char >= 0x0A80 && char <= 0x0AFF,
        // 'Oriya': (char) => char >= 0x0B00 && char <= 0x0B7F,
        // 'Tamil': (char) => char >= 0x0B80 && char <= 0x0BFF,
        // 'Telugu': (char) => char >= 0x0C00 && char <= 0x0C7F,
        // 'Kannada': (char) => char >= 0x0C80 && char <= 0x0CFF,
        // 'Malayalam': (char) => char >= 0x0D00 && char <= 0x0D7F,
        // 'Sinhala': (char) => char >= 0x0D80 && char <= 0x0DFF,
        // 'Thai': (char) => char >= 0x0E00 && char <= 0x0E7F,
        // 'Lao': (char) => char >= 0x0E80 && char <= 0x0EFF,
        // 'Tibetan': (char) => char >= 0x0F00 && char <= 0x0FFF,
        // 'Myanmar': (char) => char >= 0x1000 && char <= 0x109F,
        // 'Georgian': (char) => char >= 0x10A0 && char <= 0x10FF,
        "Hangul Jamo": (char) => char >= 4352 && char <= 4607,
        // 'Ethiopic': (char) => char >= 0x1200 && char <= 0x137F,
        // 'Ethiopic Supplement': (char) => char >= 0x1380 && char <= 0x139F,
        // 'Cherokee': (char) => char >= 0x13A0 && char <= 0x13FF,
        "Unified Canadian Aboriginal Syllabics": (char) => char >= 5120 && char <= 5759,
        // 'Ogham': (char) => char >= 0x1680 && char <= 0x169F,
        // 'Runic': (char) => char >= 0x16A0 && char <= 0x16FF,
        // 'Tagalog': (char) => char >= 0x1700 && char <= 0x171F,
        // 'Hanunoo': (char) => char >= 0x1720 && char <= 0x173F,
        // 'Buhid': (char) => char >= 0x1740 && char <= 0x175F,
        // 'Tagbanwa': (char) => char >= 0x1760 && char <= 0x177F,
        Khmer: (char) => char >= 6016 && char <= 6143,
        // 'Mongolian': (char) => char >= 0x1800 && char <= 0x18AF,
        "Unified Canadian Aboriginal Syllabics Extended": (char) => char >= 6320 && char <= 6399,
        // 'Limbu': (char) => char >= 0x1900 && char <= 0x194F,
        // 'Tai Le': (char) => char >= 0x1950 && char <= 0x197F,
        // 'New Tai Lue': (char) => char >= 0x1980 && char <= 0x19DF,
        // 'Khmer Symbols': (char) => char >= 0x19E0 && char <= 0x19FF,
        // 'Buginese': (char) => char >= 0x1A00 && char <= 0x1A1F,
        // 'Tai Tham': (char) => char >= 0x1A20 && char <= 0x1AAF,
        // 'Combining Diacritical Marks Extended': (char) => char >= 0x1AB0 && char <= 0x1AFF,
        // 'Balinese': (char) => char >= 0x1B00 && char <= 0x1B7F,
        // 'Sundanese': (char) => char >= 0x1B80 && char <= 0x1BBF,
        // 'Batak': (char) => char >= 0x1BC0 && char <= 0x1BFF,
        // 'Lepcha': (char) => char >= 0x1C00 && char <= 0x1C4F,
        // 'Ol Chiki': (char) => char >= 0x1C50 && char <= 0x1C7F,
        // 'Cyrillic Extended-C': (char) => char >= 0x1C80 && char <= 0x1C8F,
        // 'Sundanese Supplement': (char) => char >= 0x1CC0 && char <= 0x1CCF,
        // 'Vedic Extensions': (char) => char >= 0x1CD0 && char <= 0x1CFF,
        // 'Phonetic Extensions': (char) => char >= 0x1D00 && char <= 0x1D7F,
        // 'Phonetic Extensions Supplement': (char) => char >= 0x1D80 && char <= 0x1DBF,
        // 'Combining Diacritical Marks Supplement': (char) => char >= 0x1DC0 && char <= 0x1DFF,
        // 'Latin Extended Additional': (char) => char >= 0x1E00 && char <= 0x1EFF,
        // 'Greek Extended': (char) => char >= 0x1F00 && char <= 0x1FFF,
        "General Punctuation": (char) => char >= 8192 && char <= 8303,
        // 'Superscripts and Subscripts': (char) => char >= 0x2070 && char <= 0x209F,
        // 'Currency Symbols': (char) => char >= 0x20A0 && char <= 0x20CF,
        // 'Combining Diacritical Marks for Symbols': (char) => char >= 0x20D0 && char <= 0x20FF,
        "Letterlike Symbols": (char) => char >= 8448 && char <= 8527,
        "Number Forms": (char) => char >= 8528 && char <= 8591,
        // 'Arrows': (char) => char >= 0x2190 && char <= 0x21FF,
        // 'Mathematical Operators': (char) => char >= 0x2200 && char <= 0x22FF,
        "Miscellaneous Technical": (char) => char >= 8960 && char <= 9215,
        "Control Pictures": (char) => char >= 9216 && char <= 9279,
        "Optical Character Recognition": (char) => char >= 9280 && char <= 9311,
        "Enclosed Alphanumerics": (char) => char >= 9312 && char <= 9471,
        // 'Box Drawing': (char) => char >= 0x2500 && char <= 0x257F,
        // 'Block Elements': (char) => char >= 0x2580 && char <= 0x259F,
        "Geometric Shapes": (char) => char >= 9632 && char <= 9727,
        "Miscellaneous Symbols": (char) => char >= 9728 && char <= 9983,
        // 'Dingbats': (char) => char >= 0x2700 && char <= 0x27BF,
        // 'Miscellaneous Mathematical Symbols-A': (char) => char >= 0x27C0 && char <= 0x27EF,
        // 'Supplemental Arrows-A': (char) => char >= 0x27F0 && char <= 0x27FF,
        // 'Braille Patterns': (char) => char >= 0x2800 && char <= 0x28FF,
        // 'Supplemental Arrows-B': (char) => char >= 0x2900 && char <= 0x297F,
        // 'Miscellaneous Mathematical Symbols-B': (char) => char >= 0x2980 && char <= 0x29FF,
        // 'Supplemental Mathematical Operators': (char) => char >= 0x2A00 && char <= 0x2AFF,
        "Miscellaneous Symbols and Arrows": (char) => char >= 11008 && char <= 11263,
        // 'Glagolitic': (char) => char >= 0x2C00 && char <= 0x2C5F,
        // 'Latin Extended-C': (char) => char >= 0x2C60 && char <= 0x2C7F,
        // 'Coptic': (char) => char >= 0x2C80 && char <= 0x2CFF,
        // 'Georgian Supplement': (char) => char >= 0x2D00 && char <= 0x2D2F,
        // 'Tifinagh': (char) => char >= 0x2D30 && char <= 0x2D7F,
        // 'Ethiopic Extended': (char) => char >= 0x2D80 && char <= 0x2DDF,
        // 'Cyrillic Extended-A': (char) => char >= 0x2DE0 && char <= 0x2DFF,
        // 'Supplemental Punctuation': (char) => char >= 0x2E00 && char <= 0x2E7F,
        "CJK Radicals Supplement": (char) => char >= 11904 && char <= 12031,
        "Kangxi Radicals": (char) => char >= 12032 && char <= 12255,
        "Ideographic Description Characters": (char) => char >= 12272 && char <= 12287,
        "CJK Symbols and Punctuation": (char) => char >= 12288 && char <= 12351,
        Hiragana: (char) => char >= 12352 && char <= 12447,
        Katakana: (char) => char >= 12448 && char <= 12543,
        Bopomofo: (char) => char >= 12544 && char <= 12591,
        "Hangul Compatibility Jamo": (char) => char >= 12592 && char <= 12687,
        Kanbun: (char) => char >= 12688 && char <= 12703,
        "Bopomofo Extended": (char) => char >= 12704 && char <= 12735,
        "CJK Strokes": (char) => char >= 12736 && char <= 12783,
        "Katakana Phonetic Extensions": (char) => char >= 12784 && char <= 12799,
        "Enclosed CJK Letters and Months": (char) => char >= 12800 && char <= 13055,
        "CJK Compatibility": (char) => char >= 13056 && char <= 13311,
        "CJK Unified Ideographs Extension A": (char) => char >= 13312 && char <= 19903,
        "Yijing Hexagram Symbols": (char) => char >= 19904 && char <= 19967,
        "CJK Unified Ideographs": (char) => char >= 19968 && char <= 40959,
        "Yi Syllables": (char) => char >= 40960 && char <= 42127,
        "Yi Radicals": (char) => char >= 42128 && char <= 42191,
        // 'Lisu': (char) => char >= 0xA4D0 && char <= 0xA4FF,
        // 'Vai': (char) => char >= 0xA500 && char <= 0xA63F,
        // 'Cyrillic Extended-B': (char) => char >= 0xA640 && char <= 0xA69F,
        // 'Bamum': (char) => char >= 0xA6A0 && char <= 0xA6FF,
        // 'Modifier Tone Letters': (char) => char >= 0xA700 && char <= 0xA71F,
        // 'Latin Extended-D': (char) => char >= 0xA720 && char <= 0xA7FF,
        // 'Syloti Nagri': (char) => char >= 0xA800 && char <= 0xA82F,
        // 'Common Indic Number Forms': (char) => char >= 0xA830 && char <= 0xA83F,
        // 'Phags-pa': (char) => char >= 0xA840 && char <= 0xA87F,
        // 'Saurashtra': (char) => char >= 0xA880 && char <= 0xA8DF,
        // 'Devanagari Extended': (char) => char >= 0xA8E0 && char <= 0xA8FF,
        // 'Kayah Li': (char) => char >= 0xA900 && char <= 0xA92F,
        // 'Rejang': (char) => char >= 0xA930 && char <= 0xA95F,
        "Hangul Jamo Extended-A": (char) => char >= 43360 && char <= 43391,
        // 'Javanese': (char) => char >= 0xA980 && char <= 0xA9DF,
        // 'Myanmar Extended-B': (char) => char >= 0xA9E0 && char <= 0xA9FF,
        // 'Cham': (char) => char >= 0xAA00 && char <= 0xAA5F,
        // 'Myanmar Extended-A': (char) => char >= 0xAA60 && char <= 0xAA7F,
        // 'Tai Viet': (char) => char >= 0xAA80 && char <= 0xAADF,
        // 'Meetei Mayek Extensions': (char) => char >= 0xAAE0 && char <= 0xAAFF,
        // 'Ethiopic Extended-A': (char) => char >= 0xAB00 && char <= 0xAB2F,
        // 'Latin Extended-E': (char) => char >= 0xAB30 && char <= 0xAB6F,
        // 'Cherokee Supplement': (char) => char >= 0xAB70 && char <= 0xABBF,
        // 'Meetei Mayek': (char) => char >= 0xABC0 && char <= 0xABFF,
        "Hangul Syllables": (char) => char >= 44032 && char <= 55215,
        "Hangul Jamo Extended-B": (char) => char >= 55216 && char <= 55295,
        // 'High Surrogates': (char) => char >= 0xD800 && char <= 0xDB7F,
        // 'High Private Use Surrogates': (char) => char >= 0xDB80 && char <= 0xDBFF,
        // 'Low Surrogates': (char) => char >= 0xDC00 && char <= 0xDFFF,
        "Private Use Area": (char) => char >= 57344 && char <= 63743,
        "CJK Compatibility Ideographs": (char) => char >= 63744 && char <= 64255,
        // 'Alphabetic Presentation Forms': (char) => char >= 0xFB00 && char <= 0xFB4F,
        "Arabic Presentation Forms-A": (char) => char >= 64336 && char <= 65023,
        // 'Variation Selectors': (char) => char >= 0xFE00 && char <= 0xFE0F,
        "Vertical Forms": (char) => char >= 65040 && char <= 65055,
        // 'Combining Half Marks': (char) => char >= 0xFE20 && char <= 0xFE2F,
        "CJK Compatibility Forms": (char) => char >= 65072 && char <= 65103,
        "Small Form Variants": (char) => char >= 65104 && char <= 65135,
        "Arabic Presentation Forms-B": (char) => char >= 65136 && char <= 65279,
        "Halfwidth and Fullwidth Forms": (char) => char >= 65280 && char <= 65519
        // 'Specials': (char) => char >= 0xFFF0 && char <= 0xFFFF,
        // 'Linear B Syllabary': (char) => char >= 0x10000 && char <= 0x1007F,
        // 'Linear B Ideograms': (char) => char >= 0x10080 && char <= 0x100FF,
        // 'Aegean Numbers': (char) => char >= 0x10100 && char <= 0x1013F,
        // 'Ancient Greek Numbers': (char) => char >= 0x10140 && char <= 0x1018F,
        // 'Ancient Symbols': (char) => char >= 0x10190 && char <= 0x101CF,
        // 'Phaistos Disc': (char) => char >= 0x101D0 && char <= 0x101FF,
        // 'Lycian': (char) => char >= 0x10280 && char <= 0x1029F,
        // 'Carian': (char) => char >= 0x102A0 && char <= 0x102DF,
        // 'Coptic Epact Numbers': (char) => char >= 0x102E0 && char <= 0x102FF,
        // 'Old Italic': (char) => char >= 0x10300 && char <= 0x1032F,
        // 'Gothic': (char) => char >= 0x10330 && char <= 0x1034F,
        // 'Old Permic': (char) => char >= 0x10350 && char <= 0x1037F,
        // 'Ugaritic': (char) => char >= 0x10380 && char <= 0x1039F,
        // 'Old Persian': (char) => char >= 0x103A0 && char <= 0x103DF,
        // 'Deseret': (char) => char >= 0x10400 && char <= 0x1044F,
        // 'Shavian': (char) => char >= 0x10450 && char <= 0x1047F,
        // 'Osmanya': (char) => char >= 0x10480 && char <= 0x104AF,
        // 'Osage': (char) => char >= 0x104B0 && char <= 0x104FF,
        // 'Elbasan': (char) => char >= 0x10500 && char <= 0x1052F,
        // 'Caucasian Albanian': (char) => char >= 0x10530 && char <= 0x1056F,
        // 'Linear A': (char) => char >= 0x10600 && char <= 0x1077F,
        // 'Cypriot Syllabary': (char) => char >= 0x10800 && char <= 0x1083F,
        // 'Imperial Aramaic': (char) => char >= 0x10840 && char <= 0x1085F,
        // 'Palmyrene': (char) => char >= 0x10860 && char <= 0x1087F,
        // 'Nabataean': (char) => char >= 0x10880 && char <= 0x108AF,
        // 'Hatran': (char) => char >= 0x108E0 && char <= 0x108FF,
        // 'Phoenician': (char) => char >= 0x10900 && char <= 0x1091F,
        // 'Lydian': (char) => char >= 0x10920 && char <= 0x1093F,
        // 'Meroitic Hieroglyphs': (char) => char >= 0x10980 && char <= 0x1099F,
        // 'Meroitic Cursive': (char) => char >= 0x109A0 && char <= 0x109FF,
        // 'Kharoshthi': (char) => char >= 0x10A00 && char <= 0x10A5F,
        // 'Old South Arabian': (char) => char >= 0x10A60 && char <= 0x10A7F,
        // 'Old North Arabian': (char) => char >= 0x10A80 && char <= 0x10A9F,
        // 'Manichaean': (char) => char >= 0x10AC0 && char <= 0x10AFF,
        // 'Avestan': (char) => char >= 0x10B00 && char <= 0x10B3F,
        // 'Inscriptional Parthian': (char) => char >= 0x10B40 && char <= 0x10B5F,
        // 'Inscriptional Pahlavi': (char) => char >= 0x10B60 && char <= 0x10B7F,
        // 'Psalter Pahlavi': (char) => char >= 0x10B80 && char <= 0x10BAF,
        // 'Old Turkic': (char) => char >= 0x10C00 && char <= 0x10C4F,
        // 'Old Hungarian': (char) => char >= 0x10C80 && char <= 0x10CFF,
        // 'Rumi Numeral Symbols': (char) => char >= 0x10E60 && char <= 0x10E7F,
        // 'Brahmi': (char) => char >= 0x11000 && char <= 0x1107F,
        // 'Kaithi': (char) => char >= 0x11080 && char <= 0x110CF,
        // 'Sora Sompeng': (char) => char >= 0x110D0 && char <= 0x110FF,
        // 'Chakma': (char) => char >= 0x11100 && char <= 0x1114F,
        // 'Mahajani': (char) => char >= 0x11150 && char <= 0x1117F,
        // 'Sharada': (char) => char >= 0x11180 && char <= 0x111DF,
        // 'Sinhala Archaic Numbers': (char) => char >= 0x111E0 && char <= 0x111FF,
        // 'Khojki': (char) => char >= 0x11200 && char <= 0x1124F,
        // 'Multani': (char) => char >= 0x11280 && char <= 0x112AF,
        // 'Khudawadi': (char) => char >= 0x112B0 && char <= 0x112FF,
        // 'Grantha': (char) => char >= 0x11300 && char <= 0x1137F,
        // 'Newa': (char) => char >= 0x11400 && char <= 0x1147F,
        // 'Tirhuta': (char) => char >= 0x11480 && char <= 0x114DF,
        // 'Siddham': (char) => char >= 0x11580 && char <= 0x115FF,
        // 'Modi': (char) => char >= 0x11600 && char <= 0x1165F,
        // 'Mongolian Supplement': (char) => char >= 0x11660 && char <= 0x1167F,
        // 'Takri': (char) => char >= 0x11680 && char <= 0x116CF,
        // 'Ahom': (char) => char >= 0x11700 && char <= 0x1173F,
        // 'Warang Citi': (char) => char >= 0x118A0 && char <= 0x118FF,
        // 'Zanabazar Square': (char) => char >= 0x11A00 && char <= 0x11A4F,
        // 'Soyombo': (char) => char >= 0x11A50 && char <= 0x11AAF,
        // 'Pau Cin Hau': (char) => char >= 0x11AC0 && char <= 0x11AFF,
        // 'Bhaiksuki': (char) => char >= 0x11C00 && char <= 0x11C6F,
        // 'Marchen': (char) => char >= 0x11C70 && char <= 0x11CBF,
        // 'Masaram Gondi': (char) => char >= 0x11D00 && char <= 0x11D5F,
        // 'Cuneiform': (char) => char >= 0x12000 && char <= 0x123FF,
        // 'Cuneiform Numbers and Punctuation': (char) => char >= 0x12400 && char <= 0x1247F,
        // 'Early Dynastic Cuneiform': (char) => char >= 0x12480 && char <= 0x1254F,
        // 'Egyptian Hieroglyphs': (char) => char >= 0x13000 && char <= 0x1342F,
        // 'Anatolian Hieroglyphs': (char) => char >= 0x14400 && char <= 0x1467F,
        // 'Bamum Supplement': (char) => char >= 0x16800 && char <= 0x16A3F,
        // 'Mro': (char) => char >= 0x16A40 && char <= 0x16A6F,
        // 'Bassa Vah': (char) => char >= 0x16AD0 && char <= 0x16AFF,
        // 'Pahawh Hmong': (char) => char >= 0x16B00 && char <= 0x16B8F,
        // 'Miao': (char) => char >= 0x16F00 && char <= 0x16F9F,
        // 'Ideographic Symbols and Punctuation': (char) => char >= 0x16FE0 && char <= 0x16FFF,
        // 'Tangut': (char) => char >= 0x17000 && char <= 0x187FF,
        // 'Tangut Components': (char) => char >= 0x18800 && char <= 0x18AFF,
        // 'Kana Supplement': (char) => char >= 0x1B000 && char <= 0x1B0FF,
        // 'Kana Extended-A': (char) => char >= 0x1B100 && char <= 0x1B12F,
        // 'Nushu': (char) => char >= 0x1B170 && char <= 0x1B2FF,
        // 'Duployan': (char) => char >= 0x1BC00 && char <= 0x1BC9F,
        // 'Shorthand Format Controls': (char) => char >= 0x1BCA0 && char <= 0x1BCAF,
        // 'Byzantine Musical Symbols': (char) => char >= 0x1D000 && char <= 0x1D0FF,
        // 'Musical Symbols': (char) => char >= 0x1D100 && char <= 0x1D1FF,
        // 'Ancient Greek Musical Notation': (char) => char >= 0x1D200 && char <= 0x1D24F,
        // 'Tai Xuan Jing Symbols': (char) => char >= 0x1D300 && char <= 0x1D35F,
        // 'Counting Rod Numerals': (char) => char >= 0x1D360 && char <= 0x1D37F,
        // 'Mathematical Alphanumeric Symbols': (char) => char >= 0x1D400 && char <= 0x1D7FF,
        // 'Sutton SignWriting': (char) => char >= 0x1D800 && char <= 0x1DAAF,
        // 'Glagolitic Supplement': (char) => char >= 0x1E000 && char <= 0x1E02F,
        // 'Mende Kikakui': (char) => char >= 0x1E800 && char <= 0x1E8DF,
        // 'Adlam': (char) => char >= 0x1E900 && char <= 0x1E95F,
        // 'Arabic Mathematical Alphabetic Symbols': (char) => char >= 0x1EE00 && char <= 0x1EEFF,
        // 'Mahjong Tiles': (char) => char >= 0x1F000 && char <= 0x1F02F,
        // 'Domino Tiles': (char) => char >= 0x1F030 && char <= 0x1F09F,
        // 'Playing Cards': (char) => char >= 0x1F0A0 && char <= 0x1F0FF,
        // 'Enclosed Alphanumeric Supplement': (char) => char >= 0x1F100 && char <= 0x1F1FF,
        // 'Enclosed Ideographic Supplement': (char) => char >= 0x1F200 && char <= 0x1F2FF,
        // 'Miscellaneous Symbols and Pictographs': (char) => char >= 0x1F300 && char <= 0x1F5FF,
        // 'Emoticons': (char) => char >= 0x1F600 && char <= 0x1F64F,
        // 'Ornamental Dingbats': (char) => char >= 0x1F650 && char <= 0x1F67F,
        // 'Transport and Map Symbols': (char) => char >= 0x1F680 && char <= 0x1F6FF,
        // 'Alchemical Symbols': (char) => char >= 0x1F700 && char <= 0x1F77F,
        // 'Geometric Shapes Extended': (char) => char >= 0x1F780 && char <= 0x1F7FF,
        // 'Supplemental Arrows-C': (char) => char >= 0x1F800 && char <= 0x1F8FF,
        // 'Supplemental Symbols and Pictographs': (char) => char >= 0x1F900 && char <= 0x1F9FF,
        // 'CJK Unified Ideographs Extension B': (char) => char >= 0x20000 && char <= 0x2A6DF,
        // 'CJK Unified Ideographs Extension C': (char) => char >= 0x2A700 && char <= 0x2B73F,
        // 'CJK Unified Ideographs Extension D': (char) => char >= 0x2B740 && char <= 0x2B81F,
        // 'CJK Unified Ideographs Extension E': (char) => char >= 0x2B820 && char <= 0x2CEAF,
        // 'CJK Unified Ideographs Extension F': (char) => char >= 0x2CEB0 && char <= 0x2EBEF,
        // 'CJK Compatibility Ideographs Supplement': (char) => char >= 0x2F800 && char <= 0x2FA1F,
        // 'Tags': (char) => char >= 0xE0000 && char <= 0xE007F,
        // 'Variation Selectors Supplement': (char) => char >= 0xE0100 && char <= 0xE01EF,
        // 'Supplementary Private Use Area-A': (char) => char >= 0xF0000 && char <= 0xFFFFF,
        // 'Supplementary Private Use Area-B': (char) => char >= 0x100000 && char <= 0x10FFFF,
      };
      module.exports = unicodeBlockLookup;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/script_detection.js
  var require_script_detection = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/script_detection.js"(exports, module) {
      var isChar = require_is_char_in_unicode_block();
      module.exports = {
        allowsIdeographicBreaking,
        allowsVerticalWritingMode,
        allowsLetterSpacing,
        charAllowsLetterSpacing,
        charAllowsIdeographicBreaking,
        charHasUprightVerticalOrientation,
        charHasNeutralVerticalOrientation,
        charHasRotatedVerticalOrientation,
        charInSupportedScript,
        isStringInSupportedScript
      };
      function allowsIdeographicBreaking(chars) {
        for (const char of chars) {
          if (!charAllowsIdeographicBreaking(char.charCodeAt(0))) return false;
        }
        return true;
      }
      function allowsVerticalWritingMode(chars) {
        for (const char of chars) {
          if (charHasUprightVerticalOrientation(char.charCodeAt(0))) return true;
        }
        return false;
      }
      function allowsLetterSpacing(chars) {
        for (const char of chars) {
          if (!charAllowsLetterSpacing(char.charCodeAt(0))) return false;
        }
        return true;
      }
      function charAllowsLetterSpacing(char) {
        if (isChar["Arabic"](char)) return false;
        if (isChar["Arabic Supplement"](char)) return false;
        if (isChar["Arabic Extended-A"](char)) return false;
        if (isChar["Arabic Presentation Forms-A"](char)) return false;
        if (isChar["Arabic Presentation Forms-B"](char)) return false;
        return true;
      }
      function charAllowsIdeographicBreaking(char) {
        if (char < 11904) return false;
        if (isChar["Bopomofo Extended"](char)) return true;
        if (isChar["Bopomofo"](char)) return true;
        if (isChar["CJK Compatibility Forms"](char)) return true;
        if (isChar["CJK Compatibility Ideographs"](char)) return true;
        if (isChar["CJK Compatibility"](char)) return true;
        if (isChar["CJK Radicals Supplement"](char)) return true;
        if (isChar["CJK Strokes"](char)) return true;
        if (isChar["CJK Symbols and Punctuation"](char)) return true;
        if (isChar["CJK Unified Ideographs Extension A"](char)) return true;
        if (isChar["CJK Unified Ideographs"](char)) return true;
        if (isChar["Enclosed CJK Letters and Months"](char)) return true;
        if (isChar["Halfwidth and Fullwidth Forms"](char)) return true;
        if (isChar["Hiragana"](char)) return true;
        if (isChar["Ideographic Description Characters"](char)) return true;
        if (isChar["Kangxi Radicals"](char)) return true;
        if (isChar["Katakana Phonetic Extensions"](char)) return true;
        if (isChar["Katakana"](char)) return true;
        if (isChar["Vertical Forms"](char)) return true;
        if (isChar["Yi Radicals"](char)) return true;
        if (isChar["Yi Syllables"](char)) return true;
        return false;
      }
      function charHasUprightVerticalOrientation(char) {
        if (char === 746 || char === 747) {
          return true;
        }
        if (char < 4352) return false;
        if (isChar["Bopomofo Extended"](char)) return true;
        if (isChar["Bopomofo"](char)) return true;
        if (isChar["CJK Compatibility Forms"](char)) {
          if (!(char >= 65097 && char <= 65103)) {
            return true;
          }
        }
        if (isChar["CJK Compatibility Ideographs"](char)) return true;
        if (isChar["CJK Compatibility"](char)) return true;
        if (isChar["CJK Radicals Supplement"](char)) return true;
        if (isChar["CJK Strokes"](char)) return true;
        if (isChar["CJK Symbols and Punctuation"](char)) {
          if (!(char >= 12296 && char <= 12305) && !(char >= 12308 && char <= 12319) && char !== 12336) {
            return true;
          }
        }
        if (isChar["CJK Unified Ideographs Extension A"](char)) return true;
        if (isChar["CJK Unified Ideographs"](char)) return true;
        if (isChar["Enclosed CJK Letters and Months"](char)) return true;
        if (isChar["Hangul Compatibility Jamo"](char)) return true;
        if (isChar["Hangul Jamo Extended-A"](char)) return true;
        if (isChar["Hangul Jamo Extended-B"](char)) return true;
        if (isChar["Hangul Jamo"](char)) return true;
        if (isChar["Hangul Syllables"](char)) return true;
        if (isChar["Hiragana"](char)) return true;
        if (isChar["Ideographic Description Characters"](char)) return true;
        if (isChar["Kanbun"](char)) return true;
        if (isChar["Kangxi Radicals"](char)) return true;
        if (isChar["Katakana Phonetic Extensions"](char)) return true;
        if (isChar["Katakana"](char)) {
          if (char !== 12540) {
            return true;
          }
        }
        if (isChar["Halfwidth and Fullwidth Forms"](char)) {
          if (char !== 65288 && char !== 65289 && char !== 65293 && !(char >= 65306 && char <= 65310) && char !== 65339 && char !== 65341 && char !== 65343 && !(char >= 65371 && char <= 65503) && char !== 65507 && !(char >= 65512 && char <= 65519)) {
            return true;
          }
        }
        if (isChar["Small Form Variants"](char)) {
          if (!(char >= 65112 && char <= 65118) && !(char >= 65123 && char <= 65126)) {
            return true;
          }
        }
        if (isChar["Unified Canadian Aboriginal Syllabics"](char)) return true;
        if (isChar["Unified Canadian Aboriginal Syllabics Extended"](char)) return true;
        if (isChar["Vertical Forms"](char)) return true;
        if (isChar["Yijing Hexagram Symbols"](char)) return true;
        if (isChar["Yi Syllables"](char)) return true;
        if (isChar["Yi Radicals"](char)) return true;
        return false;
      }
      function charHasNeutralVerticalOrientation(char) {
        if (isChar["Latin-1 Supplement"](char)) {
          if (char === 167 || char === 169 || char === 174 || char === 177 || char === 188 || char === 189 || char === 190 || char === 215 || char === 247) {
            return true;
          }
        }
        if (isChar["General Punctuation"](char)) {
          if (char === 8214 || char === 8224 || char === 8225 || char === 8240 || char === 8241 || char === 8251 || char === 8252 || char === 8258 || char === 8263 || char === 8264 || char === 8265 || char === 8273) {
            return true;
          }
        }
        if (isChar["Letterlike Symbols"](char)) return true;
        if (isChar["Number Forms"](char)) return true;
        if (isChar["Miscellaneous Technical"](char)) {
          if (char >= 8960 && char <= 8967 || char >= 8972 && char <= 8991 || char >= 8996 && char <= 9e3 || char === 9003 || char >= 9085 && char <= 9114 || char >= 9150 && char <= 9165 || char === 9167 || char >= 9169 && char <= 9179 || char >= 9186 && char <= 9215) {
            return true;
          }
        }
        if (isChar["Control Pictures"](char) && char !== 9251) return true;
        if (isChar["Optical Character Recognition"](char)) return true;
        if (isChar["Enclosed Alphanumerics"](char)) return true;
        if (isChar["Geometric Shapes"](char)) return true;
        if (isChar["Miscellaneous Symbols"](char)) {
          if (!(char >= 9754 && char <= 9759)) {
            return true;
          }
        }
        if (isChar["Miscellaneous Symbols and Arrows"](char)) {
          if (char >= 11026 && char <= 11055 || char >= 11088 && char <= 11097 || char >= 11192 && char <= 11243) {
            return true;
          }
        }
        if (isChar["CJK Symbols and Punctuation"](char)) return true;
        if (isChar["Katakana"](char)) return true;
        if (isChar["Private Use Area"](char)) return true;
        if (isChar["CJK Compatibility Forms"](char)) return true;
        if (isChar["Small Form Variants"](char)) return true;
        if (isChar["Halfwidth and Fullwidth Forms"](char)) return true;
        if (char === 8734 || char === 8756 || char === 8757 || char >= 9984 && char <= 10087 || char >= 10102 && char <= 10131 || char === 65532 || char === 65533) {
          return true;
        }
        return false;
      }
      function charHasRotatedVerticalOrientation(char) {
        return !(charHasUprightVerticalOrientation(char) || charHasNeutralVerticalOrientation(char));
      }
      function charInSupportedScript(char, canRenderRTL) {
        if (!canRenderRTL && (char >= 1424 && char <= 2303 || isChar["Arabic Presentation Forms-A"](char) || isChar["Arabic Presentation Forms-B"](char))) {
          return false;
        }
        if (char >= 2304 && char <= 3583 || // Main blocks for Indic scripts and Sinhala
        char >= 3840 && char <= 4255 || // Main blocks for Tibetan and Myanmar
        isChar["Khmer"](char)) {
          return false;
        }
        return true;
      }
      function isStringInSupportedScript(chars, canRenderRTL) {
        for (const char of chars) {
          if (!charInSupportedScript(char.charCodeAt(0), canRenderRTL)) {
            return false;
          }
        }
        return true;
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/evaluation_parameters.js
  var require_evaluation_parameters = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/evaluation_parameters.js"(exports, module) {
      var ZoomHistory = require_zoom_history();
      var { isStringInSupportedScript } = require_script_detection();
      var { plugin: rtlTextPlugin } = require_rtl_text_plugin();
      var EvaluationParameters = class {
        // "options" may also be another EvaluationParameters to copy, see CrossFadedProperty.possiblyEvaluate
        constructor(zoom, options) {
          this.zoom = zoom;
          if (options) {
            this.now = options.now;
            this.fadeDuration = options.fadeDuration;
            this.zoomHistory = options.zoomHistory;
            this.transition = options.transition;
          } else {
            this.now = 0;
            this.fadeDuration = 0;
            this.zoomHistory = new ZoomHistory();
            this.transition = {};
          }
        }
        isSupportedScript(str) {
          return isStringInSupportedScript(str, rtlTextPlugin.isLoaded());
        }
        crossFadingFactor() {
          if (this.fadeDuration === 0) {
            return 1;
          }
          return Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const z = this.zoom;
          const fraction = z - Math.floor(z);
          const t = this.crossFadingFactor();
          return z > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: fraction + (1 - fraction) * t } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - t) * fraction };
        }
      };
      module.exports = EvaluationParameters;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/properties.js
  var require_properties2 = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/properties.js"(exports, module) {
      var assert = require_nanoassert();
      var { clone } = require_object();
      var { easeCubicInOut } = require_util();
      var { interpolate: interpolate2, normalizePropertyExpression } = require_style_expressions();
      var { register } = require_transfer_registry();
      var EvaluationParameters = require_evaluation_parameters();
      var PropertyValue = class {
        constructor(property, value) {
          this.property = property;
          this.value = value;
          this.expression = normalizePropertyExpression(
            value === void 0 ? property.specification.default : value,
            property.specification
          );
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(parameters) {
          return this.property.possiblyEvaluate(this, parameters);
        }
      };
      var TransitionablePropertyValue = class {
        constructor(property) {
          this.property = property;
          this.value = new PropertyValue(property, void 0);
        }
        transitioned(parameters, prior) {
          return new TransitioningPropertyValue(
            this.property,
            this.value,
            prior,
            Object.assign({}, parameters.transition, this.transition),
            parameters.now
          );
        }
        untransitioned() {
          return new TransitioningPropertyValue(this.property, this.value, null, {}, 0);
        }
      };
      var Transitionable = class {
        constructor(properties) {
          this._properties = properties;
          this._values = Object.create(properties.defaultTransitionablePropertyValues);
        }
        getValue(name) {
          return clone(this._values[name].value.value);
        }
        setValue(name, value) {
          if (!this._values.hasOwnProperty(name)) {
            this._values[name] = new TransitionablePropertyValue(this._values[name].property);
          }
          this._values[name].value = new PropertyValue(
            this._values[name].property,
            value === null ? void 0 : clone(value)
          );
        }
        getTransition(name) {
          return clone(this._values[name].transition);
        }
        setTransition(name, value) {
          if (!this._values.hasOwnProperty(name)) {
            this._values[name] = new TransitionablePropertyValue(this._values[name].property);
          }
          this._values[name].transition = clone(value) || void 0;
        }
        serialize() {
          const result = {};
          for (const property of Object.keys(this._values)) {
            const value = this.getValue(property);
            if (value !== void 0) {
              result[property] = value;
            }
            const transition = this.getTransition(property);
            if (transition !== void 0) {
              result[`${property}-transition`] = transition;
            }
          }
          return result;
        }
        transitioned(parameters, prior) {
          const result = new Transitioning(this._properties);
          for (const property of Object.keys(this._values)) {
            result._values[property] = this._values[property].transitioned(parameters, prior._values[property]);
          }
          return result;
        }
        untransitioned() {
          const result = new Transitioning(this._properties);
          for (const property of Object.keys(this._values)) {
            result._values[property] = this._values[property].untransitioned();
          }
          return result;
        }
      };
      var TransitioningPropertyValue = class {
        constructor(property, value, prior, transition, now) {
          this.property = property;
          this.value = value;
          this.begin = now + transition.delay || 0;
          this.end = this.begin + transition.duration || 0;
          if (property.specification.transition && (transition.delay || transition.duration)) {
            this.prior = prior;
          }
        }
        possiblyEvaluate(parameters) {
          const now = parameters.now || 0;
          const finalValue = this.value.possiblyEvaluate(parameters);
          const prior = this.prior;
          if (!prior) {
            return finalValue;
          }
          if (now > this.end) {
            this.prior = null;
            return finalValue;
          }
          if (this.value.isDataDriven()) {
            this.prior = null;
            return finalValue;
          }
          if (now < this.begin) {
            return prior.possiblyEvaluate(parameters);
          }
          const t = (now - this.begin) / (this.end - this.begin);
          return this.property.interpolate(prior.possiblyEvaluate(parameters), finalValue, easeCubicInOut(t));
        }
      };
      var Transitioning = class {
        constructor(properties) {
          this._properties = properties;
          this._values = Object.create(properties.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(parameters) {
          const result = new PossiblyEvaluated(this._properties);
          for (const property of Object.keys(this._values)) {
            result._values[property] = this._values[property].possiblyEvaluate(parameters);
          }
          return result;
        }
        hasTransition() {
          for (const property of Object.keys(this._values)) {
            if (this._values[property].prior) {
              return true;
            }
          }
          return false;
        }
      };
      var Layout = class {
        constructor(properties) {
          this._properties = properties;
          this._values = Object.create(properties.defaultPropertyValues);
        }
        getValue(name) {
          return clone(this._values[name].value);
        }
        setValue(name, value) {
          this._values[name] = new PropertyValue(this._values[name].property, value === null ? void 0 : clone(value));
        }
        serialize() {
          const result = {};
          for (const property of Object.keys(this._values)) {
            const value = this.getValue(property);
            if (value !== void 0) {
              result[property] = value;
            }
          }
          return result;
        }
        possiblyEvaluate(parameters) {
          const result = new PossiblyEvaluated(this._properties);
          for (const property of Object.keys(this._values)) {
            result._values[property] = this._values[property].possiblyEvaluate(parameters);
          }
          return result;
        }
      };
      var PossiblyEvaluatedPropertyValue = class {
        constructor(property, value, parameters) {
          this.property = property;
          this.value = value;
          this.parameters = parameters;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(value) {
          if (this.value.kind === "constant") {
            return this.value.value;
          }
          return value;
        }
        evaluate(feature, featureState) {
          return this.property.evaluate(this.value, this.parameters, feature, featureState);
        }
      };
      var PossiblyEvaluated = class {
        constructor(properties) {
          this._properties = properties;
          this._values = Object.create(properties.defaultPossiblyEvaluatedValues);
        }
        get(name) {
          return this._values[name];
        }
      };
      var DataConstantProperty = class {
        constructor(specification) {
          this.specification = specification;
          this.specification["property-type"] ??= "data-constant";
        }
        possiblyEvaluate(value, parameters) {
          assert(!value.isDataDriven());
          return value.expression.evaluate(parameters);
        }
        interpolate(a, b, t) {
          const interp = interpolate2[this.specification.type];
          if (interp) {
            return interp(a, b, t);
          }
          return a;
        }
      };
      var DataDrivenProperty = class {
        constructor(specification) {
          this.specification = specification;
          this.specification["property-type"] ??= "data-driven";
        }
        possiblyEvaluate(value, parameters) {
          if (value.expression.kind === "constant" || value.expression.kind === "camera") {
            return new PossiblyEvaluatedPropertyValue(
              this,
              { kind: "constant", value: value.expression.evaluate(parameters) },
              parameters
            );
          }
          return new PossiblyEvaluatedPropertyValue(this, value.expression, parameters);
        }
        interpolate(a, b, t) {
          if (a.value.kind !== "constant" || b.value.kind !== "constant") {
            return a;
          }
          if (a.value.value === void 0 || b.value.value === void 0) {
            return new PossiblyEvaluatedPropertyValue(this, { kind: "constant", value: void 0 }, a.parameters);
          }
          const interp = interpolate2[this.specification.type];
          if (interp) {
            return new PossiblyEvaluatedPropertyValue(
              this,
              { kind: "constant", value: interp(a.value.value, b.value.value, t) },
              a.parameters
            );
          }
          return a;
        }
        evaluate(value, parameters, feature, featureState) {
          if (value.kind === "constant") {
            return value.value;
          }
          return value.evaluate(parameters, feature, featureState);
        }
      };
      var CrossFadedDataDrivenProperty = class extends DataDrivenProperty {
        constructor(specification) {
          specification["property-type"] ??= "cross-faded-data-driven";
          super(specification);
        }
        possiblyEvaluate(value, parameters) {
          if (value.value === void 0) {
            return new PossiblyEvaluatedPropertyValue(this, { kind: "constant", value: void 0 }, parameters);
          }
          if (value.expression.kind === "constant") {
            const constantValue = value.expression.evaluate(parameters);
            const constant = this._calculate(constantValue, constantValue, constantValue, parameters);
            return new PossiblyEvaluatedPropertyValue(this, { kind: "constant", value: constant }, parameters);
          }
          if (value.expression.kind === "camera") {
            const cameraVal = this._calculate(
              value.expression.evaluate({ zoom: parameters.zoom - 1 }),
              value.expression.evaluate({ zoom: parameters.zoom }),
              value.expression.evaluate({ zoom: parameters.zoom + 1 }),
              parameters
            );
            return new PossiblyEvaluatedPropertyValue(this, { kind: "constant", value: cameraVal }, parameters);
          }
          return new PossiblyEvaluatedPropertyValue(this, value.expression, parameters);
        }
        evaluate(value, globals, feature, featureState) {
          if (value.kind === "source") {
            const constant = value.evaluate(globals, feature, featureState);
            return this._calculate(constant, constant, constant, globals);
          }
          if (value.kind === "composite") {
            return this._calculate(
              value.evaluate({ zoom: Math.floor(globals.zoom) - 1 }, feature, featureState),
              value.evaluate({ zoom: Math.floor(globals.zoom) }, feature, featureState),
              value.evaluate({ zoom: Math.floor(globals.zoom) + 1 }, feature, featureState),
              globals
            );
          }
          return value.value;
        }
        _calculate(min, mid, max, parameters) {
          const z = parameters.zoom;
          return z > parameters.zoomHistory.lastIntegerZoom ? { from: min, to: mid } : { from: max, to: mid };
        }
        interpolate(a) {
          return a;
        }
      };
      var CrossFadedProperty = class {
        constructor(specification) {
          this.specification = specification;
          this.specification["property-type"] ??= "cross-faded";
        }
        possiblyEvaluate(value, parameters) {
          if (value.value === void 0) {
            return void 0;
          }
          if (value.expression.kind === "constant") {
            const constant = value.expression.evaluate(parameters);
            return this._calculate(constant, constant, constant, parameters);
          }
          assert(!value.isDataDriven());
          return this._calculate(
            value.expression.evaluate(new EvaluationParameters(Math.floor(parameters.zoom - 1), parameters)),
            value.expression.evaluate(new EvaluationParameters(Math.floor(parameters.zoom), parameters)),
            value.expression.evaluate(new EvaluationParameters(Math.floor(parameters.zoom + 1), parameters)),
            parameters
          );
        }
        _calculate(min, mid, max, parameters) {
          const z = parameters.zoom;
          return z > parameters.zoomHistory.lastIntegerZoom ? { from: min, to: mid } : { from: max, to: mid };
        }
        interpolate(a) {
          return a;
        }
      };
      var ColorRampProperty = class {
        constructor(specification) {
          this.specification = specification;
          this.specification["property-type"] ??= "color-ramp";
        }
        possiblyEvaluate(value, parameters) {
          return !!value.expression.evaluate(parameters);
        }
        interpolate() {
          return false;
        }
      };
      var Properties = class {
        constructor(properties) {
          this.properties = properties;
          this.defaultPropertyValues = {};
          this.defaultTransitionablePropertyValues = {};
          this.defaultTransitioningPropertyValues = {};
          this.defaultPossiblyEvaluatedValues = {};
          for (const property in properties) {
            const prop = properties[property];
            const defaultPropertyValue = this.defaultPropertyValues[property] = new PropertyValue(prop, void 0);
            const defaultTransitionablePropertyValue = this.defaultTransitionablePropertyValues[property] = new TransitionablePropertyValue(prop);
            this.defaultTransitioningPropertyValues[property] = defaultTransitionablePropertyValue.untransitioned();
            this.defaultPossiblyEvaluatedValues[property] = defaultPropertyValue.possiblyEvaluate({});
          }
        }
      };
      register("DataDrivenProperty", DataDrivenProperty);
      register("DataConstantProperty", DataConstantProperty);
      register("CrossFadedDataDrivenProperty", CrossFadedDataDrivenProperty);
      register("CrossFadedProperty", CrossFadedProperty);
      register("ColorRampProperty", ColorRampProperty);
      module.exports = {
        PropertyValue,
        Transitionable,
        Transitioning,
        Layout,
        PossiblyEvaluatedPropertyValue,
        PossiblyEvaluated,
        DataConstantProperty,
        DataDrivenProperty,
        CrossFadedDataDrivenProperty,
        CrossFadedProperty,
        ColorRampProperty,
        Properties
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer.js
  var require_style_layer = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer.js"(exports, module) {
      var { filterObject } = require_object();
      var { Evented: Evented3 } = (init_events(), __toCommonJS(events_exports));
      var { Layout, Transitionable, PossiblyEvaluatedPropertyValue } = require_properties2();
      var { supportsPropertyExpression } = require_style_expressions();
      var TRANSITION_SUFFIX = "-transition";
      var StyleLayer = class extends Evented3 {
        constructor(layer, properties) {
          super();
          this.id = layer.id;
          this.metadata = layer.metadata;
          this.type = layer.type;
          this.minzoom = layer.minzoom;
          this.maxzoom = layer.maxzoom;
          this.visibility = "visible";
          this.paint = {};
          this.layout = {};
          if (layer.type !== "background") {
            this.source = layer.source;
            this.sourceLayer = layer["source-layer"];
            this.filter = layer.filter;
          }
          this._featureFilter = () => true;
          if (properties.layout) {
            this._unevaluatedLayout = new Layout(properties.layout);
          }
          this._transitionablePaint = new Transitionable(properties.paint);
          for (const property in layer.paint) {
            this.setPaintProperty(property, layer.paint[property]);
          }
          for (const property in layer.layout) {
            this.setLayoutProperty(property, layer.layout[property]);
          }
          this._transitioningPaint = this._transitionablePaint.untransitioned();
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(name) {
          if (name === "visibility") {
            return this.visibility;
          }
          return this._unevaluatedLayout.getValue(name);
        }
        setLayoutProperty(name, value) {
          if (name === "visibility") {
            this.visibility = value === "none" ? value : "visible";
            return;
          }
          this._unevaluatedLayout.setValue(name, value);
        }
        getPaintProperty(name) {
          if (name.endsWith(TRANSITION_SUFFIX)) {
            return this._transitionablePaint.getTransition(name.slice(0, -TRANSITION_SUFFIX.length));
          }
          return this._transitionablePaint.getValue(name);
        }
        setPaintProperty(name, value) {
          if (name.endsWith(TRANSITION_SUFFIX)) {
            this._transitionablePaint.setTransition(name.slice(0, -TRANSITION_SUFFIX.length), value || void 0);
            return false;
          }
          const prop = this._transitionablePaint._values[name];
          const newCrossFadedValue = prop.property.specification["property-type"] === "cross-faded-data-driven" && !prop.value.value && value;
          const wasDataDriven = this._transitionablePaint._values[name].value.isDataDriven();
          this._transitionablePaint.setValue(name, value);
          const isDataDriven = this._transitionablePaint._values[name].value.isDataDriven();
          this._handleSpecialPaintPropertyUpdate(name);
          return isDataDriven || wasDataDriven || newCrossFadedValue;
        }
        _handleSpecialPaintPropertyUpdate() {
        }
        isHidden(zoom) {
          if (this.minzoom && zoom < this.minzoom) return true;
          if (this.maxzoom && zoom >= this.maxzoom) return true;
          return this.visibility === "none";
        }
        updateTransitions(parameters) {
          this._transitioningPaint = this._transitionablePaint.transitioned(parameters, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(parameters) {
          if (parameters.getCrossfadeParameters) {
            this._crossfadeParameters = parameters.getCrossfadeParameters();
          }
          if (this._unevaluatedLayout) {
            this.layout = this._unevaluatedLayout.possiblyEvaluate(parameters);
          }
          this.paint = this._transitioningPaint.possiblyEvaluate(parameters);
        }
        serialize() {
          const output = {
            id: this.id,
            type: this.type,
            source: this.source,
            "source-layer": this.sourceLayer,
            metadata: this.metadata,
            minzoom: this.minzoom,
            maxzoom: this.maxzoom,
            filter: this.filter,
            layout: this._unevaluatedLayout?.serialize(),
            paint: this._transitionablePaint?.serialize()
          };
          if (this.visibility === "none") {
            output.layout = output.layout || {};
            output.layout.visibility = "none";
          }
          return filterObject(output, (value, key) => {
            return value !== void 0 && !(key === "layout" && !Object.keys(value).length) && !(key === "paint" && !Object.keys(value).length);
          });
        }
        is3D() {
          return false;
        }
        isTileClipped() {
          return false;
        }
        hasOffscreenPass() {
          return false;
        }
        resize() {
        }
        isStateDependent() {
          for (const property in this.paint._values) {
            const value = this.paint.get(property);
            if (!(value instanceof PossiblyEvaluatedPropertyValue) || !supportsPropertyExpression(value.property.specification)) {
              continue;
            }
            if ((value.value.kind === "source" || value.value.kind === "composite") && value.value.isStateDependent) {
              return true;
            }
          }
          return false;
        }
      };
      module.exports = StyleLayer;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/struct_array.js
  var require_struct_array = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/struct_array.js"(exports, module) {
      var assert = require_nanoassert();
      var viewTypes = {
        Int8: Int8Array,
        Uint8: Uint8Array,
        Int16: Int16Array,
        Uint16: Uint16Array,
        Int32: Int32Array,
        Uint32: Uint32Array,
        Float32: Float32Array
      };
      var Struct = class {
        // The following properties are defined on the prototype of sub classes.
        /**
         * @param {StructArray} structArray The StructArray the struct is stored in
         * @param {number} index The index of the struct in the StructArray.
         * @private
         */
        constructor(structArray, index) {
          this._structArray = structArray;
          this._pos1 = index * this.size;
          this._pos2 = this._pos1 / 2;
          this._pos4 = this._pos1 / 4;
          this._pos8 = this._pos1 / 8;
        }
      };
      var DEFAULT_CAPACITY = 128;
      var RESIZE_MULTIPLIER = 5;
      var StructArray = class {
        // The following properties are defined on the prototype.
        constructor() {
          this.isTransferred = false;
          this.capacity = -1;
          this.resize(0);
        }
        /**
         * Serialize a StructArray instance.  Serializes both the raw data and the
         * metadata needed to reconstruct the StructArray base class during
         * deserialization.
         */
        static serialize(array, transferables) {
          assert(!array.isTransferred);
          array._trim();
          if (transferables) {
            array.isTransferred = true;
            transferables.push(array.arrayBuffer);
          }
          return {
            length: array.length,
            arrayBuffer: array.arrayBuffer
          };
        }
        static deserialize(input) {
          const structArray = Object.create(this.prototype);
          structArray.arrayBuffer = input.arrayBuffer;
          structArray.length = input.length;
          structArray.capacity = input.arrayBuffer.byteLength / structArray.bytesPerElement;
          structArray._refreshViews();
          return structArray;
        }
        /**
         * Resize the array to discard unused capacity.
         */
        _trim() {
          if (this.length !== this.capacity) {
            this.capacity = this.length;
            this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement);
            this._refreshViews();
          }
        }
        /**
         * Resets the the length of the array to 0 without de-allocating capcacity.
         */
        clear() {
          this.length = 0;
        }
        /**
         * Resize the array.
         * If `n` is greater than the current length then additional elements with undefined values are added.
         * If `n` is less than the current length then the array will be reduced to the first `n` elements.
         * @param {number} n The new size of the array.
         */
        resize(n) {
          assert(!this.isTransferred);
          this.reserve(n);
          this.length = n;
        }
        /**
         * Indicate a planned increase in size, so that any necessary allocation may
         * be done once, ahead of time.
         * @param {number} n The expected size of the array.
         */
        reserve(n) {
          if (n > this.capacity) {
            this.capacity = Math.max(n, Math.floor(this.capacity * RESIZE_MULTIPLIER), DEFAULT_CAPACITY);
            this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const oldUint8Array = this.uint8;
            this._refreshViews();
            if (oldUint8Array) this.uint8.set(oldUint8Array);
          }
        }
        /**
         * Create TypedArray views for the current ArrayBuffer.
         */
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      };
      function createLayout(members, alignment = 1) {
        let offset = 0;
        let maxSize = 0;
        const layoutMembers = members.map((member) => {
          assert(member.name.length);
          const typeSize = sizeOf(member.type);
          const memberOffset = offset = align(offset, Math.max(alignment, typeSize));
          const components = member.components || 1;
          maxSize = Math.max(maxSize, typeSize);
          offset += typeSize * components;
          return {
            name: member.name,
            type: member.type,
            components,
            offset: memberOffset
          };
        });
        const size = align(offset, Math.max(maxSize, alignment));
        return {
          members: layoutMembers,
          size,
          alignment
        };
      }
      function sizeOf(type) {
        return viewTypes[type].BYTES_PER_ELEMENT;
      }
      function align(offset, size) {
        return Math.ceil(offset / size) * size;
      }
      module.exports = { StructArray, Struct, viewTypes, createLayout };
    }
  });

  // node_modules/@mapbox/point-geometry/index.js
  var point_geometry_exports = {};
  __export(point_geometry_exports, {
    default: () => Point
  });
  function Point(x, y) {
    this.x = x;
    this.y = y;
  }
  var init_point_geometry = __esm({
    "node_modules/@mapbox/point-geometry/index.js"() {
      Point.prototype = {
        /**
         * Clone this point, returning a new point that can be modified
         * without affecting the old one.
         * @return {Point} the clone
         */
        clone() {
          return new Point(this.x, this.y);
        },
        /**
         * Add this point's x & y coordinates to another point,
         * yielding a new point.
         * @param {Point} p the other point
         * @return {Point} output point
         */
        add(p) {
          return this.clone()._add(p);
        },
        /**
         * Subtract this point's x & y coordinates to from point,
         * yielding a new point.
         * @param {Point} p the other point
         * @return {Point} output point
         */
        sub(p) {
          return this.clone()._sub(p);
        },
        /**
         * Multiply this point's x & y coordinates by point,
         * yielding a new point.
         * @param {Point} p the other point
         * @return {Point} output point
         */
        multByPoint(p) {
          return this.clone()._multByPoint(p);
        },
        /**
         * Divide this point's x & y coordinates by point,
         * yielding a new point.
         * @param {Point} p the other point
         * @return {Point} output point
         */
        divByPoint(p) {
          return this.clone()._divByPoint(p);
        },
        /**
         * Multiply this point's x & y coordinates by a factor,
         * yielding a new point.
         * @param {number} k factor
         * @return {Point} output point
         */
        mult(k) {
          return this.clone()._mult(k);
        },
        /**
         * Divide this point's x & y coordinates by a factor,
         * yielding a new point.
         * @param {number} k factor
         * @return {Point} output point
         */
        div(k) {
          return this.clone()._div(k);
        },
        /**
         * Rotate this point around the 0, 0 origin by an angle a,
         * given in radians
         * @param {number} a angle to rotate around, in radians
         * @return {Point} output point
         */
        rotate(a) {
          return this.clone()._rotate(a);
        },
        /**
         * Rotate this point around p point by an angle a,
         * given in radians
         * @param {number} a angle to rotate around, in radians
         * @param {Point} p Point to rotate around
         * @return {Point} output point
         */
        rotateAround(a, p) {
          return this.clone()._rotateAround(a, p);
        },
        /**
         * Multiply this point by a 4x1 transformation matrix
         * @param {[number, number, number, number]} m transformation matrix
         * @return {Point} output point
         */
        matMult(m) {
          return this.clone()._matMult(m);
        },
        /**
         * Calculate this point but as a unit vector from 0, 0, meaning
         * that the distance from the resulting point to the 0, 0
         * coordinate will be equal to 1 and the angle from the resulting
         * point to the 0, 0 coordinate will be the same as before.
         * @return {Point} unit vector point
         */
        unit() {
          return this.clone()._unit();
        },
        /**
         * Compute a perpendicular point, where the new y coordinate
         * is the old x coordinate and the new x coordinate is the old y
         * coordinate multiplied by -1
         * @return {Point} perpendicular point
         */
        perp() {
          return this.clone()._perp();
        },
        /**
         * Return a version of this point with the x & y coordinates
         * rounded to integers.
         * @return {Point} rounded point
         */
        round() {
          return this.clone()._round();
        },
        /**
         * Return the magnitude of this point: this is the Euclidean
         * distance from the 0, 0 coordinate to this point's x and y
         * coordinates.
         * @return {number} magnitude
         */
        mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        /**
         * Judge whether this point is equal to another point, returning
         * true or false.
         * @param {Point} other the other point
         * @return {boolean} whether the points are equal
         */
        equals(other) {
          return this.x === other.x && this.y === other.y;
        },
        /**
         * Calculate the distance from this point to another point
         * @param {Point} p the other point
         * @return {number} distance
         */
        dist(p) {
          return Math.sqrt(this.distSqr(p));
        },
        /**
         * Calculate the distance from this point to another point,
         * without the square root step. Useful if you're comparing
         * relative distances.
         * @param {Point} p the other point
         * @return {number} distance
         */
        distSqr(p) {
          const dx = p.x - this.x, dy = p.y - this.y;
          return dx * dx + dy * dy;
        },
        /**
         * Get the angle from the 0, 0 coordinate to this point, in radians
         * coordinates.
         * @return {number} angle
         */
        angle() {
          return Math.atan2(this.y, this.x);
        },
        /**
         * Get the angle from this point to another point, in radians
         * @param {Point} b the other point
         * @return {number} angle
         */
        angleTo(b) {
          return Math.atan2(this.y - b.y, this.x - b.x);
        },
        /**
         * Get the angle between this point and another point, in radians
         * @param {Point} b the other point
         * @return {number} angle
         */
        angleWith(b) {
          return this.angleWithSep(b.x, b.y);
        },
        /**
         * Find the angle of the two vectors, solving the formula for
         * the cross product a x b = |a||b|sin() for .
         * @param {number} x the x-coordinate
         * @param {number} y the y-coordinate
         * @return {number} the angle in radians
         */
        angleWithSep(x, y) {
          return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y
          );
        },
        /** @param {[number, number, number, number]} m */
        _matMult(m) {
          const x = m[0] * this.x + m[1] * this.y, y = m[2] * this.x + m[3] * this.y;
          this.x = x;
          this.y = y;
          return this;
        },
        /** @param {Point} p */
        _add(p) {
          this.x += p.x;
          this.y += p.y;
          return this;
        },
        /** @param {Point} p */
        _sub(p) {
          this.x -= p.x;
          this.y -= p.y;
          return this;
        },
        /** @param {number} k */
        _mult(k) {
          this.x *= k;
          this.y *= k;
          return this;
        },
        /** @param {number} k */
        _div(k) {
          this.x /= k;
          this.y /= k;
          return this;
        },
        /** @param {Point} p */
        _multByPoint(p) {
          this.x *= p.x;
          this.y *= p.y;
          return this;
        },
        /** @param {Point} p */
        _divByPoint(p) {
          this.x /= p.x;
          this.y /= p.y;
          return this;
        },
        _unit() {
          this._div(this.mag());
          return this;
        },
        _perp() {
          const y = this.y;
          this.y = this.x;
          this.x = -y;
          return this;
        },
        /** @param {number} angle */
        _rotate(angle) {
          const cos = Math.cos(angle), sin = Math.sin(angle), x = cos * this.x - sin * this.y, y = sin * this.x + cos * this.y;
          this.x = x;
          this.y = y;
          return this;
        },
        /**
         * @param {number} angle
         * @param {Point} p
         */
        _rotateAround(angle, p) {
          const cos = Math.cos(angle), sin = Math.sin(angle), x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y), y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);
          this.x = x;
          this.y = y;
          return this;
        },
        _round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        },
        constructor: Point
      };
      Point.convert = function(p) {
        if (p instanceof Point) {
          return (
            /** @type {Point} */
            p
          );
        }
        if (Array.isArray(p)) {
          return new Point(+p[0], +p[1]);
        }
        if (p.x !== void 0 && p.y !== void 0) {
          return new Point(+p.x, +p.y);
        }
        throw new Error("Expected [x, y] or {x, y} point format");
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/array_types.js
  var require_array_types = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/array_types.js"(exports, module) {
      var assert = require_nanoassert();
      var { Struct, StructArray } = require_struct_array();
      var { register } = require_transfer_registry();
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      var StructArrayLayout2i4 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1) {
          const i = this.length;
          this.resize(i + 1);
          const o2 = i * 2;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          return i;
        }
        emplace(i, v0, v1) {
          const o2 = i * 2;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          return i;
        }
      };
      StructArrayLayout2i4.prototype.bytesPerElement = 4;
      register("StructArrayLayout2i4", StructArrayLayout2i4);
      var StructArrayLayout4i8 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1, v2, v3) {
          const i = this.length;
          this.resize(i + 1);
          const o2 = i * 4;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          this.int16[o2 + 3] = v3;
          return i;
        }
        emplace(i, v0, v1, v2, v3) {
          const o2 = i * 4;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          this.int16[o2 + 3] = v3;
          return i;
        }
      };
      StructArrayLayout4i8.prototype.bytesPerElement = 8;
      register("StructArrayLayout4i8", StructArrayLayout4i8);
      var StructArrayLayout2i4i12 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1, v2, v3, v4, v5) {
          const i = this.length;
          this.resize(i + 1);
          const o2 = i * 6;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          this.int16[o2 + 3] = v3;
          this.int16[o2 + 4] = v4;
          this.int16[o2 + 5] = v5;
          return i;
        }
        emplace(i, v0, v1, v2, v3, v4, v5) {
          const o2 = i * 6;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          this.int16[o2 + 3] = v3;
          this.int16[o2 + 4] = v4;
          this.int16[o2 + 5] = v5;
          return i;
        }
      };
      StructArrayLayout2i4i12.prototype.bytesPerElement = 12;
      register("StructArrayLayout2i4i12", StructArrayLayout2i4i12);
      var StructArrayLayout4i4ub12 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7) {
          const i = this.length;
          this.resize(i + 1);
          const o2 = i * 6;
          const o1 = i * 12;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          this.int16[o2 + 3] = v3;
          this.uint8[o1 + 8] = v4;
          this.uint8[o1 + 9] = v5;
          this.uint8[o1 + 10] = v6;
          this.uint8[o1 + 11] = v7;
          return i;
        }
        emplace(i, v0, v1, v2, v3, v4, v5, v6, v7) {
          const o2 = i * 6;
          const o1 = i * 12;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          this.int16[o2 + 3] = v3;
          this.uint8[o1 + 8] = v4;
          this.uint8[o1 + 9] = v5;
          this.uint8[o1 + 10] = v6;
          this.uint8[o1 + 11] = v7;
          return i;
        }
      };
      StructArrayLayout4i4ub12.prototype.bytesPerElement = 12;
      register("StructArrayLayout4i4ub12", StructArrayLayout4i4ub12);
      var StructArrayLayout8ui16 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7) {
          const i = this.length;
          this.resize(i + 1);
          const o2 = i * 8;
          this.uint16[o2 + 0] = v0;
          this.uint16[o2 + 1] = v1;
          this.uint16[o2 + 2] = v2;
          this.uint16[o2 + 3] = v3;
          this.uint16[o2 + 4] = v4;
          this.uint16[o2 + 5] = v5;
          this.uint16[o2 + 6] = v6;
          this.uint16[o2 + 7] = v7;
          return i;
        }
        emplace(i, v0, v1, v2, v3, v4, v5, v6, v7) {
          const o2 = i * 8;
          this.uint16[o2 + 0] = v0;
          this.uint16[o2 + 1] = v1;
          this.uint16[o2 + 2] = v2;
          this.uint16[o2 + 3] = v3;
          this.uint16[o2 + 4] = v4;
          this.uint16[o2 + 5] = v5;
          this.uint16[o2 + 6] = v6;
          this.uint16[o2 + 7] = v7;
          return i;
        }
      };
      StructArrayLayout8ui16.prototype.bytesPerElement = 16;
      register("StructArrayLayout8ui16", StructArrayLayout8ui16);
      var StructArrayLayout4i4ui16 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.int16 = new Int16Array(this.arrayBuffer);
          this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7) {
          const i = this.length;
          this.resize(i + 1);
          const o2 = i * 8;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          this.int16[o2 + 3] = v3;
          this.uint16[o2 + 4] = v4;
          this.uint16[o2 + 5] = v5;
          this.uint16[o2 + 6] = v6;
          this.uint16[o2 + 7] = v7;
          return i;
        }
        emplace(i, v0, v1, v2, v3, v4, v5, v6, v7) {
          const o2 = i * 8;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          this.int16[o2 + 3] = v3;
          this.uint16[o2 + 4] = v4;
          this.uint16[o2 + 5] = v5;
          this.uint16[o2 + 6] = v6;
          this.uint16[o2 + 7] = v7;
          return i;
        }
      };
      StructArrayLayout4i4ui16.prototype.bytesPerElement = 16;
      register("StructArrayLayout4i4ui16", StructArrayLayout4i4ui16);
      var StructArrayLayout3f12 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1, v2) {
          const i = this.length;
          this.resize(i + 1);
          const o4 = i * 3;
          this.float32[o4 + 0] = v0;
          this.float32[o4 + 1] = v1;
          this.float32[o4 + 2] = v2;
          return i;
        }
        emplace(i, v0, v1, v2) {
          const o4 = i * 3;
          this.float32[o4 + 0] = v0;
          this.float32[o4 + 1] = v1;
          this.float32[o4 + 2] = v2;
          return i;
        }
      };
      StructArrayLayout3f12.prototype.bytesPerElement = 12;
      register("StructArrayLayout3f12", StructArrayLayout3f12);
      var StructArrayLayout1ul4 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(v0) {
          const i = this.length;
          this.resize(i + 1);
          const o4 = i * 1;
          this.uint32[o4 + 0] = v0;
          return i;
        }
        emplace(i, v0) {
          const o4 = i * 1;
          this.uint32[o4 + 0] = v0;
          return i;
        }
      };
      StructArrayLayout1ul4.prototype.bytesPerElement = 4;
      register("StructArrayLayout1ul4", StructArrayLayout1ul4);
      var StructArrayLayout6i1ul2ui2i24 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.int16 = new Int16Array(this.arrayBuffer);
          this.uint32 = new Uint32Array(this.arrayBuffer);
          this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) {
          const i = this.length;
          this.resize(i + 1);
          const o2 = i * 12;
          const o4 = i * 6;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          this.int16[o2 + 3] = v3;
          this.int16[o2 + 4] = v4;
          this.int16[o2 + 5] = v5;
          this.uint32[o4 + 3] = v6;
          this.uint16[o2 + 8] = v7;
          this.uint16[o2 + 9] = v8;
          this.int16[o2 + 10] = v9;
          this.int16[o2 + 11] = v10;
          return i;
        }
        emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) {
          const o2 = i * 12;
          const o4 = i * 6;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          this.int16[o2 + 3] = v3;
          this.int16[o2 + 4] = v4;
          this.int16[o2 + 5] = v5;
          this.uint32[o4 + 3] = v6;
          this.uint16[o2 + 8] = v7;
          this.uint16[o2 + 9] = v8;
          this.int16[o2 + 10] = v9;
          this.int16[o2 + 11] = v10;
          return i;
        }
      };
      StructArrayLayout6i1ul2ui2i24.prototype.bytesPerElement = 24;
      register("StructArrayLayout6i1ul2ui2i24", StructArrayLayout6i1ul2ui2i24);
      var StructArrayLayout2i2i2i12 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1, v2, v3, v4, v5) {
          const i = this.length;
          this.resize(i + 1);
          const o2 = i * 6;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          this.int16[o2 + 3] = v3;
          this.int16[o2 + 4] = v4;
          this.int16[o2 + 5] = v5;
          return i;
        }
        emplace(i, v0, v1, v2, v3, v4, v5) {
          const o2 = i * 6;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          this.int16[o2 + 3] = v3;
          this.int16[o2 + 4] = v4;
          this.int16[o2 + 5] = v5;
          return i;
        }
      };
      StructArrayLayout2i2i2i12.prototype.bytesPerElement = 12;
      register("StructArrayLayout2i2i2i12", StructArrayLayout2i2i2i12);
      var StructArrayLayout2ub4 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1) {
          const i = this.length;
          this.resize(i + 1);
          const o1 = i * 4;
          this.uint8[o1 + 0] = v0;
          this.uint8[o1 + 1] = v1;
          return i;
        }
        emplace(i, v0, v1) {
          const o1 = i * 4;
          this.uint8[o1 + 0] = v0;
          this.uint8[o1 + 1] = v1;
          return i;
        }
      };
      StructArrayLayout2ub4.prototype.bytesPerElement = 4;
      register("StructArrayLayout2ub4", StructArrayLayout2ub4);
      var StructArrayLayout2i2ui3ul3ui2f2ub40 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.int16 = new Int16Array(this.arrayBuffer);
          this.uint16 = new Uint16Array(this.arrayBuffer);
          this.uint32 = new Uint32Array(this.arrayBuffer);
          this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) {
          const i = this.length;
          this.resize(i + 1);
          const o2 = i * 20;
          const o4 = i * 10;
          const o1 = i * 40;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.uint16[o2 + 2] = v2;
          this.uint16[o2 + 3] = v3;
          this.uint32[o4 + 2] = v4;
          this.uint32[o4 + 3] = v5;
          this.uint32[o4 + 4] = v6;
          this.uint16[o2 + 10] = v7;
          this.uint16[o2 + 11] = v8;
          this.uint16[o2 + 12] = v9;
          this.float32[o4 + 7] = v10;
          this.float32[o4 + 8] = v11;
          this.uint8[o1 + 36] = v12;
          this.uint8[o1 + 37] = v13;
          return i;
        }
        emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) {
          const o2 = i * 20;
          const o4 = i * 10;
          const o1 = i * 40;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.uint16[o2 + 2] = v2;
          this.uint16[o2 + 3] = v3;
          this.uint32[o4 + 2] = v4;
          this.uint32[o4 + 3] = v5;
          this.uint32[o4 + 4] = v6;
          this.uint16[o2 + 10] = v7;
          this.uint16[o2 + 11] = v8;
          this.uint16[o2 + 12] = v9;
          this.float32[o4 + 7] = v10;
          this.float32[o4 + 8] = v11;
          this.uint8[o1 + 36] = v12;
          this.uint8[o1 + 37] = v13;
          return i;
        }
      };
      StructArrayLayout2i2ui3ul3ui2f2ub40.prototype.bytesPerElement = 40;
      register("StructArrayLayout2i2ui3ul3ui2f2ub40", StructArrayLayout2i2ui3ul3ui2f2ub40);
      var StructArrayLayout4i9ui1ul32 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.int16 = new Int16Array(this.arrayBuffer);
          this.uint16 = new Uint16Array(this.arrayBuffer);
          this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) {
          const i = this.length;
          this.resize(i + 1);
          const o2 = i * 16;
          const o4 = i * 8;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          this.int16[o2 + 3] = v3;
          this.uint16[o2 + 4] = v4;
          this.uint16[o2 + 5] = v5;
          this.uint16[o2 + 6] = v6;
          this.uint16[o2 + 7] = v7;
          this.uint16[o2 + 8] = v8;
          this.uint16[o2 + 9] = v9;
          this.uint16[o2 + 10] = v10;
          this.uint16[o2 + 11] = v11;
          this.uint16[o2 + 12] = v12;
          this.uint32[o4 + 7] = v13;
          return i;
        }
        emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) {
          const o2 = i * 16;
          const o4 = i * 8;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          this.int16[o2 + 3] = v3;
          this.uint16[o2 + 4] = v4;
          this.uint16[o2 + 5] = v5;
          this.uint16[o2 + 6] = v6;
          this.uint16[o2 + 7] = v7;
          this.uint16[o2 + 8] = v8;
          this.uint16[o2 + 9] = v9;
          this.uint16[o2 + 10] = v10;
          this.uint16[o2 + 11] = v11;
          this.uint16[o2 + 12] = v12;
          this.uint32[o4 + 7] = v13;
          return i;
        }
      };
      StructArrayLayout4i9ui1ul32.prototype.bytesPerElement = 32;
      register("StructArrayLayout4i9ui1ul32", StructArrayLayout4i9ui1ul32);
      var StructArrayLayout1f4 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(v0) {
          const i = this.length;
          this.resize(i + 1);
          const o4 = i * 1;
          this.float32[o4 + 0] = v0;
          return i;
        }
        emplace(i, v0) {
          const o4 = i * 1;
          this.float32[o4 + 0] = v0;
          return i;
        }
      };
      StructArrayLayout1f4.prototype.bytesPerElement = 4;
      register("StructArrayLayout1f4", StructArrayLayout1f4);
      var StructArrayLayout3i6 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1, v2) {
          const i = this.length;
          this.resize(i + 1);
          const o2 = i * 3;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          return i;
        }
        emplace(i, v0, v1, v2) {
          const o2 = i * 3;
          this.int16[o2 + 0] = v0;
          this.int16[o2 + 1] = v1;
          this.int16[o2 + 2] = v2;
          return i;
        }
      };
      StructArrayLayout3i6.prototype.bytesPerElement = 6;
      register("StructArrayLayout3i6", StructArrayLayout3i6);
      var StructArrayLayout1ul2ui8 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.uint32 = new Uint32Array(this.arrayBuffer);
          this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1, v2) {
          const i = this.length;
          this.resize(i + 1);
          const o4 = i * 2;
          const o2 = i * 4;
          this.uint32[o4 + 0] = v0;
          this.uint16[o2 + 2] = v1;
          this.uint16[o2 + 3] = v2;
          return i;
        }
        emplace(i, v0, v1, v2) {
          const o4 = i * 2;
          const o2 = i * 4;
          this.uint32[o4 + 0] = v0;
          this.uint16[o2 + 2] = v1;
          this.uint16[o2 + 3] = v2;
          return i;
        }
      };
      StructArrayLayout1ul2ui8.prototype.bytesPerElement = 8;
      register("StructArrayLayout1ul2ui8", StructArrayLayout1ul2ui8);
      var StructArrayLayout3ui6 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1, v2) {
          const i = this.length;
          this.resize(i + 1);
          const o2 = i * 3;
          this.uint16[o2 + 0] = v0;
          this.uint16[o2 + 1] = v1;
          this.uint16[o2 + 2] = v2;
          return i;
        }
        emplace(i, v0, v1, v2) {
          const o2 = i * 3;
          this.uint16[o2 + 0] = v0;
          this.uint16[o2 + 1] = v1;
          this.uint16[o2 + 2] = v2;
          return i;
        }
      };
      StructArrayLayout3ui6.prototype.bytesPerElement = 6;
      register("StructArrayLayout3ui6", StructArrayLayout3ui6);
      var StructArrayLayout2ui4 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1) {
          const i = this.length;
          this.resize(i + 1);
          const o2 = i * 2;
          this.uint16[o2 + 0] = v0;
          this.uint16[o2 + 1] = v1;
          return i;
        }
        emplace(i, v0, v1) {
          const o2 = i * 2;
          this.uint16[o2 + 0] = v0;
          this.uint16[o2 + 1] = v1;
          return i;
        }
      };
      StructArrayLayout2ui4.prototype.bytesPerElement = 4;
      register("StructArrayLayout2ui4", StructArrayLayout2ui4);
      var StructArrayLayout1ui2 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(v0) {
          const i = this.length;
          this.resize(i + 1);
          const o2 = i * 1;
          this.uint16[o2 + 0] = v0;
          return i;
        }
        emplace(i, v0) {
          const o2 = i * 1;
          this.uint16[o2 + 0] = v0;
          return i;
        }
      };
      StructArrayLayout1ui2.prototype.bytesPerElement = 2;
      register("StructArrayLayout1ui2", StructArrayLayout1ui2);
      var StructArrayLayout2f8 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1) {
          const i = this.length;
          this.resize(i + 1);
          const o4 = i * 2;
          this.float32[o4 + 0] = v0;
          this.float32[o4 + 1] = v1;
          return i;
        }
        emplace(i, v0, v1) {
          const o4 = i * 2;
          this.float32[o4 + 0] = v0;
          this.float32[o4 + 1] = v1;
          return i;
        }
      };
      StructArrayLayout2f8.prototype.bytesPerElement = 8;
      register("StructArrayLayout2f8", StructArrayLayout2f8);
      var StructArrayLayout4f16 = class extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
          this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(v0, v1, v2, v3) {
          const i = this.length;
          this.resize(i + 1);
          const o4 = i * 4;
          this.float32[o4 + 0] = v0;
          this.float32[o4 + 1] = v1;
          this.float32[o4 + 2] = v2;
          this.float32[o4 + 3] = v3;
          return i;
        }
        emplace(i, v0, v1, v2, v3) {
          const o4 = i * 4;
          this.float32[o4 + 0] = v0;
          this.float32[o4 + 1] = v1;
          this.float32[o4 + 2] = v2;
          this.float32[o4 + 3] = v3;
          return i;
        }
      };
      StructArrayLayout4f16.prototype.bytesPerElement = 16;
      register("StructArrayLayout4f16", StructArrayLayout4f16);
      var CollisionBoxStruct = class extends Struct {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        set anchorPointX(x) {
          this._structArray.int16[this._pos2 + 0] = x;
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        set anchorPointY(x) {
          this._structArray.int16[this._pos2 + 1] = x;
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        set x1(x) {
          this._structArray.int16[this._pos2 + 2] = x;
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        set y1(x) {
          this._structArray.int16[this._pos2 + 3] = x;
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        set x2(x) {
          this._structArray.int16[this._pos2 + 4] = x;
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        set y2(x) {
          this._structArray.int16[this._pos2 + 5] = x;
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        set featureIndex(x) {
          this._structArray.uint32[this._pos4 + 3] = x;
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        set sourceLayerIndex(x) {
          this._structArray.uint16[this._pos2 + 8] = x;
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        set bucketIndex(x) {
          this._structArray.uint16[this._pos2 + 9] = x;
        }
        get radius() {
          return this._structArray.int16[this._pos2 + 10];
        }
        set radius(x) {
          this._structArray.int16[this._pos2 + 10] = x;
        }
        get signedDistanceFromAnchor() {
          return this._structArray.int16[this._pos2 + 11];
        }
        set signedDistanceFromAnchor(x) {
          this._structArray.int16[this._pos2 + 11] = x;
        }
        get anchorPoint() {
          return new Point3(this.anchorPointX, this.anchorPointY);
        }
      };
      CollisionBoxStruct.prototype.size = 24;
      var CollisionBoxArray = class extends StructArrayLayout6i1ul2ui2i24 {
        /**
         * Return the CollisionBoxStruct at the given location in the array.
         * @param {number} index The index of the element.
         */
        get(index) {
          assert(!this.isTransferred);
          return new CollisionBoxStruct(this, index);
        }
      };
      register("CollisionBoxArray", CollisionBoxArray);
      var PlacedSymbolStruct = class extends Struct {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        set anchorX(x) {
          this._structArray.int16[this._pos2 + 0] = x;
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        set anchorY(x) {
          this._structArray.int16[this._pos2 + 1] = x;
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        set glyphStartIndex(x) {
          this._structArray.uint16[this._pos2 + 2] = x;
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        set numGlyphs(x) {
          this._structArray.uint16[this._pos2 + 3] = x;
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        set vertexStartIndex(x) {
          this._structArray.uint32[this._pos4 + 2] = x;
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        set lineStartIndex(x) {
          this._structArray.uint32[this._pos4 + 3] = x;
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        set lineLength(x) {
          this._structArray.uint32[this._pos4 + 4] = x;
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        set segment(x) {
          this._structArray.uint16[this._pos2 + 10] = x;
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        set lowerSize(x) {
          this._structArray.uint16[this._pos2 + 11] = x;
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        set upperSize(x) {
          this._structArray.uint16[this._pos2 + 12] = x;
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        set lineOffsetX(x) {
          this._structArray.float32[this._pos4 + 7] = x;
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        set lineOffsetY(x) {
          this._structArray.float32[this._pos4 + 8] = x;
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        set writingMode(x) {
          this._structArray.uint8[this._pos1 + 36] = x;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set hidden(x) {
          this._structArray.uint8[this._pos1 + 37] = x;
        }
      };
      PlacedSymbolStruct.prototype.size = 40;
      var PlacedSymbolArray = class extends StructArrayLayout2i2ui3ul3ui2f2ub40 {
        /**
         * Return the PlacedSymbolStruct at the given location in the array.
         * @param {number} index The index of the element.
         */
        get(index) {
          assert(!this.isTransferred);
          return new PlacedSymbolStruct(this, index);
        }
      };
      register("PlacedSymbolArray", PlacedSymbolArray);
      var SymbolInstanceStruct = class extends Struct {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        set anchorX(x) {
          this._structArray.int16[this._pos2 + 0] = x;
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        set anchorY(x) {
          this._structArray.int16[this._pos2 + 1] = x;
        }
        get horizontalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        set horizontalPlacedTextSymbolIndex(x) {
          this._structArray.int16[this._pos2 + 2] = x;
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        set verticalPlacedTextSymbolIndex(x) {
          this._structArray.int16[this._pos2 + 3] = x;
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 4];
        }
        set key(x) {
          this._structArray.uint16[this._pos2 + 4] = x;
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 5];
        }
        set textBoxStartIndex(x) {
          this._structArray.uint16[this._pos2 + 5] = x;
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 6];
        }
        set textBoxEndIndex(x) {
          this._structArray.uint16[this._pos2 + 6] = x;
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 7];
        }
        set iconBoxStartIndex(x) {
          this._structArray.uint16[this._pos2 + 7] = x;
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        set iconBoxEndIndex(x) {
          this._structArray.uint16[this._pos2 + 8] = x;
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        set featureIndex(x) {
          this._structArray.uint16[this._pos2 + 9] = x;
        }
        get numGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        set numGlyphVertices(x) {
          this._structArray.uint16[this._pos2 + 10] = x;
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        set numVerticalGlyphVertices(x) {
          this._structArray.uint16[this._pos2 + 11] = x;
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        set numIconVertices(x) {
          this._structArray.uint16[this._pos2 + 12] = x;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 7];
        }
        set crossTileID(x) {
          this._structArray.uint32[this._pos4 + 7] = x;
        }
      };
      SymbolInstanceStruct.prototype.size = 32;
      var SymbolInstanceArray = class extends StructArrayLayout4i9ui1ul32 {
        /**
         * Return the SymbolInstanceStruct at the given location in the array.
         * @param {number} index The index of the element.
         */
        get(index) {
          assert(!this.isTransferred);
          return new SymbolInstanceStruct(this, index);
        }
      };
      register("SymbolInstanceArray", SymbolInstanceArray);
      var GlyphOffsetStruct = class extends Struct {
        get offsetX() {
          return this._structArray.float32[this._pos4 + 0];
        }
        set offsetX(x) {
          this._structArray.float32[this._pos4 + 0] = x;
        }
      };
      GlyphOffsetStruct.prototype.size = 4;
      var GlyphOffsetArray = class extends StructArrayLayout1f4 {
        getoffsetX(index) {
          return this.float32[index * 1 + 0];
        }
        /**
         * Return the GlyphOffsetStruct at the given location in the array.
         * @param {number} index The index of the element.
         */
        get(index) {
          assert(!this.isTransferred);
          return new GlyphOffsetStruct(this, index);
        }
      };
      register("GlyphOffsetArray", GlyphOffsetArray);
      var SymbolLineVertexStruct = class extends Struct {
        get x() {
          return this._structArray.int16[this._pos2 + 0];
        }
        set x(x) {
          this._structArray.int16[this._pos2 + 0] = x;
        }
        get y() {
          return this._structArray.int16[this._pos2 + 1];
        }
        set y(x) {
          this._structArray.int16[this._pos2 + 1] = x;
        }
        get tileUnitDistanceFromAnchor() {
          return this._structArray.int16[this._pos2 + 2];
        }
        set tileUnitDistanceFromAnchor(x) {
          this._structArray.int16[this._pos2 + 2] = x;
        }
      };
      SymbolLineVertexStruct.prototype.size = 6;
      var SymbolLineVertexArray = class extends StructArrayLayout3i6 {
        getx(index) {
          return this.int16[index * 3 + 0];
        }
        gety(index) {
          return this.int16[index * 3 + 1];
        }
        gettileUnitDistanceFromAnchor(index) {
          return this.int16[index * 3 + 2];
        }
        /**
         * Return the SymbolLineVertexStruct at the given location in the array.
         * @param {number} index The index of the element.
         */
        get(index) {
          assert(!this.isTransferred);
          return new SymbolLineVertexStruct(this, index);
        }
      };
      register("SymbolLineVertexArray", SymbolLineVertexArray);
      var FeatureIndexStruct = class extends Struct {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        set featureIndex(x) {
          this._structArray.uint32[this._pos4 + 0] = x;
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        set sourceLayerIndex(x) {
          this._structArray.uint16[this._pos2 + 2] = x;
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        set bucketIndex(x) {
          this._structArray.uint16[this._pos2 + 3] = x;
        }
      };
      FeatureIndexStruct.prototype.size = 8;
      var FeatureIndexArray = class extends StructArrayLayout1ul2ui8 {
        /**
         * Return the FeatureIndexStruct at the given location in the array.
         * @param {number} index The index of the element.
         */
        get(index) {
          assert(!this.isTransferred);
          return new FeatureIndexStruct(this, index);
        }
      };
      register("FeatureIndexArray", FeatureIndexArray);
      module.exports = {
        StructArrayLayout2i4,
        StructArrayLayout4i8,
        StructArrayLayout2i4i12,
        StructArrayLayout4i4ub12,
        StructArrayLayout8ui16,
        StructArrayLayout4i4ui16,
        StructArrayLayout3f12,
        StructArrayLayout1ul4,
        StructArrayLayout6i1ul2ui2i24,
        StructArrayLayout2i2i2i12,
        StructArrayLayout2ub4,
        StructArrayLayout2i2ui3ul3ui2f2ub40,
        StructArrayLayout4i9ui1ul32,
        StructArrayLayout1f4,
        StructArrayLayout3i6,
        StructArrayLayout1ul2ui8,
        StructArrayLayout3ui6,
        StructArrayLayout2ui4,
        StructArrayLayout1ui2,
        StructArrayLayout2f8,
        StructArrayLayout4f16,
        PosArray: StructArrayLayout2i4,
        RasterBoundsArray: StructArrayLayout4i8,
        CircleLayoutArray: StructArrayLayout2i4,
        FillLayoutArray: StructArrayLayout2i4,
        FillExtrusionLayoutArray: StructArrayLayout2i4i12,
        HeatmapLayoutArray: StructArrayLayout2i4,
        LineLayoutArray: StructArrayLayout4i4ub12,
        PatternLayoutArray: StructArrayLayout8ui16,
        SymbolLayoutArray: StructArrayLayout4i4ui16,
        SymbolDynamicLayoutArray: StructArrayLayout3f12,
        SymbolOpacityArray: StructArrayLayout1ul4,
        CollisionBoxLayoutArray: StructArrayLayout2i2i2i12,
        CollisionCircleLayoutArray: StructArrayLayout2i2i2i12,
        CollisionVertexArray: StructArrayLayout2ub4,
        TriangleIndexArray: StructArrayLayout3ui6,
        LineIndexArray: StructArrayLayout2ui4,
        LineStripIndexArray: StructArrayLayout1ui2,
        CollisionBoxArray,
        FeatureIndexArray,
        GlyphOffsetArray,
        PlacedSymbolArray,
        SymbolInstanceArray,
        SymbolLineVertexArray
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/bucket/circle_attributes.js
  var require_circle_attributes = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/bucket/circle_attributes.js"(exports, module) {
      var { createLayout } = require_struct_array();
      var layout = createLayout([{ name: "a_pos", components: 2, type: "Int16" }], 4);
      module.exports = layout;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/segment.js
  var require_segment = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/segment.js"(exports, module) {
      var warn = require_warn();
      var { register } = require_transfer_registry();
      var SegmentVector = class _SegmentVector {
        constructor(segments = []) {
          this.segments = segments;
        }
        prepareSegment(numVertices, layoutVertexArray, indexArray) {
          if (numVertices > _SegmentVector.MAX_VERTEX_ARRAY_LENGTH)
            warn.once(
              `Max vertices per segment is ${_SegmentVector.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${numVertices}`
            );
          let segment = this.segments.at(-1);
          if (!segment || segment.vertexLength + numVertices > _SegmentVector.MAX_VERTEX_ARRAY_LENGTH) {
            segment = {
              vertexOffset: layoutVertexArray.length,
              primitiveOffset: indexArray.length,
              vertexLength: 0,
              primitiveLength: 0
            };
            this.segments.push(segment);
          }
          return segment;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const segment of this.segments) {
            for (const k in segment.vaos) {
              segment.vaos[k].destroy();
            }
          }
        }
        static simpleSegment(vertexOffset, primitiveOffset, vertexLength, primitiveLength) {
          return new _SegmentVector([
            {
              vertexOffset,
              primitiveOffset,
              vertexLength,
              primitiveLength,
              vaos: {}
            }
          ]);
        }
      };
      SegmentVector.MAX_VERTEX_ARRAY_LENGTH = 2 ** 16 - 1;
      register("SegmentVector", SegmentVector);
      module.exports = SegmentVector;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/shaders/encode_attribute.js
  var require_encode_attribute = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/shaders/encode_attribute.js"(exports, module) {
      var { clamp } = require_util();
      function pack(a, b) {
        a = clamp(Math.floor(a), 0, 255);
        b = clamp(Math.floor(b), 0, 255);
        return 256 * a + b;
      }
      module.exports = {
        packUint8ToFloat: pack
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/uniform_binding.js
  var require_uniform_binding = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/uniform_binding.js"(exports, module) {
      var { Color } = require_style_expressions();
      var Uniform = class {
        constructor(context, location) {
          this.gl = context.gl;
          this.location = location;
        }
      };
      var Uniform1i = class extends Uniform {
        constructor(context, location) {
          super(context, location);
          this.current = 0;
        }
        set(v) {
          if (this.current !== v) {
            this.current = v;
            this.gl.uniform1i(this.location, v);
          }
        }
      };
      var Uniform1f = class extends Uniform {
        constructor(context, location) {
          super(context, location);
          this.current = 0;
        }
        set(v) {
          if (this.current !== v) {
            this.current = v;
            this.gl.uniform1f(this.location, v);
          }
        }
      };
      var Uniform2f = class extends Uniform {
        constructor(context, location) {
          super(context, location);
          this.current = [0, 0];
        }
        set(v) {
          if (v[0] !== this.current[0] || v[1] !== this.current[1]) {
            this.current = v;
            this.gl.uniform2f(this.location, v[0], v[1]);
          }
        }
      };
      var Uniform3f = class extends Uniform {
        constructor(context, location) {
          super(context, location);
          this.current = [0, 0, 0];
        }
        set(v) {
          if (v[0] !== this.current[0] || v[1] !== this.current[1] || v[2] !== this.current[2]) {
            this.current = v;
            this.gl.uniform3f(this.location, v[0], v[1], v[2]);
          }
        }
      };
      var Uniform4f = class extends Uniform {
        constructor(context, location) {
          super(context, location);
          this.current = [0, 0, 0, 0];
        }
        set(v) {
          if (v[0] !== this.current[0] || v[1] !== this.current[1] || v[2] !== this.current[2] || v[3] !== this.current[3]) {
            this.current = v;
            this.gl.uniform4f(this.location, v[0], v[1], v[2], v[3]);
          }
        }
      };
      var UniformColor = class extends Uniform {
        constructor(context, location) {
          super(context, location);
          this.current = Color.transparent;
        }
        set(v) {
          if (v.r !== this.current.r || v.g !== this.current.g || v.b !== this.current.b || v.a !== this.current.a) {
            this.current = v;
            this.gl.uniform4f(this.location, v.r, v.g, v.b, v.a);
          }
        }
      };
      var emptyMat4 = new Float32Array(16);
      var UniformMatrix4f = class extends Uniform {
        constructor(context, location) {
          super(context, location);
          this.current = emptyMat4;
        }
        set(v) {
          if (v[12] !== this.current[12] || v[0] !== this.current[0]) {
            this.current = v;
            this.gl.uniformMatrix4fv(this.location, false, v);
            return;
          }
          for (let i = 1; i < 16; i++) {
            if (v[i] !== this.current[i]) {
              this.current = v;
              this.gl.uniformMatrix4fv(this.location, false, v);
              break;
            }
          }
        }
      };
      module.exports = {
        Uniform,
        Uniform1i,
        Uniform1f,
        Uniform2f,
        Uniform3f,
        Uniform4f,
        UniformColor,
        UniformMatrix4f
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/program_configuration.js
  var require_program_configuration = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/program_configuration.js"(exports, module) {
      var { packUint8ToFloat } = require_encode_attribute();
      var { supportsPropertyExpression } = require_style_expressions();
      var { register } = require_transfer_registry();
      var { PossiblyEvaluatedPropertyValue } = require_properties2();
      var {
        StructArrayLayout1f4,
        StructArrayLayout2f8,
        StructArrayLayout4f16,
        PatternLayoutArray
      } = require_array_types();
      var EvaluationParameters = require_evaluation_parameters();
      var { Uniform1f, UniformColor, Uniform4f } = require_uniform_binding();
      function packColor(color) {
        return [packUint8ToFloat(255 * color.r, 255 * color.g), packUint8ToFloat(255 * color.b, 255 * color.a)];
      }
      var ConstantBinder = class {
        constructor(value, names, type) {
          this.value = value;
          this.names = names;
          this.uniformNames = this.names.map((name) => `u_${name}`);
          this.type = type;
          this.maxValue = Number.NEGATIVE_INFINITY;
        }
        defines() {
          return this.names.map((name) => `#define HAS_UNIFORM_u_${name}`);
        }
        setConstantPatternPositions() {
        }
        populatePaintArray() {
        }
        updatePaintArray() {
        }
        upload() {
        }
        destroy() {
        }
        setUniforms(context, uniform, globals, currentValue) {
          uniform.set(currentValue.constantOr(this.value));
        }
        getBinding(context, location) {
          return this.type === "color" ? new UniformColor(context, location) : new Uniform1f(context, location);
        }
      };
      var CrossFadedConstantBinder = class {
        constructor(value, names, type) {
          this.value = value;
          this.names = names;
          this.uniformNames = this.names.map((name) => `u_${name}`);
          this.type = type;
          this.maxValue = Number.NEGATIVE_INFINITY;
          this.patternPositions = { patternTo: null, patternFrom: null };
        }
        defines() {
          return this.names.map((name) => `#define HAS_UNIFORM_u_${name}`);
        }
        populatePaintArray() {
        }
        updatePaintArray() {
        }
        upload() {
        }
        destroy() {
        }
        setConstantPatternPositions(posTo, posFrom) {
          this.patternPositions.patternTo = posTo.tlbr;
          this.patternPositions.patternFrom = posFrom.tlbr;
        }
        setUniforms(context, uniform, globals, currentValue, uniformName) {
          const pos = this.patternPositions;
          if (uniformName === "u_pattern_to" && pos.patternTo) uniform.set(pos.patternTo);
          if (uniformName === "u_pattern_from" && pos.patternFrom) uniform.set(pos.patternFrom);
        }
        getBinding(context, location) {
          return new Uniform4f(context, location);
        }
      };
      var SourceExpressionBinder = class {
        constructor(expression, names, type, PaintVertexArray) {
          this.expression = expression;
          this.names = names;
          this.type = type;
          this.uniformNames = this.names.map((name) => `a_${name}`);
          this.maxValue = Number.NEGATIVE_INFINITY;
          this.paintVertexAttributes = names.map((name) => ({
            name: `a_${name}`,
            type: "Float32",
            components: type === "color" ? 2 : 1,
            offset: 0
          }));
          this.paintVertexArray = new PaintVertexArray();
        }
        defines() {
          return [];
        }
        setConstantPatternPositions() {
        }
        populatePaintArray(newLength, feature, imagePositions) {
          const paintArray = this.paintVertexArray;
          const start = paintArray.length;
          paintArray.reserve(newLength);
          const value = this.expression.evaluate(new EvaluationParameters(0), feature, {});
          if (this.type === "color") {
            const color = packColor(value);
            for (let i = start; i < newLength; i++) {
              paintArray.emplaceBack(color[0], color[1]);
            }
          } else {
            for (let i = start; i < newLength; i++) {
              paintArray.emplaceBack(value);
            }
            this.maxValue = Math.max(this.maxValue, value);
          }
        }
        updatePaintArray(start, end, feature, featureState, imagePositions) {
          const paintArray = this.paintVertexArray;
          const value = this.expression.evaluate({ zoom: 0 }, feature, featureState);
          if (this.type === "color") {
            const color = packColor(value);
            for (let i = start; i < end; i++) {
              paintArray.emplace(i, color[0], color[1]);
            }
          } else {
            for (let i = start; i < end; i++) {
              paintArray.emplace(i, value);
            }
            this.maxValue = Math.max(this.maxValue, value);
          }
        }
        upload(context) {
          if (this.paintVertexArray?.arrayBuffer) {
            if (this.paintVertexBuffer?.buffer) {
              this.paintVertexBuffer.updateData(this.paintVertexArray);
            } else {
              this.paintVertexBuffer = context.createVertexBuffer(
                this.paintVertexArray,
                this.paintVertexAttributes,
                this.expression.isStateDependent
              );
            }
          }
        }
        destroy() {
          if (this.paintVertexBuffer) {
            this.paintVertexBuffer.destroy();
          }
        }
        setUniforms(context, uniform) {
          uniform.set(0);
        }
        getBinding(context, location) {
          return new Uniform1f(context, location);
        }
      };
      var CompositeExpressionBinder = class {
        constructor(expression, names, type, useIntegerZoom, zoom, layout) {
          this.expression = expression;
          this.names = names;
          this.uniformNames = this.names.map((name) => `a_${name}_t`);
          this.type = type;
          this.useIntegerZoom = useIntegerZoom;
          this.zoom = zoom;
          this.maxValue = Number.NEGATIVE_INFINITY;
          const PaintVertexArray = layout;
          this.paintVertexAttributes = names.map((name) => {
            return {
              name: `a_${name}`,
              type: "Float32",
              components: type === "color" ? 4 : 2,
              offset: 0
            };
          });
          this.paintVertexArray = new PaintVertexArray();
        }
        defines() {
          return [];
        }
        setConstantPatternPositions() {
        }
        populatePaintArray(newLength, feature) {
          const paintArray = this.paintVertexArray;
          const start = paintArray.length;
          paintArray.reserve(newLength);
          const min = this.expression.evaluate(new EvaluationParameters(this.zoom), feature, {});
          const max = this.expression.evaluate(new EvaluationParameters(this.zoom + 1), feature, {});
          if (this.type === "color") {
            const minColor = packColor(min);
            const maxColor = packColor(max);
            for (let i = start; i < newLength; i++) {
              paintArray.emplaceBack(minColor[0], minColor[1], maxColor[0], maxColor[1]);
            }
          } else {
            for (let i = start; i < newLength; i++) {
              paintArray.emplaceBack(min, max);
            }
            this.maxValue = Math.max(this.maxValue, min, max);
          }
        }
        updatePaintArray(start, end, feature, featureState) {
          const paintArray = this.paintVertexArray;
          const min = this.expression.evaluate({ zoom: this.zoom }, feature, featureState);
          const max = this.expression.evaluate({ zoom: this.zoom + 1 }, feature, featureState);
          if (this.type === "color") {
            const minColor = packColor(min);
            const maxColor = packColor(max);
            for (let i = start; i < end; i++) {
              paintArray.emplace(i, minColor[0], minColor[1], maxColor[0], maxColor[1]);
            }
          } else {
            for (let i = start; i < end; i++) {
              paintArray.emplace(i, min, max);
            }
            this.maxValue = Math.max(this.maxValue, min, max);
          }
        }
        upload(context) {
          if (this.paintVertexArray?.arrayBuffer) {
            if (this.paintVertexBuffer?.buffer) {
              this.paintVertexBuffer.updateData(this.paintVertexArray);
            } else {
              this.paintVertexBuffer = context.createVertexBuffer(
                this.paintVertexArray,
                this.paintVertexAttributes,
                this.expression.isStateDependent
              );
            }
          }
        }
        destroy() {
          if (this.paintVertexBuffer) {
            this.paintVertexBuffer.destroy();
          }
        }
        interpolationFactor(currentZoom) {
          if (this.useIntegerZoom) {
            return this.expression.interpolationFactor(Math.floor(currentZoom), this.zoom, this.zoom + 1);
          }
          return this.expression.interpolationFactor(currentZoom, this.zoom, this.zoom + 1);
        }
        setUniforms(context, uniform, globals) {
          uniform.set(this.interpolationFactor(globals.zoom));
        }
        getBinding(context, location) {
          return new Uniform1f(context, location);
        }
      };
      var CrossFadedCompositeBinder = class {
        constructor(expression, names, type, useIntegerZoom, zoom, PaintVertexArray, layerId) {
          this.expression = expression;
          this.names = names;
          this.type = type;
          this.uniformNames = this.names.map((name) => `a_${name}_t`);
          this.useIntegerZoom = useIntegerZoom;
          this.zoom = zoom;
          this.maxValue = Number.NEGATIVE_INFINITY;
          this.layerId = layerId;
          this.paintVertexAttributes = names.map((name) => ({
            name: `a_${name}`,
            type: "Uint16",
            components: 4,
            offset: 0
          }));
          this.zoomInPaintVertexArray = new PaintVertexArray();
          this.zoomOutPaintVertexArray = new PaintVertexArray();
        }
        defines() {
          return [];
        }
        setConstantPatternPositions() {
        }
        populatePaintArray(length, feature, imagePositions) {
          const zoomInArray = this.zoomInPaintVertexArray;
          const zoomOutArray = this.zoomOutPaintVertexArray;
          const { layerId } = this;
          const start = zoomInArray.length;
          zoomInArray.reserve(length);
          zoomOutArray.reserve(length);
          if (imagePositions && feature.patterns && feature.patterns[layerId]) {
            const { min, mid, max } = feature.patterns[layerId];
            const imageMin = imagePositions[min];
            const imageMid = imagePositions[mid];
            const imageMax = imagePositions[max];
            if (!imageMin || !imageMid || !imageMax) return;
            for (let i = start; i < length; i++) {
              zoomInArray.emplaceBack(
                imageMid.tl[0],
                imageMid.tl[1],
                imageMid.br[0],
                imageMid.br[1],
                imageMin.tl[0],
                imageMin.tl[1],
                imageMin.br[0],
                imageMin.br[1]
              );
              zoomOutArray.emplaceBack(
                imageMid.tl[0],
                imageMid.tl[1],
                imageMid.br[0],
                imageMid.br[1],
                imageMax.tl[0],
                imageMax.tl[1],
                imageMax.br[0],
                imageMax.br[1]
              );
            }
          }
        }
        updatePaintArray(start, end, feature, featureState, imagePositions) {
          const zoomInArray = this.zoomInPaintVertexArray;
          const zoomOutArray = this.zoomOutPaintVertexArray;
          const { layerId } = this;
          if (imagePositions && feature.patterns && feature.patterns[layerId]) {
            const { min, mid, max } = feature.patterns[layerId];
            const imageMin = imagePositions[min];
            const imageMid = imagePositions[mid];
            const imageMax = imagePositions[max];
            if (!imageMin || !imageMid || !imageMax) return;
            for (let i = start; i < end; i++) {
              zoomInArray.emplace(
                i,
                imageMid.tl[0],
                imageMid.tl[1],
                imageMid.br[0],
                imageMid.br[1],
                imageMin.tl[0],
                imageMin.tl[1],
                imageMin.br[0],
                imageMin.br[1]
              );
              zoomOutArray.emplace(
                i,
                imageMid.tl[0],
                imageMid.tl[1],
                imageMid.br[0],
                imageMid.br[1],
                imageMax.tl[0],
                imageMax.tl[1],
                imageMax.br[0],
                imageMax.br[1]
              );
            }
          }
        }
        upload(context) {
          if (this.zoomInPaintVertexArray?.arrayBuffer && this.zoomOutPaintVertexArray?.arrayBuffer) {
            this.zoomInPaintVertexBuffer = context.createVertexBuffer(
              this.zoomInPaintVertexArray,
              this.paintVertexAttributes,
              this.expression.isStateDependent
            );
            this.zoomOutPaintVertexBuffer = context.createVertexBuffer(
              this.zoomOutPaintVertexArray,
              this.paintVertexAttributes,
              this.expression.isStateDependent
            );
          }
        }
        destroy() {
          if (this.zoomOutPaintVertexBuffer) this.zoomOutPaintVertexBuffer.destroy();
          if (this.zoomInPaintVertexBuffer) this.zoomInPaintVertexBuffer.destroy();
        }
        setUniforms(context, uniform) {
          uniform.set(0);
        }
        getBinding(context, location) {
          return new Uniform1f(context, location);
        }
      };
      var ProgramConfiguration = class _ProgramConfiguration {
        constructor() {
          this.binders = {};
          this.cacheKey = "";
          this._buffers = [];
          this._idMap = {};
          this._bufferOffset = 0;
        }
        static createDynamic(layer, zoom, filterProperties) {
          const self2 = new _ProgramConfiguration();
          const keys = [];
          for (const property in layer.paint._values) {
            if (!filterProperties(property)) continue;
            const value = layer.paint.get(property);
            if (!(value instanceof PossiblyEvaluatedPropertyValue) || !supportsPropertyExpression(value.property.specification)) {
              continue;
            }
            const names = paintAttributeNames(property, layer.type);
            const type = value.property.specification.type;
            const useIntegerZoom = value.property.useIntegerZoom;
            const isCrossFaded = value.property.specification["property-type"] === "cross-faded" || value.property.specification["property-type"] === "cross-faded-data-driven";
            if (isCrossFaded) {
              if (value.value.kind === "constant") {
                self2.binders[property] = new CrossFadedConstantBinder(value.value.value, names, type);
                keys.push(`/u_${property}`);
              } else {
                const StructArrayLayout = layoutType(property, type, "source");
                self2.binders[property] = new CrossFadedCompositeBinder(
                  value.value,
                  names,
                  type,
                  useIntegerZoom,
                  zoom,
                  StructArrayLayout,
                  layer.id
                );
                keys.push(`/a_${property}`);
              }
            } else if (value.value.kind === "constant") {
              self2.binders[property] = new ConstantBinder(value.value.value, names, type);
              keys.push(`/u_${property}`);
            } else if (value.value.kind === "source") {
              const StructArrayLayout = layoutType(property, type, "source");
              self2.binders[property] = new SourceExpressionBinder(value.value, names, type, StructArrayLayout);
              keys.push(`/a_${property}`);
            } else {
              const StructArrayLayout = layoutType(property, type, "composite");
              self2.binders[property] = new CompositeExpressionBinder(
                value.value,
                names,
                type,
                useIntegerZoom,
                zoom,
                StructArrayLayout
              );
              keys.push(`/z_${property}`);
            }
          }
          self2.cacheKey = keys.sort().join("");
          return self2;
        }
        populatePaintArrays(newLength, feature, index, imagePositions) {
          for (const property in this.binders) {
            const binder = this.binders[property];
            binder.populatePaintArray(newLength, feature, imagePositions);
          }
          if (feature.id) {
            const featureId = String(feature.id);
            this._idMap[featureId] = this._idMap[featureId] || [];
            this._idMap[featureId].push({
              index,
              start: this._bufferOffset,
              end: newLength
            });
          }
          this._bufferOffset = newLength;
        }
        setConstantPatternPositions(posTo, posFrom) {
          for (const property in this.binders) {
            const binder = this.binders[property];
            binder.setConstantPatternPositions(posTo, posFrom);
          }
        }
        updatePaintArrays(featureStates, vtLayer, layer, imagePositions) {
          let dirty = false;
          for (const id in featureStates) {
            const posArray = this._idMap[id];
            if (!posArray) continue;
            const featureState = featureStates[id];
            for (const pos of posArray) {
              const feature = vtLayer.feature(pos.index);
              for (const property in this.binders) {
                const binder = this.binders[property];
                if (binder instanceof ConstantBinder || binder instanceof CrossFadedConstantBinder) continue;
                if (binder.expression.isStateDependent === true) {
                  const value = layer.paint.get(property);
                  binder.expression = value.value;
                  binder.updatePaintArray(pos.start, pos.end, feature, featureState, imagePositions);
                  dirty = true;
                }
              }
            }
          }
          return dirty;
        }
        defines() {
          const result = [];
          for (const property in this.binders) {
            result.push.apply(result, this.binders[property].defines());
          }
          return result;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(context, locations) {
          const result = {};
          for (const property in this.binders) {
            const binder = this.binders[property];
            for (const name of binder.uniformNames) {
              result[name] = binder.getBinding(context, locations[name]);
            }
          }
          return result;
        }
        setUniforms(context, uniformBindings, properties, globals) {
          for (const property in this.binders) {
            const binder = this.binders[property];
            for (const uniformName of binder.uniformNames) {
              binder.setUniforms(context, uniformBindings[uniformName], globals, properties.get(property), uniformName);
            }
          }
        }
        updatePatternPaintBuffers(crossfade) {
          const buffers = [];
          for (const property in this.binders) {
            const binder = this.binders[property];
            if (binder instanceof CrossFadedCompositeBinder) {
              const patternVertexBuffer = crossfade.fromScale === 2 ? binder.zoomInPaintVertexBuffer : binder.zoomOutPaintVertexBuffer;
              if (patternVertexBuffer) buffers.push(patternVertexBuffer);
            } else if ((binder instanceof SourceExpressionBinder || binder instanceof CompositeExpressionBinder) && binder.paintVertexBuffer) {
              buffers.push(binder.paintVertexBuffer);
            }
          }
          this._buffers = buffers;
        }
        upload(context) {
          for (const property in this.binders) {
            this.binders[property].upload(context);
          }
          const buffers = [];
          for (const property in this.binders) {
            const binder = this.binders[property];
            if ((binder instanceof SourceExpressionBinder || binder instanceof CompositeExpressionBinder) && binder.paintVertexBuffer) {
              buffers.push(binder.paintVertexBuffer);
            }
          }
          this._buffers = buffers;
        }
        destroy() {
          for (const property in this.binders) {
            this.binders[property].destroy();
          }
        }
      };
      var ProgramConfigurationSet = class {
        constructor(layoutAttributes, layers, zoom, filterProperties = () => true) {
          this.programConfigurations = {};
          for (const layer of layers) {
            this.programConfigurations[layer.id] = ProgramConfiguration.createDynamic(layer, zoom, filterProperties);
            this.programConfigurations[layer.id].layoutAttributes = layoutAttributes;
          }
          this.needsUpload = false;
        }
        populatePaintArrays(length, feature, index, imagePositions) {
          for (const key in this.programConfigurations) {
            this.programConfigurations[key].populatePaintArrays(length, feature, index, imagePositions);
          }
          this.needsUpload = true;
        }
        updatePaintArrays(featureStates, vtLayer, layers, imagePositions) {
          for (const layer of layers) {
            this.needsUpload = this.programConfigurations[layer.id].updatePaintArrays(featureStates, vtLayer, layer, imagePositions) || this.needsUpload;
          }
        }
        get(layerId) {
          return this.programConfigurations[layerId];
        }
        upload(context) {
          if (!this.needsUpload) return;
          for (const layerId in this.programConfigurations) {
            this.programConfigurations[layerId].upload(context);
          }
          this.needsUpload = false;
        }
        destroy() {
          for (const layerId in this.programConfigurations) {
            this.programConfigurations[layerId].destroy();
          }
        }
      };
      function paintAttributeNames(property, type) {
        const attributeNameExceptions = {
          "text-opacity": ["opacity"],
          "icon-opacity": ["opacity"],
          "text-color": ["fill_color"],
          "icon-color": ["fill_color"],
          "text-halo-color": ["halo_color"],
          "icon-halo-color": ["halo_color"],
          "text-halo-blur": ["halo_blur"],
          "icon-halo-blur": ["halo_blur"],
          "text-halo-width": ["halo_width"],
          "icon-halo-width": ["halo_width"],
          "line-gap-width": ["gapwidth"],
          "line-pattern": ["pattern_to", "pattern_from"],
          "fill-pattern": ["pattern_to", "pattern_from"],
          "fill-extrusion-pattern": ["pattern_to", "pattern_from"]
        };
        return attributeNameExceptions[property] || [property.replace(`${type}-`, "").replace(/-/g, "_")];
      }
      function getLayoutException(property) {
        const propertyExceptions = {
          "line-pattern": {
            source: PatternLayoutArray,
            composite: PatternLayoutArray
          },
          "fill-pattern": {
            source: PatternLayoutArray,
            composite: PatternLayoutArray
          },
          "fill-extrusion-pattern": {
            source: PatternLayoutArray,
            composite: PatternLayoutArray
          }
        };
        return propertyExceptions[property];
      }
      function layoutType(property, type, binderType) {
        const defaultLayouts = {
          color: {
            source: StructArrayLayout2f8,
            composite: StructArrayLayout4f16
          },
          number: {
            source: StructArrayLayout1f4,
            composite: StructArrayLayout2f8
          }
        };
        const layoutException = getLayoutException(property);
        return layoutException?.[binderType] || defaultLayouts[type][binderType];
      }
      register("ConstantBinder", ConstantBinder);
      register("CrossFadedConstantBinder", CrossFadedConstantBinder);
      register("SourceExpressionBinder", SourceExpressionBinder);
      register("CrossFadedCompositeBinder", CrossFadedCompositeBinder);
      register("CompositeExpressionBinder", CompositeExpressionBinder);
      register("ProgramConfiguration", ProgramConfiguration, { omit: ["_buffers"] });
      register("ProgramConfigurationSet", ProgramConfigurationSet);
      ProgramConfiguration.ProgramConfigurationSet = ProgramConfigurationSet;
      module.exports = ProgramConfiguration;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/index_array_type.js
  var require_index_array_type = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/index_array_type.js"(exports, module) {
      var { LineIndexArray, TriangleIndexArray, LineStripIndexArray } = require_array_types();
      module.exports = {
        LineIndexArray,
        TriangleIndexArray,
        LineStripIndexArray
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/extent.js
  var require_extent = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/extent.js"(exports, module) {
      module.exports = 8192;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/load_geometry.js
  var require_load_geometry = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/load_geometry.js"(exports, module) {
      var warn = require_warn();
      var EXTENT = require_extent();
      function createBounds(bits) {
        return {
          min: -1 * 2 ** (bits - 1),
          max: 2 ** (bits - 1) - 1
        };
      }
      var bounds2 = createBounds(16);
      module.exports = function loadGeometry(feature) {
        const scale = EXTENT / feature.extent;
        const geometry = feature.loadGeometry();
        for (let r = 0; r < geometry.length; r++) {
          const ring = geometry[r];
          for (let p = 0; p < ring.length; p++) {
            const point = ring[p];
            point.x = Math.round(point.x * scale);
            point.y = Math.round(point.y * scale);
            if (point.x < bounds2.min || point.x > bounds2.max || point.y < bounds2.min || point.y > bounds2.max) {
              warn.once("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
        }
        return geometry;
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/bucket/circle_bucket.js
  var require_circle_bucket = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/bucket/circle_bucket.js"(exports, module) {
      var { CircleLayoutArray } = require_array_types();
      var { members: layoutAttributes } = require_circle_attributes();
      var SegmentVector = require_segment();
      var { ProgramConfigurationSet } = require_program_configuration();
      var { TriangleIndexArray } = require_index_array_type();
      var loadGeometry = require_load_geometry();
      var EXTENT = require_extent();
      var { register } = require_transfer_registry();
      var EvaluationParameters = require_evaluation_parameters();
      function addCircleVertex(layoutVertexArray, x, y, extrudeX, extrudeY) {
        layoutVertexArray.emplaceBack(x * 2 + (extrudeX + 1) / 2, y * 2 + (extrudeY + 1) / 2);
      }
      var CircleBucket = class {
        constructor(options) {
          this.zoom = options.zoom;
          this.overscaling = options.overscaling;
          this.layers = options.layers;
          this.layerIds = this.layers.map((layer) => layer.id);
          this.index = options.index;
          this.hasPattern = false;
          this.layoutVertexArray = new CircleLayoutArray();
          this.indexArray = new TriangleIndexArray();
          this.segments = new SegmentVector();
          this.programConfigurations = new ProgramConfigurationSet(layoutAttributes, options.layers, options.zoom);
        }
        populate(features, options) {
          for (const { feature, index, sourceLayerIndex } of features) {
            if (this.layers[0]._featureFilter(new EvaluationParameters(this.zoom), feature)) {
              const geometry = loadGeometry(feature);
              this.addFeature(feature, geometry, index);
              options.featureIndex.insert(feature, geometry, index, sourceLayerIndex, this.index);
            }
          }
        }
        update(states, vtLayer, imagePositions) {
          if (!this.stateDependentLayers.length) return;
          this.programConfigurations.updatePaintArrays(states, vtLayer, this.stateDependentLayers, imagePositions);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(context) {
          if (!this.uploaded) {
            this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, layoutAttributes);
            this.indexBuffer = context.createIndexBuffer(this.indexArray);
          }
          this.programConfigurations.upload(context);
          this.uploaded = true;
        }
        destroy() {
          if (!this.layoutVertexBuffer) return;
          this.layoutVertexBuffer.destroy();
          this.indexBuffer.destroy();
          this.programConfigurations.destroy();
          this.segments.destroy();
        }
        addFeature(feature, geometry, index) {
          for (const ring of geometry) {
            for (const point of ring) {
              const x = point.x;
              const y = point.y;
              if (x < 0 || x >= EXTENT || y < 0 || y >= EXTENT) continue;
              const segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
              const index2 = segment.vertexLength;
              addCircleVertex(this.layoutVertexArray, x, y, -1, -1);
              addCircleVertex(this.layoutVertexArray, x, y, 1, -1);
              addCircleVertex(this.layoutVertexArray, x, y, 1, 1);
              addCircleVertex(this.layoutVertexArray, x, y, -1, 1);
              this.indexArray.emplaceBack(index2, index2 + 1, index2 + 2);
              this.indexArray.emplaceBack(index2, index2 + 3, index2 + 2);
              segment.vertexLength += 4;
              segment.primitiveLength += 2;
            }
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, feature, index, {});
        }
      };
      register("CircleBucket", CircleBucket, { omit: ["layers"] });
      module.exports = CircleBucket;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/intersection_tests.js
  var require_intersection_tests = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/intersection_tests.js"(exports, module) {
      var { isCounterClockwise } = require_util();
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      module.exports = {
        polygonIntersectsBufferedPoint,
        polygonIntersectsMultiPolygon,
        polygonIntersectsBufferedMultiLine,
        polygonIntersectsPolygon,
        distToSegmentSquared,
        polygonIntersectsBox
      };
      function polygonIntersectsPolygon(polygonA, polygonB) {
        for (let i = 0; i < polygonA.length; i++) {
          if (polygonContainsPoint(polygonB, polygonA[i])) return true;
        }
        for (let i = 0; i < polygonB.length; i++) {
          if (polygonContainsPoint(polygonA, polygonB[i])) return true;
        }
        if (lineIntersectsLine(polygonA, polygonB)) return true;
        return false;
      }
      function polygonIntersectsBufferedPoint(polygon, point, radius) {
        if (polygonContainsPoint(polygon, point)) return true;
        if (pointIntersectsBufferedLine(point, polygon, radius)) return true;
        return false;
      }
      function polygonIntersectsMultiPolygon(polygon, multiPolygon) {
        if (polygon.length === 1) {
          return multiPolygonContainsPoint(multiPolygon, polygon[0]);
        }
        for (let m = 0; m < multiPolygon.length; m++) {
          const ring = multiPolygon[m];
          for (let n = 0; n < ring.length; n++) {
            if (polygonContainsPoint(polygon, ring[n])) return true;
          }
        }
        for (let i = 0; i < polygon.length; i++) {
          if (multiPolygonContainsPoint(multiPolygon, polygon[i])) return true;
        }
        for (let k = 0; k < multiPolygon.length; k++) {
          if (lineIntersectsLine(polygon, multiPolygon[k])) return true;
        }
        return false;
      }
      function polygonIntersectsBufferedMultiLine(polygon, multiLine, radius) {
        for (let i = 0; i < multiLine.length; i++) {
          const line = multiLine[i];
          if (polygon.length >= 3) {
            for (let k = 0; k < line.length; k++) {
              if (polygonContainsPoint(polygon, line[k])) return true;
            }
          }
          if (lineIntersectsBufferedLine(polygon, line, radius)) return true;
        }
        return false;
      }
      function lineIntersectsBufferedLine(lineA, lineB, radius) {
        if (lineA.length > 1) {
          if (lineIntersectsLine(lineA, lineB)) return true;
          for (let j = 0; j < lineB.length; j++) {
            if (pointIntersectsBufferedLine(lineB[j], lineA, radius)) return true;
          }
        }
        for (let k = 0; k < lineA.length; k++) {
          if (pointIntersectsBufferedLine(lineA[k], lineB, radius)) return true;
        }
        return false;
      }
      function lineIntersectsLine(lineA, lineB) {
        if (lineA.length === 0 || lineB.length === 0) return false;
        for (let i = 0; i < lineA.length - 1; i++) {
          const a0 = lineA[i];
          const a1 = lineA[i + 1];
          for (let j = 0; j < lineB.length - 1; j++) {
            const b0 = lineB[j];
            const b1 = lineB[j + 1];
            if (lineSegmentIntersectsLineSegment(a0, a1, b0, b1)) return true;
          }
        }
        return false;
      }
      function lineSegmentIntersectsLineSegment(a0, a1, b0, b1) {
        return isCounterClockwise(a0, b0, b1) !== isCounterClockwise(a1, b0, b1) && isCounterClockwise(a0, a1, b0) !== isCounterClockwise(a0, a1, b1);
      }
      function pointIntersectsBufferedLine(p, line, radius) {
        const radiusSquared = radius * radius;
        if (line.length === 1) return p.distSqr(line[0]) < radiusSquared;
        for (let i = 1; i < line.length; i++) {
          const v = line[i - 1];
          const w = line[i];
          if (distToSegmentSquared(p, v, w) < radiusSquared) return true;
        }
        return false;
      }
      function distToSegmentSquared(p, v, w) {
        const l2 = v.distSqr(w);
        if (l2 === 0) return p.distSqr(v);
        const t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        if (t < 0) return p.distSqr(v);
        if (t > 1) return p.distSqr(w);
        return p.distSqr(w.sub(v)._mult(t)._add(v));
      }
      function multiPolygonContainsPoint(rings, p) {
        let c = false;
        let ring;
        let p1;
        let p2;
        for (let k = 0; k < rings.length; k++) {
          ring = rings[k];
          for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            p1 = ring[i];
            p2 = ring[j];
            if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
              c = !c;
            }
          }
        }
        return c;
      }
      function polygonContainsPoint(ring, p) {
        let c = false;
        for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
          const p1 = ring[i];
          const p2 = ring[j];
          if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
            c = !c;
          }
        }
        return c;
      }
      function polygonIntersectsBox(ring, boxX1, boxY1, boxX2, boxY2) {
        for (const p of ring) {
          if (boxX1 <= p.x && boxY1 <= p.y && boxX2 >= p.x && boxY2 >= p.y) return true;
        }
        const corners = [new Point3(boxX1, boxY1), new Point3(boxX1, boxY2), new Point3(boxX2, boxY2), new Point3(boxX2, boxY1)];
        if (ring.length > 2) {
          for (const corner of corners) {
            if (polygonContainsPoint(ring, corner)) return true;
          }
        }
        for (let i = 0; i < ring.length - 1; i++) {
          const p1 = ring[i];
          const p2 = ring[i + 1];
          if (edgeIntersectsBox(p1, p2, corners)) return true;
        }
        return false;
      }
      function edgeIntersectsBox(e1, e2, corners) {
        const tl = corners[0];
        const br = corners[2];
        if (e1.x < tl.x && e2.x < tl.x || e1.x > br.x && e2.x > br.x || e1.y < tl.y && e2.y < tl.y || e1.y > br.y && e2.y > br.y)
          return false;
        const dir = isCounterClockwise(e1, e2, corners[0]);
        return dir !== isCounterClockwise(e1, e2, corners[1]) || dir !== isCounterClockwise(e1, e2, corners[2]) || dir !== isCounterClockwise(e1, e2, corners[3]);
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/query_utils.js
  var require_query_utils = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/query_utils.js"(exports, module) {
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      module.exports = {
        getMaximumPaintValue,
        translateDistance,
        translate
      };
      function getMaximumPaintValue(property, layer, bucket) {
        const value = layer.paint.get(property).value;
        if (value.kind === "constant") {
          return value.value;
        }
        const binders = bucket.programConfigurations.get(layer.id).binders;
        return binders[property].maxValue;
      }
      function translateDistance(translate2) {
        return Math.sqrt(translate2[0] * translate2[0] + translate2[1] * translate2[1]);
      }
      function translate(queryGeometry, translate2, translateAnchor, bearing, pixelsToTileUnits) {
        if (!translate2[0] && !translate2[1]) {
          return queryGeometry;
        }
        const pt = Point3.convert(translate2);
        if (translateAnchor === "viewport") {
          pt._rotate(-bearing);
        }
        const translated = [];
        for (let i = 0; i < queryGeometry.length; i++) {
          const point = queryGeometry[i];
          translated.push(point.sub(pt._mult(pixelsToTileUnits)));
        }
        return translated;
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/circle_style_layer_properties.js
  var require_circle_style_layer_properties = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/circle_style_layer_properties.js"(exports, module) {
      var { Properties, DataConstantProperty, DataDrivenProperty } = require_properties2();
      var paint = new Properties({
        "circle-radius": new DataDrivenProperty({
          type: "number",
          default: 5,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "circle-color": new DataDrivenProperty({
          type: "color",
          default: "#000000",
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "circle-blur": new DataDrivenProperty({
          type: "number",
          default: 0,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "circle-opacity": new DataDrivenProperty({
          type: "number",
          default: 1,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "circle-translate": new DataConstantProperty({
          type: "array",
          value: "number",
          length: 2,
          default: [0, 0],
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "circle-translate-anchor": new DataConstantProperty({
          type: "enum",
          values: ["map", "viewport"],
          default: "map",
          expression: { parameters: ["zoom"] }
        }),
        "circle-pitch-scale": new DataConstantProperty({
          type: "enum",
          values: ["map", "viewport"],
          default: "map",
          expression: { parameters: ["zoom"] }
        }),
        "circle-pitch-alignment": new DataConstantProperty({
          type: "enum",
          values: ["map", "viewport"],
          default: "viewport",
          expression: { parameters: ["zoom"] }
        }),
        "circle-stroke-width": new DataDrivenProperty({
          type: "number",
          default: 0,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "circle-stroke-color": new DataDrivenProperty({
          type: "color",
          default: "#000000",
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "circle-stroke-opacity": new DataDrivenProperty({
          type: "number",
          default: 1,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        })
      });
      module.exports = { paint };
    }
  });

  // node_modules/@mapbox/gl-matrix/dist/gl-matrix.js
  var require_gl_matrix = __commonJS({
    "node_modules/@mapbox/gl-matrix/dist/gl-matrix.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.glMatrix = factory();
      })(exports, function() {
        "use strict";
        function create() {
          var out = new Float32Array(3);
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
          return out;
        }
        function transformMat3(out, a, m) {
          var x = a[0], y = a[1], z = a[2];
          out[0] = x * m[0] + y * m[3] + z * m[6];
          out[1] = x * m[1] + y * m[4] + z * m[7];
          out[2] = x * m[2] + y * m[5] + z * m[8];
          return out;
        }
        var vec = create();
        function create$1() {
          var out = new Float32Array(4);
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          return out;
        }
        function scale$1(out, a, b) {
          out[0] = a[0] * b;
          out[1] = a[1] * b;
          out[2] = a[2] * b;
          out[3] = a[3] * b;
          return out;
        }
        function normalize$1(out, a) {
          var x = a[0], y = a[1], z = a[2], w = a[3];
          var len = x * x + y * y + z * z + w * w;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out[0] = x * len;
            out[1] = y * len;
            out[2] = z * len;
            out[3] = w * len;
          }
          return out;
        }
        function transformMat4$1(out, a, m) {
          var x = a[0], y = a[1], z = a[2], w = a[3];
          out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
          out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
          out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
          out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
          return out;
        }
        var vec$1 = create$1();
        function create$2() {
          var out = new Float32Array(4);
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          return out;
        }
        function rotate(out, a, rad) {
          var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], s = Math.sin(rad), c = Math.cos(rad);
          out[0] = a0 * c + a2 * s;
          out[1] = a1 * c + a3 * s;
          out[2] = a0 * -s + a2 * c;
          out[3] = a1 * -s + a3 * c;
          return out;
        }
        function scale$2(out, a, v) {
          var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], v0 = v[0], v1 = v[1];
          out[0] = a0 * v0;
          out[1] = a1 * v0;
          out[2] = a2 * v1;
          out[3] = a3 * v1;
          return out;
        }
        function create$3() {
          var out = new Float32Array(9);
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 1;
          out[5] = 0;
          out[6] = 0;
          out[7] = 0;
          out[8] = 1;
          return out;
        }
        function fromRotation$1(out, rad) {
          var s = Math.sin(rad), c = Math.cos(rad);
          out[0] = c;
          out[1] = s;
          out[2] = 0;
          out[3] = -s;
          out[4] = c;
          out[5] = 0;
          out[6] = 0;
          out[7] = 0;
          out[8] = 1;
          return out;
        }
        function create$4() {
          var out = new Float32Array(16);
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[5] = 1;
          out[6] = 0;
          out[7] = 0;
          out[8] = 0;
          out[9] = 0;
          out[10] = 1;
          out[11] = 0;
          out[12] = 0;
          out[13] = 0;
          out[14] = 0;
          out[15] = 1;
          return out;
        }
        function identity$2(out) {
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[5] = 1;
          out[6] = 0;
          out[7] = 0;
          out[8] = 0;
          out[9] = 0;
          out[10] = 1;
          out[11] = 0;
          out[12] = 0;
          out[13] = 0;
          out[14] = 0;
          out[15] = 1;
          return out;
        }
        function invert$2(out, a) {
          var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) {
            return null;
          }
          det = 1 / det;
          out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
          out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
          out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
          out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
          out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
          out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
          out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
          return out;
        }
        function multiply$4(out, a, b) {
          var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
          var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
          out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[4];
          b1 = b[5];
          b2 = b[6];
          b3 = b[7];
          out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[8];
          b1 = b[9];
          b2 = b[10];
          b3 = b[11];
          out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[12];
          b1 = b[13];
          b2 = b[14];
          b3 = b[15];
          out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          return out;
        }
        function translate$1(out, a, v) {
          var x = v[0], y = v[1], z = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
          if (a === out) {
            out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
            out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
            out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
            out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
          } else {
            a00 = a[0];
            a01 = a[1];
            a02 = a[2];
            a03 = a[3];
            a10 = a[4];
            a11 = a[5];
            a12 = a[6];
            a13 = a[7];
            a20 = a[8];
            a21 = a[9];
            a22 = a[10];
            a23 = a[11];
            out[0] = a00;
            out[1] = a01;
            out[2] = a02;
            out[3] = a03;
            out[4] = a10;
            out[5] = a11;
            out[6] = a12;
            out[7] = a13;
            out[8] = a20;
            out[9] = a21;
            out[10] = a22;
            out[11] = a23;
            out[12] = a00 * x + a10 * y + a20 * z + a[12];
            out[13] = a01 * x + a11 * y + a21 * z + a[13];
            out[14] = a02 * x + a12 * y + a22 * z + a[14];
            out[15] = a03 * x + a13 * y + a23 * z + a[15];
          }
          return out;
        }
        function scale$4(out, a, v) {
          var x = v[0], y = v[1], z = v[2];
          out[0] = a[0] * x;
          out[1] = a[1] * x;
          out[2] = a[2] * x;
          out[3] = a[3] * x;
          out[4] = a[4] * y;
          out[5] = a[5] * y;
          out[6] = a[6] * y;
          out[7] = a[7] * y;
          out[8] = a[8] * z;
          out[9] = a[9] * z;
          out[10] = a[10] * z;
          out[11] = a[11] * z;
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
          return out;
        }
        function rotateX$1(out, a, rad) {
          var s = Math.sin(rad), c = Math.cos(rad), a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
          if (a !== out) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
          }
          out[4] = a10 * c + a20 * s;
          out[5] = a11 * c + a21 * s;
          out[6] = a12 * c + a22 * s;
          out[7] = a13 * c + a23 * s;
          out[8] = a20 * c - a10 * s;
          out[9] = a21 * c - a11 * s;
          out[10] = a22 * c - a12 * s;
          out[11] = a23 * c - a13 * s;
          return out;
        }
        function rotateZ$1(out, a, rad) {
          var s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
          if (a !== out) {
            out[8] = a[8];
            out[9] = a[9];
            out[10] = a[10];
            out[11] = a[11];
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
          }
          out[0] = a00 * c + a10 * s;
          out[1] = a01 * c + a11 * s;
          out[2] = a02 * c + a12 * s;
          out[3] = a03 * c + a13 * s;
          out[4] = a10 * c - a00 * s;
          out[5] = a11 * c - a01 * s;
          out[6] = a12 * c - a02 * s;
          out[7] = a13 * c - a03 * s;
          return out;
        }
        function perspective(out, fovy, aspect, near, far) {
          var f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
          out[0] = f / aspect;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[5] = f;
          out[6] = 0;
          out[7] = 0;
          out[8] = 0;
          out[9] = 0;
          out[10] = (far + near) * nf;
          out[11] = -1;
          out[12] = 0;
          out[13] = 0;
          out[14] = 2 * far * near * nf;
          out[15] = 0;
          return out;
        }
        function ortho(out, left, right, bottom, top, near, far) {
          var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
          out[0] = -2 * lr;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[5] = -2 * bt;
          out[6] = 0;
          out[7] = 0;
          out[8] = 0;
          out[9] = 0;
          out[10] = 2 * nf;
          out[11] = 0;
          out[12] = (left + right) * lr;
          out[13] = (top + bottom) * bt;
          out[14] = (far + near) * nf;
          out[15] = 1;
          return out;
        }
        var mapboxBuild = {
          vec3: {
            transformMat3
          },
          vec4: {
            transformMat4: transformMat4$1
          },
          mat2: {
            create: create$2,
            rotate,
            scale: scale$2
          },
          mat3: {
            create: create$3,
            fromRotation: fromRotation$1
          },
          mat4: {
            create: create$4,
            identity: identity$2,
            translate: translate$1,
            scale: scale$4,
            multiply: multiply$4,
            perspective,
            rotateX: rotateX$1,
            rotateZ: rotateZ$1,
            invert: invert$2,
            ortho
          }
        };
        return mapboxBuild;
      });
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/circle_style_layer.js
  var require_circle_style_layer = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/circle_style_layer.js"(exports, module) {
      var StyleLayer = require_style_layer();
      var CircleBucket = require_circle_bucket();
      var { polygonIntersectsBufferedPoint } = require_intersection_tests();
      var { getMaximumPaintValue, translateDistance, translate } = require_query_utils();
      var properties = require_circle_style_layer_properties();
      var { vec4 } = require_gl_matrix();
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      var CircleStyleLayer = class extends StyleLayer {
        constructor(layer) {
          super(layer, properties);
        }
        createBucket(parameters) {
          return new CircleBucket(parameters);
        }
        queryRadius(bucket) {
          const circleBucket = bucket;
          return getMaximumPaintValue("circle-radius", this, circleBucket) + getMaximumPaintValue("circle-stroke-width", this, circleBucket) + translateDistance(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(queryGeometry, feature, featureState, geometry, zoom, transform, pixelsToTileUnits, pixelPosMatrix) {
          const translatedPolygon = translate(
            queryGeometry,
            this.paint.get("circle-translate"),
            this.paint.get("circle-translate-anchor"),
            transform.angle,
            pixelsToTileUnits
          );
          const radius = this.paint.get("circle-radius").evaluate(feature, featureState);
          const stroke = this.paint.get("circle-stroke-width").evaluate(feature, featureState);
          const size = radius + stroke;
          const alignWithMap = this.paint.get("circle-pitch-alignment") === "map";
          const transformedPolygon = alignWithMap ? translatedPolygon : projectQueryGeometry(translatedPolygon, pixelPosMatrix);
          const transformedSize = alignWithMap ? size * pixelsToTileUnits : size;
          for (const ring of geometry) {
            for (const point of ring) {
              const transformedPoint = alignWithMap ? point : projectPoint(point, pixelPosMatrix);
              let adjustedSize = transformedSize;
              const projectedCenter = vec4.transformMat4([], [point.x, point.y, 0, 1], pixelPosMatrix);
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map") {
                adjustedSize *= projectedCenter[3] / transform.cameraToCenterDistance;
              } else if (this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport") {
                adjustedSize *= transform.cameraToCenterDistance / projectedCenter[3];
              }
              if (polygonIntersectsBufferedPoint(transformedPolygon, transformedPoint, adjustedSize)) return true;
            }
          }
          return false;
        }
      };
      function projectPoint(p, pixelPosMatrix) {
        const point = vec4.transformMat4([], [p.x, p.y, 0, 1], pixelPosMatrix);
        return new Point3(point[0] / point[3], point[1] / point[3]);
      }
      function projectQueryGeometry(queryGeometry, pixelPosMatrix) {
        return queryGeometry.map((p) => {
          return projectPoint(p, pixelPosMatrix);
        });
      }
      module.exports = CircleStyleLayer;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/bucket/heatmap_bucket.js
  var require_heatmap_bucket = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/bucket/heatmap_bucket.js"(exports, module) {
      var CircleBucket = require_circle_bucket();
      var { register } = require_transfer_registry();
      var HeatmapBucket = class extends CircleBucket {
        // Needed for flow to accept omit: ['layers'] below, due to
        // https://github.com/facebook/flow/issues/4262
      };
      register("HeatmapBucket", HeatmapBucket, { omit: ["layers"] });
      module.exports = HeatmapBucket;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/heatmap_style_layer_properties.js
  var require_heatmap_style_layer_properties = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/heatmap_style_layer_properties.js"(exports, module) {
      var { Properties, ColorRampProperty, DataConstantProperty, DataDrivenProperty } = require_properties2();
      var paint = new Properties({
        "heatmap-radius": new DataDrivenProperty({
          type: "number",
          default: 30,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "heatmap-weight": new DataDrivenProperty({
          type: "number",
          default: 1,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "heatmap-intensity": new DataConstantProperty({
          type: "number",
          default: 1,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "heatmap-color": new ColorRampProperty({
          type: "color",
          default: [
            "interpolate",
            ["linear"],
            ["heatmap-density"],
            0,
            "rgba(0, 0, 255, 0)",
            0.1,
            "royalblue",
            0.3,
            "cyan",
            0.5,
            "lime",
            0.7,
            "yellow",
            1,
            "red"
          ],
          expression: { interpolated: true, parameters: ["heatmap-density"] }
        }),
        "heatmap-opacity": new DataConstantProperty({
          type: "number",
          default: 1,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        })
      });
      module.exports = { paint };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/image.js
  var require_image2 = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/image.js"(exports, module) {
      var assert = require_nanoassert();
      var { register } = require_transfer_registry();
      function createImage(image, { width, height }, channels, data) {
        if (!data) {
          data = new Uint8Array(width * height * channels);
        } else if (data.length !== width * height * channels) {
          throw new RangeError("mismatched image size");
        }
        image.width = width;
        image.height = height;
        image.data = data;
        return image;
      }
      function resizeImage(image, { width, height }, channels) {
        if (width === image.width && height === image.height) {
          return;
        }
        const newImage = createImage({}, { width, height }, channels);
        copyImage(
          image,
          newImage,
          { x: 0, y: 0 },
          { x: 0, y: 0 },
          {
            width: Math.min(image.width, width),
            height: Math.min(image.height, height)
          },
          channels
        );
        image.width = width;
        image.height = height;
        image.data = newImage.data;
      }
      function copyImage(srcImg, dstImg, srcPt, dstPt, size, channels) {
        if (size.width === 0 || size.height === 0) {
          return dstImg;
        }
        if (size.width > srcImg.width || size.height > srcImg.height || srcPt.x > srcImg.width - size.width || srcPt.y > srcImg.height - size.height) {
          throw new RangeError("out of range source coordinates for image copy");
        }
        if (size.width > dstImg.width || size.height > dstImg.height || dstPt.x > dstImg.width - size.width || dstPt.y > dstImg.height - size.height) {
          throw new RangeError("out of range destination coordinates for image copy");
        }
        const srcData = srcImg.data;
        const dstData = dstImg.data;
        assert(srcData !== dstData);
        for (let y = 0; y < size.height; y++) {
          const srcOffset = ((srcPt.y + y) * srcImg.width + srcPt.x) * channels;
          const dstOffset = ((dstPt.y + y) * dstImg.width + dstPt.x) * channels;
          for (let i = 0; i < size.width * channels; i++) {
            dstData[dstOffset + i] = srcData[srcOffset + i];
          }
        }
        return dstImg;
      }
      var AlphaImage = class _AlphaImage {
        constructor(size, data) {
          createImage(this, size, 1, data);
        }
        resize(size) {
          resizeImage(this, size, 1);
        }
        clone() {
          return new _AlphaImage({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(srcImg, dstImg, srcPt, dstPt, size) {
          copyImage(srcImg, dstImg, srcPt, dstPt, size, 1);
        }
      };
      var RGBAImage = class _RGBAImage {
        constructor(size, data) {
          createImage(this, size, 4, data);
        }
        resize(size) {
          resizeImage(this, size, 4);
        }
        clone() {
          return new _RGBAImage({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(srcImg, dstImg, srcPt, dstPt, size) {
          copyImage(srcImg, dstImg, srcPt, dstPt, size, 4);
        }
      };
      register("AlphaImage", AlphaImage);
      register("RGBAImage", RGBAImage);
      module.exports = {
        AlphaImage,
        RGBAImage
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/color_ramp.js
  var require_color_ramp = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/color_ramp.js"(exports, module) {
      var { RGBAImage } = require_image2();
      module.exports = function renderColorRamp(expression, colorRampEvaluationParameter) {
        const colorRampData = new Uint8Array(256 * 4);
        const evaluationGlobals = {};
        for (let i = 0, j = 0; i < 256; i++, j += 4) {
          evaluationGlobals[colorRampEvaluationParameter] = i / 255;
          const pxColor = expression.evaluate(evaluationGlobals);
          colorRampData[j + 0] = Math.floor(pxColor.r * 255 / pxColor.a);
          colorRampData[j + 1] = Math.floor(pxColor.g * 255 / pxColor.a);
          colorRampData[j + 2] = Math.floor(pxColor.b * 255 / pxColor.a);
          colorRampData[j + 3] = Math.floor(pxColor.a * 255);
        }
        return new RGBAImage({ width: 256, height: 1 }, colorRampData);
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/heatmap_style_layer.js
  var require_heatmap_style_layer = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/heatmap_style_layer.js"(exports, module) {
      var StyleLayer = require_style_layer();
      var HeatmapBucket = require_heatmap_bucket();
      var properties = require_heatmap_style_layer_properties();
      var renderColorRamp = require_color_ramp();
      var HeatmapStyleLayer = class extends StyleLayer {
        createBucket(options) {
          return new HeatmapBucket(options);
        }
        constructor(layer) {
          super(layer, properties);
          this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(name) {
          if (name === "heatmap-color") {
            this._updateColorRamp();
          }
        }
        _updateColorRamp() {
          const expression = this._transitionablePaint._values["heatmap-color"].value.expression;
          this.colorRamp = renderColorRamp(expression, "heatmapDensity");
          this.colorRampTexture = null;
        }
        resize() {
          if (this.heatmapFbo) {
            this.heatmapFbo.destroy();
            this.heatmapFbo = null;
          }
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return false;
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
      };
      module.exports = HeatmapStyleLayer;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/hillshade_style_layer_properties.js
  var require_hillshade_style_layer_properties = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/hillshade_style_layer_properties.js"(exports, module) {
      var { Properties, DataConstantProperty } = require_properties2();
      var paint = new Properties({
        "hillshade-illumination-direction": new DataConstantProperty({
          type: "number",
          default: 335,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "hillshade-illumination-anchor": new DataConstantProperty({
          type: "enum",
          values: ["map", "viewport"],
          default: "viewport",
          expression: { parameters: ["zoom"] }
        }),
        "hillshade-exaggeration": new DataConstantProperty({
          type: "number",
          default: 0.5,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "hillshade-shadow-color": new DataConstantProperty({
          type: "color",
          default: "#000000",
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "hillshade-highlight-color": new DataConstantProperty({
          type: "color",
          default: "#FFFFFF",
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "hillshade-accent-color": new DataConstantProperty({
          type: "color",
          default: "#000000",
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        })
      });
      module.exports = { paint };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/hillshade_style_layer.js
  var require_hillshade_style_layer = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/hillshade_style_layer.js"(exports, module) {
      var StyleLayer = require_style_layer();
      var properties = require_hillshade_style_layer_properties();
      var HillshadeStyleLayer = class extends StyleLayer {
        constructor(layer) {
          super(layer, properties);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
      };
      module.exports = HillshadeStyleLayer;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/bucket/fill_attributes.js
  var require_fill_attributes = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/bucket/fill_attributes.js"(exports, module) {
      var { createLayout } = require_struct_array();
      var layout = createLayout([{ name: "a_pos", components: 2, type: "Int16" }], 4);
      module.exports = layout;
    }
  });

  // node_modules/earcut/src/earcut.js
  var earcut_exports = {};
  __export(earcut_exports, {
    default: () => earcut,
    deviation: () => deviation,
    flatten: () => flatten
  });
  function earcut(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = data[0];
      minY = data[1];
      let maxX = minX;
      let maxY = minY;
      for (let i = dim; i < outerLen; i += dim) {
        const x = data[i];
        const y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
  function linkedList(data, start, end, dim, clockwise) {
    let last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (let i = start; i < end; i += dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);
    } else {
      for (let i = end - dim; i >= start; i -= dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    let p = start, again;
    do {
      again = false;
      if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next) break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    let stop = ear;
    while (ear.prev !== ear.next) {
      const prev = ear.prev;
      const next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i, ear.i, next.i);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false;
    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    const x0 = Math.min(ax, bx, cx), y0 = Math.min(ay, by, cy), x1 = Math.max(ax, bx, cx), y1 = Math.max(ay, by, cy);
    let p = c.next;
    while (p !== a) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false;
    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    const x0 = Math.min(ax, bx, cx), y0 = Math.min(ay, by, cy), x1 = Math.max(ax, bx, cx), y1 = Math.max(ay, by, cy);
    const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
    let p = ear.prevZ, n = ear.nextZ;
    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.prevZ;
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    }
    while (p && p.z >= minZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.prevZ;
    }
    while (n && n.z <= maxZ) {
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles) {
    let p = start;
    do {
      const a = p.prev, b = p.next.next;
      if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
        triangles.push(a.i, p.i, b.i);
        removeNode(p);
        removeNode(p.next);
        p = start = b;
      }
      p = p.next;
    } while (p !== start);
    return filterPoints(p);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a = start;
    do {
      let b = a.next.next;
      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          let c = splitPolygon(a, b);
          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next);
          earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
          earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
          return;
        }
        b = b.next;
      }
      a = a.next;
    } while (a !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    for (let i = 0, len = holeIndices.length; i < len; i++) {
      const start = holeIndices[i] * dim;
      const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      const list = linkedList(data, start, end, dim, false);
      if (list === list.next) list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareXYSlope);
    for (let i = 0; i < queue.length; i++) {
      outerNode = eliminateHole(queue[i], outerNode);
    }
    return outerNode;
  }
  function compareXYSlope(a, b) {
    let result = a.x - b.x;
    if (result === 0) {
      result = a.y - b.y;
      if (result === 0) {
        const aSlope = (a.next.y - a.y) / (a.next.x - a.x);
        const bSlope = (b.next.y - b.y) / (b.next.x - b.x);
        result = aSlope - bSlope;
      }
    }
    return result;
  }
  function eliminateHole(hole, outerNode) {
    const bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }
    const bridgeReverse = splitPolygon(bridge, hole);
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
  }
  function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity;
    let m;
    if (equals(hole, p)) return p;
    do {
      if (equals(hole, p.next)) return p.next;
      else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
        if (x <= hx && x > qx) {
          qx = x;
          m = p.x < p.next.x ? p : p.next;
          if (x === hx) return m;
        }
      }
      p = p.next;
    } while (p !== outerNode);
    if (!m) return null;
    const stop = m;
    const mx = m.x;
    const my = m.y;
    let tanMin = Infinity;
    p = m;
    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        const tan = Math.abs(hy - p.y) / (hx - p.x);
        if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
          m = p;
          tanMin = tan;
        }
      }
      p = p.next;
    } while (p !== stop);
    return m;
  }
  function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
      if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  }
  function sortLinked(list) {
    let numMerges;
    let inSize = 1;
    do {
      let p = list;
      let e;
      list = null;
      let tail = null;
      numMerges = 0;
      while (p) {
        numMerges++;
        let q = p;
        let pSize = 0;
        for (let i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q) break;
        }
        let qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail) tail.nextZ = e;
          else list = e;
          e.prevZ = tail;
          tail = e;
        }
        p = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x, y, minX, minY, invSize) {
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
  }
  function getLeftmost(start) {
    let p = start, leftmost = start;
    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
      p = p.next;
    } while (p !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
  }
  function pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {
    return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);
  }
  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // doesn't intersect other edges
    (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
    (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
  }
  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true;
    if (o1 === 0 && onSegment(p1, p2, q1)) return true;
    if (o2 === 0 && onSegment(p1, q2, q1)) return true;
    if (o3 === 0 && onSegment(p2, p1, q2)) return true;
    if (o4 === 0 && onSegment(p2, q1, q2)) return true;
    return false;
  }
  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a, b) {
    let p = a;
    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
      p = p.next;
    } while (p !== a);
    return false;
  }
  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  }
  function middleInside(a, b) {
    let p = a;
    let inside = false;
    const px = (a.x + b.x) / 2;
    const py = (a.y + b.y) / 2;
    do {
      if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
        inside = !inside;
      p = p.next;
    } while (p !== a);
    return inside;
  }
  function splitPolygon(a, b) {
    const a2 = createNode(a.i, a.x, a.y), b2 = createNode(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }
  function insertNode(i, x, y, last) {
    const p = createNode(i, x, y);
    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }
    return p;
  }
  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
  }
  function createNode(i, x, y) {
    return {
      i,
      // vertex index in coordinates array
      x,
      y,
      // vertex coordinates
      prev: null,
      // previous and next vertex nodes in a polygon ring
      next: null,
      z: 0,
      // z-order curve value
      prevZ: null,
      // previous and next nodes in z-order
      nextZ: null,
      steiner: false
      // indicates whether this is a steiner point
    };
  }
  function deviation(data, holeIndices, dim, triangles) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
      for (let i = 0, len = holeIndices.length; i < len; i++) {
        const start = holeIndices[i] * dim;
        const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        polygonArea -= Math.abs(signedArea(data, start, end, dim));
      }
    }
    let trianglesArea = 0;
    for (let i = 0; i < triangles.length; i += 3) {
      const a = triangles[i] * dim;
      const b = triangles[i + 1] * dim;
      const c = triangles[i + 2] * dim;
      trianglesArea += Math.abs(
        (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
      );
    }
    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
  }
  function signedArea(data, start, end, dim) {
    let sum = 0;
    for (let i = start, j = end - dim; i < end; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }
    return sum;
  }
  function flatten(data) {
    const vertices = [];
    const holes = [];
    const dimensions = data[0][0].length;
    let holeIndex = 0;
    let prevLen = 0;
    for (const ring of data) {
      for (const p of ring) {
        for (let d = 0; d < dimensions; d++) vertices.push(p[d]);
      }
      if (prevLen) {
        holeIndex += prevLen;
        holes.push(holeIndex);
      }
      prevLen = ring.length;
    }
    return { vertices, holes, dimensions };
  }
  var init_earcut = __esm({
    "node_modules/earcut/src/earcut.js"() {
    }
  });

  // node_modules/quickselect/index.js
  var quickselect_exports = {};
  __export(quickselect_exports, {
    default: () => quickselect
  });
  function quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {
    while (right > left) {
      if (right - left > 600) {
        const n = right - left + 1;
        const m = k - left + 1;
        const z = Math.log(n);
        const s = 0.5 * Math.exp(2 * z / 3);
        const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
        const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
        const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
        quickselect(arr, k, newLeft, newRight, compare);
      }
      const t = arr[k];
      let i = left;
      let j = right;
      swap(arr, left, k);
      if (compare(arr[right], t) > 0) swap(arr, left, right);
      while (i < j) {
        swap(arr, i, j);
        i++;
        j--;
        while (compare(arr[i], t) < 0) i++;
        while (compare(arr[j], t) > 0) j--;
      }
      if (compare(arr[left], t) === 0) swap(arr, left, j);
      else {
        j++;
        swap(arr, j, right);
      }
      if (j <= k) left = j + 1;
      if (k <= j) right = j - 1;
    }
  }
  function swap(arr, i, j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
  function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  var init_quickselect = __esm({
    "node_modules/quickselect/index.js"() {
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/classify_rings.js
  var require_classify_rings = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/classify_rings.js"(exports, module) {
      var { default: quickselect2 } = (init_quickselect(), __toCommonJS(quickselect_exports));
      var { calculateSignedArea } = require_util();
      module.exports = function classifyRings(rings, maxRings) {
        if (rings.length <= 1) return [rings];
        const polygons = [];
        let polygon;
        let ccw;
        for (const ring of rings) {
          const area2 = calculateSignedArea(ring);
          if (area2 === 0) continue;
          ring.area = Math.abs(area2);
          if (ccw === void 0) ccw = area2 < 0;
          if (ccw === area2 < 0) {
            append(polygon);
            polygon = [ring];
          } else {
            polygon.push(ring);
          }
        }
        append(polygon);
        return polygons;
        function append(polygon2) {
          if (!polygon2) {
            return;
          }
          if (maxRings > 1 && maxRings < polygon2.length) {
            quickselect2(polygon2, maxRings, 1, polygon2.length - 1, (a, b) => b.area - a.area);
            polygon2.length = maxRings;
          }
          polygons.push(polygon2);
        }
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/bucket/pattern_bucket_features.js
  var require_pattern_bucket_features = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/bucket/pattern_bucket_features.js"(exports, module) {
      function hasPattern(type, layers, options) {
        const patterns = options.patternDependencies;
        let hasPattern2 = false;
        for (const layer of layers) {
          const patternProperty = layer.paint.get(`${type}-pattern`);
          if (!patternProperty.isConstant()) {
            hasPattern2 = true;
          }
          const constantPattern = patternProperty.constantOr(null);
          if (constantPattern) {
            hasPattern2 = true;
            patterns[constantPattern.to] = true;
            patterns[constantPattern.from] = true;
          }
        }
        return hasPattern2;
      }
      function addPatternDependencies(type, layers, patternFeature, zoom, options) {
        const patterns = options.patternDependencies;
        for (const layer of layers) {
          const patternProperty = layer.paint.get(`${type}-pattern`);
          const patternPropertyValue = patternProperty.value;
          if (patternPropertyValue.kind !== "constant") {
            const min = patternPropertyValue.evaluate({ zoom: zoom - 1 }, patternFeature, {});
            const mid = patternPropertyValue.evaluate({ zoom }, patternFeature, {});
            const max = patternPropertyValue.evaluate({ zoom: zoom + 1 }, patternFeature, {});
            patterns[min] = true;
            patterns[mid] = true;
            patterns[max] = true;
            patternFeature.patterns[layer.id] = { min, mid, max };
          }
        }
        return patternFeature;
      }
      module.exports = { hasPattern, addPatternDependencies };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/bucket/fill_bucket.js
  var require_fill_bucket = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/bucket/fill_bucket.js"(exports, module) {
      var { FillLayoutArray } = require_array_types();
      var { members: layoutAttributes } = require_fill_attributes();
      var SegmentVector = require_segment();
      var { ProgramConfigurationSet } = require_program_configuration();
      var { LineIndexArray, TriangleIndexArray } = require_index_array_type();
      var { default: earcut2 } = (init_earcut(), __toCommonJS(earcut_exports));
      var classifyRings = require_classify_rings();
      var assert = require_nanoassert();
      var EARCUT_MAX_RINGS = 500;
      var { register } = require_transfer_registry();
      var { hasPattern, addPatternDependencies } = require_pattern_bucket_features();
      var loadGeometry = require_load_geometry();
      var EvaluationParameters = require_evaluation_parameters();
      var FillBucket = class {
        constructor(options) {
          this.zoom = options.zoom;
          this.overscaling = options.overscaling;
          this.layers = options.layers;
          this.layerIds = this.layers.map((layer) => layer.id);
          this.index = options.index;
          this.hasPattern = false;
          this.layoutVertexArray = new FillLayoutArray();
          this.indexArray = new TriangleIndexArray();
          this.indexArray2 = new LineIndexArray();
          this.programConfigurations = new ProgramConfigurationSet(layoutAttributes, options.layers, options.zoom);
          this.segments = new SegmentVector();
          this.segments2 = new SegmentVector();
        }
        populate(features, options) {
          this.features = [];
          this.hasPattern = hasPattern("fill", this.layers, options);
          for (const { feature, index, sourceLayerIndex } of features) {
            if (!this.layers[0]._featureFilter(new EvaluationParameters(this.zoom), feature)) continue;
            const geometry = loadGeometry(feature);
            const patternFeature = {
              sourceLayerIndex,
              index,
              geometry,
              properties: feature.properties,
              type: feature.type,
              patterns: {}
            };
            if (typeof feature.id !== "undefined") {
              patternFeature.id = feature.id;
            }
            if (this.hasPattern) {
              this.features.push(addPatternDependencies("fill", this.layers, patternFeature, this.zoom, options));
            } else {
              this.addFeature(patternFeature, geometry, index, {});
            }
            options.featureIndex.insert(feature, geometry, index, sourceLayerIndex, this.index);
          }
        }
        update(states, vtLayer, imagePositions) {
          if (!this.stateDependentLayers.length) return;
          this.programConfigurations.updatePaintArrays(states, vtLayer, this.stateDependentLayers, imagePositions);
        }
        addFeatures(options, imagePositions) {
          for (const feature of this.features) {
            const { geometry } = feature;
            this.addFeature(feature, geometry, feature.index, imagePositions);
          }
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(context) {
          if (!this.uploaded) {
            this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, layoutAttributes);
            this.indexBuffer = context.createIndexBuffer(this.indexArray);
            this.indexBuffer2 = context.createIndexBuffer(this.indexArray2);
          }
          this.programConfigurations.upload(context);
          this.uploaded = true;
        }
        destroy() {
          if (!this.layoutVertexBuffer) return;
          this.layoutVertexBuffer.destroy();
          this.indexBuffer.destroy();
          this.indexBuffer2.destroy();
          this.programConfigurations.destroy();
          this.segments.destroy();
          this.segments2.destroy();
        }
        addFeature(feature, geometry, index, imagePositions) {
          for (const polygon of classifyRings(geometry, EARCUT_MAX_RINGS)) {
            let numVertices = 0;
            for (const ring of polygon) {
              numVertices += ring.length;
            }
            const triangleSegment = this.segments.prepareSegment(numVertices, this.layoutVertexArray, this.indexArray);
            const triangleIndex = triangleSegment.vertexLength;
            const flattened = [];
            const holeIndices = [];
            for (const ring of polygon) {
              if (ring.length === 0) {
                continue;
              }
              if (ring !== polygon[0]) {
                holeIndices.push(flattened.length / 2);
              }
              const lineSegment = this.segments2.prepareSegment(ring.length, this.layoutVertexArray, this.indexArray2);
              const lineIndex = lineSegment.vertexLength;
              this.layoutVertexArray.emplaceBack(ring[0].x, ring[0].y);
              this.indexArray2.emplaceBack(lineIndex + ring.length - 1, lineIndex);
              flattened.push(ring[0].x);
              flattened.push(ring[0].y);
              for (let i = 1; i < ring.length; i++) {
                this.layoutVertexArray.emplaceBack(ring[i].x, ring[i].y);
                this.indexArray2.emplaceBack(lineIndex + i - 1, lineIndex + i);
                flattened.push(ring[i].x);
                flattened.push(ring[i].y);
              }
              lineSegment.vertexLength += ring.length;
              lineSegment.primitiveLength += ring.length;
            }
            const indices = earcut2(flattened, holeIndices);
            assert(indices.length % 3 === 0);
            for (let i = 0; i < indices.length; i += 3) {
              this.indexArray.emplaceBack(
                triangleIndex + indices[i],
                triangleIndex + indices[i + 1],
                triangleIndex + indices[i + 2]
              );
            }
            triangleSegment.vertexLength += numVertices;
            triangleSegment.primitiveLength += indices.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, feature, index, imagePositions);
        }
      };
      register("FillBucket", FillBucket, { omit: ["layers", "features"] });
      module.exports = FillBucket;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/fill_style_layer_properties.js
  var require_fill_style_layer_properties = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/fill_style_layer_properties.js"(exports, module) {
      var { Properties, CrossFadedDataDrivenProperty, DataConstantProperty, DataDrivenProperty } = require_properties2();
      var paint = new Properties({
        "fill-antialias": new DataConstantProperty({ type: "boolean", default: true, expression: { parameters: ["zoom"] } }),
        "fill-opacity": new DataDrivenProperty({
          type: "number",
          default: 1,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "fill-color": new DataDrivenProperty({
          type: "color",
          default: "#000000",
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "fill-outline-color": new DataDrivenProperty({
          type: "color",
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "fill-translate": new DataConstantProperty({
          type: "array",
          value: "number",
          length: 2,
          default: [0, 0],
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "fill-translate-anchor": new DataConstantProperty({
          type: "enum",
          values: ["map", "viewport"],
          default: "map",
          expression: { parameters: ["zoom"] }
        }),
        "fill-pattern": new CrossFadedDataDrivenProperty({
          type: "string",
          transition: true,
          expression: { parameters: ["zoom", "feature"] }
        })
      });
      module.exports = { paint };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/fill_style_layer.js
  var require_fill_style_layer = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/fill_style_layer.js"(exports, module) {
      var StyleLayer = require_style_layer();
      var FillBucket = require_fill_bucket();
      var { polygonIntersectsMultiPolygon } = require_intersection_tests();
      var { translateDistance, translate } = require_query_utils();
      var properties = require_fill_style_layer_properties();
      var FillStyleLayer = class extends StyleLayer {
        constructor(layer) {
          super(layer, properties);
        }
        recalculate(parameters) {
          super.recalculate(parameters);
          const outlineColor = this.paint._values["fill-outline-color"];
          if (outlineColor.value.kind === "constant" && outlineColor.value.value === void 0) {
            this.paint._values["fill-outline-color"] = this.paint._values["fill-color"];
          }
        }
        createBucket(parameters) {
          return new FillBucket(parameters);
        }
        queryRadius() {
          return translateDistance(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(queryGeometry, feature, featureState, geometry, zoom, transform, pixelsToTileUnits) {
          const translatedPolygon = translate(
            queryGeometry,
            this.paint.get("fill-translate"),
            this.paint.get("fill-translate-anchor"),
            transform.angle,
            pixelsToTileUnits
          );
          return polygonIntersectsMultiPolygon(translatedPolygon, geometry);
        }
        isTileClipped() {
          return true;
        }
      };
      module.exports = FillStyleLayer;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/bucket/fill_extrusion_attributes.js
  var require_fill_extrusion_attributes = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/bucket/fill_extrusion_attributes.js"(exports, module) {
      var { createLayout } = require_struct_array();
      var layout = createLayout(
        [
          { name: "a_pos", components: 2, type: "Int16" },
          { name: "a_normal_ed", components: 4, type: "Int16" }
        ],
        4
      );
      module.exports = layout;
    }
  });

  // node_modules/@mapwhit/vector-tile/lib/vectortilefeature.js
  var require_vectortilefeature = __commonJS({
    "node_modules/@mapwhit/vector-tile/lib/vectortilefeature.js"(exports, module) {
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      var VectorTileFeature = class _VectorTileFeature {
        static types = ["Unknown", "Point", "LineString", "Polygon"];
        constructor(pbf, end, extent, keys, values) {
          this.properties = {};
          this.extent = extent;
          this.type = 0;
          this._pbf = pbf;
          this._geometry = -1;
          this._keys = keys;
          this._values = values;
          pbf.readFields(readFeature, this, end);
        }
        loadGeometry() {
          const pbf = this._pbf;
          pbf.pos = this._geometry;
          const end = pbf.readVarint() + pbf.pos;
          let cmd = 1;
          let length = 0;
          let x = 0;
          let y = 0;
          const lines = [];
          let line;
          while (pbf.pos < end) {
            if (length <= 0) {
              const cmdLen = pbf.readVarint();
              cmd = cmdLen & 7;
              length = cmdLen >> 3;
            }
            length--;
            if (cmd === 1 || cmd === 2) {
              x += pbf.readSVarint();
              y += pbf.readSVarint();
              if (cmd === 1) {
                if (line) lines.push(line);
                line = [];
              }
              line.push(new Point3(x, y));
            } else if (cmd === 7) {
              if (line) {
                line.push(line[0].clone());
              }
            } else {
              throw new Error(`unknown command ${cmd}`);
            }
          }
          if (line) lines.push(line);
          return lines;
        }
        bbox() {
          const pbf = this._pbf;
          pbf.pos = this._geometry;
          const end = pbf.readVarint() + pbf.pos;
          let cmd = 1;
          let length = 0;
          let x = 0;
          let y = 0;
          let x1 = Number.POSITIVE_INFINITY;
          let x2 = Number.NEGATIVE_INFINITY;
          let y1 = Number.POSITIVE_INFINITY;
          let y2 = Number.NEGATIVE_INFINITY;
          while (pbf.pos < end) {
            if (length <= 0) {
              const cmdLen = pbf.readVarint();
              cmd = cmdLen & 7;
              length = cmdLen >> 3;
            }
            length--;
            if (cmd === 1 || cmd === 2) {
              x += pbf.readSVarint();
              y += pbf.readSVarint();
              if (x < x1) x1 = x;
              if (x > x2) x2 = x;
              if (y < y1) y1 = y;
              if (y > y2) y2 = y;
            } else if (cmd !== 7) {
              throw new Error(`unknown command ${cmd}`);
            }
          }
          return [x1, y1, x2, y2];
        }
        toGeoJSON(x, y, z) {
          const size = this.extent * 2 ** z;
          const x0 = this.extent * x;
          const y0 = this.extent * y;
          let coords = this.loadGeometry();
          let type = _VectorTileFeature.types[this.type];
          function project(line) {
            for (let j = 0; j < line.length; j++) {
              const p = line[j];
              const y2 = 180 - (p.y + y0) * 360 / size;
              line[j] = [(p.x + x0) * 360 / size - 180, 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1: {
              const points = [];
              for (let i = 0; i < coords.length; i++) {
                points[i] = coords[i][0];
              }
              coords = points;
              project(coords);
              break;
            }
            case 2:
              for (let i = 0; i < coords.length; i++) {
                project(coords[i]);
              }
              break;
            case 3:
              coords = classifyRings(coords);
              for (let i = 0; i < coords.length; i++) {
                for (let j = 0; j < coords[i].length; j++) {
                  project(coords[i][j]);
                }
              }
              break;
          }
          if (coords.length === 1) {
            coords = coords[0];
          } else {
            type = `Multi${type}`;
          }
          const result = {
            type: "Feature",
            geometry: {
              type,
              coordinates: coords
            },
            properties: this.properties
          };
          if ("id" in this) {
            result.id = this.id;
          }
          return result;
        }
      };
      module.exports = VectorTileFeature;
      function readFeature(tag, feature, pbf) {
        switch (tag) {
          case 1:
            feature.id = pbf.readVarint();
            break;
          case 2:
            {
              const end = pbf.readVarint() + pbf.pos;
              while (pbf.pos < end) {
                const key = feature._keys[pbf.readVarint()];
                const value = feature._values[pbf.readVarint()];
                feature.properties[key] = value;
              }
            }
            break;
          case 3:
            feature.type = pbf.readVarint();
            break;
          case 4:
            feature._geometry = pbf.pos;
            break;
        }
      }
      function classifyRings(rings) {
        const len = rings.length;
        if (len <= 1) return [rings];
        const polygons = [];
        let polygon;
        let ccw;
        for (let i = 0; i < len; i++) {
          const area2 = signedArea2(rings[i]);
          if (area2 === 0) continue;
          ccw ??= area2 < 0;
          if (ccw === area2 < 0) {
            if (polygon) polygons.push(polygon);
            polygon = [rings[i]];
          } else {
            polygon.push(rings[i]);
          }
        }
        if (polygon) polygons.push(polygon);
        return polygons;
      }
      function signedArea2(ring) {
        let sum = 0;
        let to = ring.at(-1);
        for (const from of ring) {
          sum += (to.x - from.x) * (from.y + to.y);
          to = from;
        }
        return sum;
      }
    }
  });

  // node_modules/@mapwhit/vector-tile/lib/vectortilelayer.js
  var require_vectortilelayer = __commonJS({
    "node_modules/@mapwhit/vector-tile/lib/vectortilelayer.js"(exports, module) {
      var VectorTileFeature = require_vectortilefeature();
      var VectorTileLayer = class {
        constructor(pbf, end) {
          this.version = 1;
          this.name = null;
          this.extent = 4096;
          this.length = 0;
          this._pbf = pbf;
          this._keys = [];
          this._values = [];
          this._features = [];
          pbf.readFields(readLayer, this, end);
          this.length = this._features.length;
        }
        // return feature `i` from this layer as a `VectorTileFeature`
        feature(i) {
          if (i < 0 || i >= this._features.length) throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[i];
          const end = this._pbf.readVarint() + this._pbf.pos;
          return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
        }
      };
      module.exports = VectorTileLayer;
      function readLayer(tag, layer, pbf) {
        switch (tag) {
          case 1:
            layer.name = pbf.readString();
            break;
          case 5:
            layer.extent = pbf.readVarint();
            break;
          case 2:
            layer._features.push(pbf.pos);
            break;
          case 3:
            layer._keys.push(pbf.readString());
            break;
          case 4:
            layer._values.push(readValueMessage(pbf));
            break;
          case 15:
            layer.version = pbf.readVarint();
            break;
        }
      }
      function readValueMessage(pbf) {
        let value = null;
        const end = pbf.readVarint() + pbf.pos;
        while (pbf.pos < end) {
          switch (pbf.readVarint() >> 3) {
            case 1:
              value = pbf.readString();
              break;
            case 2:
              value = pbf.readFloat();
              break;
            case 3:
              value = pbf.readDouble();
              break;
            case 4:
              value = pbf.readVarint64();
              break;
            case 5:
              value = pbf.readVarint();
              break;
            case 6:
              value = pbf.readSVarint();
              break;
            case 7:
              value = pbf.readBoolean();
              break;
            default:
              value = null;
          }
        }
        return value;
      }
    }
  });

  // node_modules/@mapwhit/vector-tile/lib/vectortile.js
  var require_vectortile = __commonJS({
    "node_modules/@mapwhit/vector-tile/lib/vectortile.js"(exports, module) {
      var VectorTileLayer = require_vectortilelayer();
      module.exports = VectorTile;
      function VectorTile(pbf, end) {
        this.layers = pbf.readFields(readTile, {}, end);
      }
      function readTile(tag, layers, pbf) {
        if (tag === 3) {
          const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
          if (layer.length) layers[layer.name] = layer;
        }
      }
    }
  });

  // node_modules/@mapwhit/vector-tile/index.js
  var require_vector_tile = __commonJS({
    "node_modules/@mapwhit/vector-tile/index.js"(exports, module) {
      module.exports.VectorTile = require_vectortile();
      module.exports.VectorTileFeature = require_vectortilefeature();
      module.exports.VectorTileLayer = require_vectortilelayer();
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/bucket/fill_extrusion_bucket.js
  var require_fill_extrusion_bucket = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/bucket/fill_extrusion_bucket.js"(exports, module) {
      var { FillExtrusionLayoutArray } = require_array_types();
      var { members: layoutAttributes } = require_fill_extrusion_attributes();
      var SegmentVector = require_segment();
      var { ProgramConfigurationSet } = require_program_configuration();
      var { TriangleIndexArray } = require_index_array_type();
      var EXTENT = require_extent();
      var { default: earcut2 } = (init_earcut(), __toCommonJS(earcut_exports));
      var {
        VectorTileFeature: { types: vectorTileFeatureTypes }
      } = require_vector_tile();
      var classifyRings = require_classify_rings();
      var assert = require_nanoassert();
      var EARCUT_MAX_RINGS = 500;
      var { register } = require_transfer_registry();
      var { hasPattern, addPatternDependencies } = require_pattern_bucket_features();
      var loadGeometry = require_load_geometry();
      var EvaluationParameters = require_evaluation_parameters();
      var FACTOR = 2 ** 13;
      function addVertex(vertexArray, x, y, nx, ny, nz, t, e) {
        vertexArray.emplaceBack(
          // a_pos
          x,
          y,
          // a_normal_ed: 3-component normal and 1-component edgedistance
          Math.floor(nx * FACTOR) * 2 + t,
          ny * FACTOR * 2,
          nz * FACTOR * 2,
          // edgedistance (used for wrapping patterns around extrusion sides)
          Math.round(e)
        );
      }
      var FillExtrusionBucket = class {
        constructor(options) {
          this.zoom = options.zoom;
          this.overscaling = options.overscaling;
          this.layers = options.layers;
          this.layerIds = this.layers.map((layer) => layer.id);
          this.index = options.index;
          this.hasPattern = false;
          this.layoutVertexArray = new FillExtrusionLayoutArray();
          this.indexArray = new TriangleIndexArray();
          this.programConfigurations = new ProgramConfigurationSet(layoutAttributes, options.layers, options.zoom);
          this.segments = new SegmentVector();
        }
        populate(features, options) {
          this.features = [];
          this.hasPattern = hasPattern("fill-extrusion", this.layers, options);
          for (const { feature, index, sourceLayerIndex } of features) {
            if (!this.layers[0]._featureFilter(new EvaluationParameters(this.zoom), feature)) continue;
            const geometry = loadGeometry(feature);
            const patternFeature = {
              sourceLayerIndex,
              index,
              geometry,
              properties: feature.properties,
              type: feature.type,
              patterns: {}
            };
            if (typeof feature.id !== "undefined") {
              patternFeature.id = feature.id;
            }
            if (this.hasPattern) {
              this.features.push(addPatternDependencies("fill-extrusion", this.layers, patternFeature, this.zoom, options));
            } else {
              this.addFeature(patternFeature, geometry, index, {});
            }
            options.featureIndex.insert(feature, geometry, index, sourceLayerIndex, this.index, true);
          }
        }
        addFeatures(options, imagePositions) {
          for (const feature of this.features) {
            const { geometry } = feature;
            this.addFeature(feature, geometry, feature.index, imagePositions);
          }
        }
        update(states, vtLayer, imagePositions) {
          if (!this.stateDependentLayers.length) return;
          this.programConfigurations.updatePaintArrays(states, vtLayer, this.stateDependentLayers, imagePositions);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(context) {
          if (!this.uploaded) {
            this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, layoutAttributes);
            this.indexBuffer = context.createIndexBuffer(this.indexArray);
          }
          this.programConfigurations.upload(context);
          this.uploaded = true;
        }
        destroy() {
          if (!this.layoutVertexBuffer) return;
          this.layoutVertexBuffer.destroy();
          this.indexBuffer.destroy();
          this.programConfigurations.destroy();
          this.segments.destroy();
        }
        addFeature(feature, geometry, index, imagePositions) {
          for (const polygon of classifyRings(geometry, EARCUT_MAX_RINGS)) {
            let numVertices = 0;
            for (const ring of polygon) {
              numVertices += ring.length;
            }
            let segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
            for (const ring of polygon) {
              if (ring.length === 0) {
                continue;
              }
              if (isEntirelyOutside(ring)) {
                continue;
              }
              let edgeDistance = 0;
              for (let p = 0; p < ring.length; p++) {
                const p1 = ring[p];
                if (p >= 1) {
                  const p2 = ring[p - 1];
                  if (!isBoundaryEdge(p1, p2)) {
                    if (segment.vertexLength + 4 > SegmentVector.MAX_VERTEX_ARRAY_LENGTH) {
                      segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
                    }
                    const perp = p1.sub(p2)._perp()._unit();
                    const dist = p2.dist(p1);
                    if (edgeDistance + dist > 32768) edgeDistance = 0;
                    addVertex(this.layoutVertexArray, p1.x, p1.y, perp.x, perp.y, 0, 0, edgeDistance);
                    addVertex(this.layoutVertexArray, p1.x, p1.y, perp.x, perp.y, 0, 1, edgeDistance);
                    edgeDistance += dist;
                    addVertex(this.layoutVertexArray, p2.x, p2.y, perp.x, perp.y, 0, 0, edgeDistance);
                    addVertex(this.layoutVertexArray, p2.x, p2.y, perp.x, perp.y, 0, 1, edgeDistance);
                    const bottomRight = segment.vertexLength;
                    this.indexArray.emplaceBack(bottomRight, bottomRight + 2, bottomRight + 1);
                    this.indexArray.emplaceBack(bottomRight + 1, bottomRight + 2, bottomRight + 3);
                    segment.vertexLength += 4;
                    segment.primitiveLength += 2;
                  }
                }
              }
            }
            if (segment.vertexLength + numVertices > SegmentVector.MAX_VERTEX_ARRAY_LENGTH) {
              segment = this.segments.prepareSegment(numVertices, this.layoutVertexArray, this.indexArray);
            }
            if (vectorTileFeatureTypes[feature.type] !== "Polygon") {
              continue;
            }
            const flattened = [];
            const holeIndices = [];
            const triangleIndex = segment.vertexLength;
            for (const ring of polygon) {
              if (ring.length === 0) {
                continue;
              }
              if (ring !== polygon[0]) {
                holeIndices.push(flattened.length / 2);
              }
              for (let i = 0; i < ring.length; i++) {
                const p = ring[i];
                addVertex(this.layoutVertexArray, p.x, p.y, 0, 0, 1, 1, 0);
                flattened.push(p.x);
                flattened.push(p.y);
              }
            }
            const indices = earcut2(flattened, holeIndices);
            assert(indices.length % 3 === 0);
            for (let j = 0; j < indices.length; j += 3) {
              this.indexArray.emplaceBack(
                triangleIndex + indices[j],
                triangleIndex + indices[j + 2],
                triangleIndex + indices[j + 1]
              );
            }
            segment.primitiveLength += indices.length / 3;
            segment.vertexLength += numVertices;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, feature, index, imagePositions);
        }
      };
      register("FillExtrusionBucket", FillExtrusionBucket, { omit: ["layers", "features"] });
      module.exports = FillExtrusionBucket;
      function isBoundaryEdge(p1, p2) {
        return p1.x === p2.x && (p1.x < 0 || p1.x > EXTENT) || p1.y === p2.y && (p1.y < 0 || p1.y > EXTENT);
      }
      function isEntirelyOutside(ring) {
        return ring.every((p) => p.x < 0) || ring.every((p) => p.x > EXTENT) || ring.every((p) => p.y < 0) || ring.every((p) => p.y > EXTENT);
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/fill_extrusion_style_layer_properties.js
  var require_fill_extrusion_style_layer_properties = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/fill_extrusion_style_layer_properties.js"(exports, module) {
      var { Properties, CrossFadedDataDrivenProperty, DataConstantProperty, DataDrivenProperty } = require_properties2();
      var paint = new Properties({
        "fill-extrusion-opacity": new DataConstantProperty({
          type: "number",
          default: 1,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "fill-extrusion-color": new DataDrivenProperty({
          type: "color",
          default: "#000000",
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "fill-extrusion-translate": new DataConstantProperty({
          type: "array",
          value: "number",
          length: 2,
          default: [0, 0],
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "fill-extrusion-translate-anchor": new DataConstantProperty({
          type: "enum",
          values: ["map", "viewport"],
          default: "map",
          expression: { parameters: ["zoom"] }
        }),
        "fill-extrusion-pattern": new CrossFadedDataDrivenProperty({
          type: "string",
          transition: true,
          expression: { parameters: ["zoom", "feature"] }
        }),
        "fill-extrusion-height": new DataDrivenProperty({
          type: "number",
          default: 0,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "fill-extrusion-base": new DataDrivenProperty({
          type: "number",
          default: 0,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "fill-extrusion-vertical-gradient": new DataConstantProperty({
          type: "boolean",
          default: true,
          expression: { parameters: ["zoom"] }
        })
      });
      module.exports = { paint };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/fill_extrusion_style_layer.js
  var require_fill_extrusion_style_layer = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/fill_extrusion_style_layer.js"(exports, module) {
      var StyleLayer = require_style_layer();
      var FillExtrusionBucket = require_fill_extrusion_bucket();
      var { polygonIntersectsPolygon, polygonIntersectsMultiPolygon } = require_intersection_tests();
      var { translateDistance, translate } = require_query_utils();
      var properties = require_fill_extrusion_style_layer_properties();
      var { vec4 } = require_gl_matrix();
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      var FillExtrusionStyleLayer = class extends StyleLayer {
        constructor(layer) {
          super(layer, properties);
        }
        createBucket(parameters) {
          return new FillExtrusionBucket(parameters);
        }
        queryRadius() {
          return translateDistance(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return true;
        }
        queryIntersectsFeature(queryGeometry, feature, featureState, geometry, zoom, transform, pixelsToTileUnits, pixelPosMatrix) {
          const translatedPolygon = translate(
            queryGeometry,
            this.paint.get("fill-extrusion-translate"),
            this.paint.get("fill-extrusion-translate-anchor"),
            transform.angle,
            pixelsToTileUnits
          );
          const height = this.paint.get("fill-extrusion-height").evaluate(feature, featureState);
          const base = this.paint.get("fill-extrusion-base").evaluate(feature, featureState);
          const projectedQueryGeometry = projectQueryGeometry(translatedPolygon, pixelPosMatrix, transform, 0);
          const projected = projectExtrusion(geometry, base, height, pixelPosMatrix);
          const projectedBase = projected[0];
          const projectedTop = projected[1];
          return checkIntersection(projectedBase, projectedTop, projectedQueryGeometry);
        }
      };
      function dot(a, b) {
        return a.x * b.x + a.y * b.y;
      }
      function getIntersectionDistance(projectedQueryGeometry, projectedFace) {
        if (projectedQueryGeometry.length === 1) {
          const a = projectedFace[0];
          const b = projectedFace[1];
          const c = projectedFace[3];
          const p = projectedQueryGeometry[0];
          const ab = b.sub(a);
          const ac = c.sub(a);
          const ap = p.sub(a);
          const dotABAB = dot(ab, ab);
          const dotABAC = dot(ab, ac);
          const dotACAC = dot(ac, ac);
          const dotAPAB = dot(ap, ab);
          const dotAPAC = dot(ap, ac);
          const denom = dotABAB * dotACAC - dotABAC * dotABAC;
          const v = (dotACAC * dotAPAB - dotABAC * dotAPAC) / denom;
          const w = (dotABAB * dotAPAC - dotABAC * dotAPAB) / denom;
          const u = 1 - v - w;
          return a.z * u + b.z * v + c.z * w;
        }
        let closestDistance = Number.POSITIVE_INFINITY;
        for (const p of projectedFace) {
          closestDistance = Math.min(closestDistance, p.z);
        }
        return closestDistance;
      }
      function checkIntersection(projectedBase, projectedTop, projectedQueryGeometry) {
        let closestDistance = Number.POSITIVE_INFINITY;
        if (polygonIntersectsMultiPolygon(projectedQueryGeometry, projectedTop)) {
          closestDistance = getIntersectionDistance(projectedQueryGeometry, projectedTop[0]);
        }
        for (let r = 0; r < projectedTop.length; r++) {
          const ringTop = projectedTop[r];
          const ringBase = projectedBase[r];
          for (let p = 0; p < ringTop.length - 1; p++) {
            const topA = ringTop[p];
            const topB = ringTop[p + 1];
            const baseA = ringBase[p];
            const baseB = ringBase[p + 1];
            const face = [topA, topB, baseB, baseA, topA];
            if (polygonIntersectsPolygon(projectedQueryGeometry, face)) {
              closestDistance = Math.min(closestDistance, getIntersectionDistance(projectedQueryGeometry, face));
            }
          }
        }
        return closestDistance === Number.POSITIVE_INFINITY ? false : closestDistance;
      }
      function projectExtrusion(geometry, zBase, zTop, m) {
        const projectedBase = [];
        const projectedTop = [];
        const baseXZ = m[8] * zBase;
        const baseYZ = m[9] * zBase;
        const baseZZ = m[10] * zBase;
        const baseWZ = m[11] * zBase;
        const topXZ = m[8] * zTop;
        const topYZ = m[9] * zTop;
        const topZZ = m[10] * zTop;
        const topWZ = m[11] * zTop;
        for (const r of geometry) {
          const ringBase = [];
          const ringTop = [];
          for (const p of r) {
            const x = p.x;
            const y = p.y;
            const sX = m[0] * x + m[4] * y + m[12];
            const sY = m[1] * x + m[5] * y + m[13];
            const sZ = m[2] * x + m[6] * y + m[14];
            const sW = m[3] * x + m[7] * y + m[15];
            const baseX = sX + baseXZ;
            const baseY = sY + baseYZ;
            const baseZ = sZ + baseZZ;
            const baseW = sW + baseWZ;
            const topX = sX + topXZ;
            const topY = sY + topYZ;
            const topZ = sZ + topZZ;
            const topW = sW + topWZ;
            const b = new Point3(baseX / baseW, baseY / baseW);
            b.z = baseZ / baseW;
            ringBase.push(b);
            const t = new Point3(topX / topW, topY / topW);
            t.z = topZ / topW;
            ringTop.push(t);
          }
          projectedBase.push(ringBase);
          projectedTop.push(ringTop);
        }
        return [projectedBase, projectedTop];
      }
      function projectQueryGeometry(queryGeometry, pixelPosMatrix, transform, z) {
        const projectedQueryGeometry = [];
        for (const p of queryGeometry) {
          const v = [p.x, p.y, z, 1];
          vec4.transformMat4(v, v, pixelPosMatrix);
          projectedQueryGeometry.push(new Point3(v[0] / v[3], v[1] / v[3]));
        }
        return projectedQueryGeometry;
      }
      module.exports = FillExtrusionStyleLayer;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/bucket/line_attributes.js
  var require_line_attributes = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/bucket/line_attributes.js"(exports, module) {
      var { createLayout } = require_struct_array();
      var layout = createLayout(
        [
          { name: "a_pos_normal", components: 4, type: "Int16" },
          { name: "a_data", components: 4, type: "Uint8" }
        ],
        4
      );
      module.exports = layout;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/bucket/line_bucket.js
  var require_line_bucket = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/bucket/line_bucket.js"(exports, module) {
      var { LineLayoutArray } = require_array_types();
      var { members: layoutAttributes } = require_line_attributes();
      var SegmentVector = require_segment();
      var { ProgramConfigurationSet } = require_program_configuration();
      var { TriangleIndexArray } = require_index_array_type();
      var EXTENT = require_extent();
      var mvt = require_vector_tile();
      var vectorTileFeatureTypes = mvt.VectorTileFeature.types;
      var { register } = require_transfer_registry();
      var { hasPattern, addPatternDependencies } = require_pattern_bucket_features();
      var loadGeometry = require_load_geometry();
      var EvaluationParameters = require_evaluation_parameters();
      var EXTRUDE_SCALE = 63;
      var COS_HALF_SHARP_CORNER = Math.cos(75 / 2 * (Math.PI / 180));
      var SHARP_CORNER_OFFSET = 15;
      var LINE_DISTANCE_BUFFER_BITS = 15;
      var LINE_DISTANCE_SCALE = 1 / 2;
      var MAX_LINE_DISTANCE = 2 ** (LINE_DISTANCE_BUFFER_BITS - 1) / LINE_DISTANCE_SCALE;
      function addLineVertex(layoutVertexBuffer, point, extrude, round, up, dir, linesofar) {
        layoutVertexBuffer.emplaceBack(
          // a_pos_normal
          point.x,
          point.y,
          round ? 1 : 0,
          up ? 1 : -1,
          // a_data
          // add 128 to store a byte in an unsigned byte
          Math.round(EXTRUDE_SCALE * extrude.x) + 128,
          Math.round(EXTRUDE_SCALE * extrude.y) + 128,
          // Encode the -1/0/1 direction value into the first two bits of .z of a_data.
          // Combine it with the lower 6 bits of `linesofar` (shifted by 2 bites to make
          // room for the direction value). The upper 8 bits of `linesofar` are placed in
          // the `w` component. `linesofar` is scaled down by `LINE_DISTANCE_SCALE` so that
          // we can store longer distances while sacrificing precision.
          (dir === 0 ? 0 : dir < 0 ? -1 : 1) + 1 | (linesofar * LINE_DISTANCE_SCALE & 63) << 2,
          linesofar * LINE_DISTANCE_SCALE >> 6
        );
      }
      var LineBucket = class {
        constructor(options) {
          this.zoom = options.zoom;
          this.overscaling = options.overscaling;
          this.layers = options.layers;
          this.layerIds = this.layers.map((layer) => layer.id);
          this.index = options.index;
          this.features = [];
          this.hasPattern = false;
          this.layoutVertexArray = new LineLayoutArray();
          this.indexArray = new TriangleIndexArray();
          this.programConfigurations = new ProgramConfigurationSet(layoutAttributes, options.layers, options.zoom);
          this.segments = new SegmentVector();
        }
        populate(features, options) {
          this.features = [];
          this.hasPattern = hasPattern("line", this.layers, options);
          for (const { feature, index, sourceLayerIndex } of features) {
            if (!this.layers[0]._featureFilter(new EvaluationParameters(this.zoom), feature)) continue;
            const geometry = loadGeometry(feature);
            const patternFeature = {
              sourceLayerIndex,
              index,
              geometry,
              properties: feature.properties,
              type: feature.type,
              patterns: {}
            };
            if (typeof feature.id !== "undefined") {
              patternFeature.id = feature.id;
            }
            if (this.hasPattern) {
              this.features.push(addPatternDependencies("line", this.layers, patternFeature, this.zoom, options));
            } else {
              this.addFeature(patternFeature, geometry, index, {});
            }
            options.featureIndex.insert(feature, geometry, index, sourceLayerIndex, this.index);
          }
        }
        update(states, vtLayer, imagePositions) {
          if (!this.stateDependentLayers.length) return;
          this.programConfigurations.updatePaintArrays(states, vtLayer, this.stateDependentLayers, imagePositions);
        }
        addFeatures(options, imagePositions) {
          for (const feature of this.features) {
            const { geometry } = feature;
            this.addFeature(feature, geometry, feature.index, imagePositions);
          }
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(context) {
          if (!this.uploaded) {
            this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, layoutAttributes);
            this.indexBuffer = context.createIndexBuffer(this.indexArray);
          }
          this.programConfigurations.upload(context);
          this.uploaded = true;
        }
        destroy() {
          if (!this.layoutVertexBuffer) return;
          this.layoutVertexBuffer.destroy();
          this.indexBuffer.destroy();
          this.programConfigurations.destroy();
          this.segments.destroy();
        }
        addFeature(feature, geometry, index, imagePositions) {
          const layout = this.layers[0].layout;
          const join = layout.get("line-join").evaluate(feature, {});
          const cap = layout.get("line-cap");
          const miterLimit = layout.get("line-miter-limit");
          const roundLimit = layout.get("line-round-limit");
          for (const line of geometry) {
            this.addLine(line, feature, join, cap, miterLimit, roundLimit, index, imagePositions);
          }
        }
        addLine(vertices, feature, join, cap, miterLimit, roundLimit, index, imagePositions) {
          let lineDistances = null;
          if (!!feature.properties && feature.properties.hasOwnProperty("mapbox_clip_start") && feature.properties.hasOwnProperty("mapbox_clip_end")) {
            lineDistances = {
              start: feature.properties.mapbox_clip_start,
              end: feature.properties.mapbox_clip_end,
              tileTotal: void 0
            };
          }
          const isPolygon = vectorTileFeatureTypes[feature.type] === "Polygon";
          let len = vertices.length;
          while (len >= 2 && vertices[len - 1].equals(vertices[len - 2])) {
            len--;
          }
          let first = 0;
          while (first < len - 1 && vertices[first].equals(vertices[first + 1])) {
            first++;
          }
          if (len < (isPolygon ? 3 : 2)) return;
          if (lineDistances) {
            lineDistances.tileTotal = calculateFullDistance(vertices, first, len);
          }
          if (join === "bevel") miterLimit = 1.05;
          const sharpCornerOffset = SHARP_CORNER_OFFSET * (EXTENT / (512 * this.overscaling));
          const firstVertex = vertices[first];
          const segment = this.segments.prepareSegment(len * 10, this.layoutVertexArray, this.indexArray);
          this.distance = 0;
          const beginCap = cap;
          const endCap = isPolygon ? "butt" : cap;
          let startOfLine = true;
          let currentVertex;
          let prevVertex;
          let nextVertex;
          let prevNormal;
          let nextNormal;
          let offsetA;
          let offsetB;
          this.e1 = this.e2 = this.e3 = -1;
          if (isPolygon) {
            currentVertex = vertices[len - 2];
            nextNormal = firstVertex.sub(currentVertex)._unit()._perp();
          }
          for (let i = first; i < len; i++) {
            nextVertex = isPolygon && i === len - 1 ? vertices[first + 1] : (
              // if the line is closed, we treat the last vertex like the first
              vertices[i + 1]
            );
            if (nextVertex && vertices[i].equals(nextVertex)) continue;
            if (nextNormal) prevNormal = nextNormal;
            if (currentVertex) prevVertex = currentVertex;
            currentVertex = vertices[i];
            nextNormal = nextVertex ? nextVertex.sub(currentVertex)._unit()._perp() : prevNormal;
            prevNormal = prevNormal || nextNormal;
            let joinNormal = prevNormal.add(nextNormal);
            if (joinNormal.x !== 0 || joinNormal.y !== 0) {
              joinNormal._unit();
            }
            const cosHalfAngle = joinNormal.x * nextNormal.x + joinNormal.y * nextNormal.y;
            const miterLength = cosHalfAngle !== 0 ? 1 / cosHalfAngle : Number.POSITIVE_INFINITY;
            const isSharpCorner = cosHalfAngle < COS_HALF_SHARP_CORNER && prevVertex && nextVertex;
            if (isSharpCorner && i > first) {
              const prevSegmentLength = currentVertex.dist(prevVertex);
              if (prevSegmentLength > 2 * sharpCornerOffset) {
                const newPrevVertex = currentVertex.sub(
                  currentVertex.sub(prevVertex)._mult(sharpCornerOffset / prevSegmentLength)._round()
                );
                this.distance += newPrevVertex.dist(prevVertex);
                this.addCurrentVertex(newPrevVertex, this.distance, prevNormal.mult(1), 0, 0, false, segment, lineDistances);
                prevVertex = newPrevVertex;
              }
            }
            const middleVertex = prevVertex && nextVertex;
            let currentJoin = middleVertex ? join : nextVertex ? beginCap : endCap;
            if (middleVertex && currentJoin === "round") {
              if (miterLength < roundLimit) {
                currentJoin = "miter";
              } else if (miterLength <= 2) {
                currentJoin = "fakeround";
              }
            }
            if (currentJoin === "miter" && miterLength > miterLimit) {
              currentJoin = "bevel";
            }
            if (currentJoin === "bevel") {
              if (miterLength > 2) currentJoin = "flipbevel";
              if (miterLength < miterLimit) currentJoin = "miter";
            }
            if (prevVertex) this.distance += currentVertex.dist(prevVertex);
            if (currentJoin === "miter") {
              joinNormal._mult(miterLength);
              this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false, segment, lineDistances);
            } else if (currentJoin === "flipbevel") {
              if (miterLength > 100) {
                joinNormal = nextNormal.clone().mult(-1);
              } else {
                const direction = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x > 0 ? -1 : 1;
                const bevelLength = miterLength * prevNormal.add(nextNormal).mag() / prevNormal.sub(nextNormal).mag();
                joinNormal._perp()._mult(bevelLength * direction);
              }
              this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false, segment, lineDistances);
              this.addCurrentVertex(currentVertex, this.distance, joinNormal.mult(-1), 0, 0, false, segment, lineDistances);
            } else if (currentJoin === "bevel" || currentJoin === "fakeround") {
              const lineTurnsLeft = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x > 0;
              const offset = -Math.sqrt(miterLength * miterLength - 1);
              if (lineTurnsLeft) {
                offsetB = 0;
                offsetA = offset;
              } else {
                offsetA = 0;
                offsetB = offset;
              }
              if (!startOfLine) {
                this.addCurrentVertex(
                  currentVertex,
                  this.distance,
                  prevNormal,
                  offsetA,
                  offsetB,
                  false,
                  segment,
                  lineDistances
                );
              }
              if (currentJoin === "fakeround") {
                const n = Math.floor((0.5 - (cosHalfAngle - 0.5)) * 8);
                let approxFractionalJoinNormal;
                for (let m = 0; m < n; m++) {
                  approxFractionalJoinNormal = nextNormal.mult((m + 1) / (n + 1))._add(prevNormal)._unit();
                  this.addPieSliceVertex(
                    currentVertex,
                    this.distance,
                    approxFractionalJoinNormal,
                    lineTurnsLeft,
                    segment,
                    lineDistances
                  );
                }
                this.addPieSliceVertex(currentVertex, this.distance, joinNormal, lineTurnsLeft, segment, lineDistances);
                for (let k = n - 1; k >= 0; k--) {
                  approxFractionalJoinNormal = prevNormal.mult((k + 1) / (n + 1))._add(nextNormal)._unit();
                  this.addPieSliceVertex(
                    currentVertex,
                    this.distance,
                    approxFractionalJoinNormal,
                    lineTurnsLeft,
                    segment,
                    lineDistances
                  );
                }
              }
              if (nextVertex) {
                this.addCurrentVertex(
                  currentVertex,
                  this.distance,
                  nextNormal,
                  -offsetA,
                  -offsetB,
                  false,
                  segment,
                  lineDistances
                );
              }
            } else if (currentJoin === "butt") {
              if (!startOfLine) {
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false, segment, lineDistances);
              }
              if (nextVertex) {
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false, segment, lineDistances);
              }
            } else if (currentJoin === "square") {
              if (!startOfLine) {
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, false, segment, lineDistances);
                this.e1 = this.e2 = -1;
              }
              if (nextVertex) {
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, false, segment, lineDistances);
              }
            } else if (currentJoin === "round") {
              if (!startOfLine) {
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false, segment, lineDistances);
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, true, segment, lineDistances);
                this.e1 = this.e2 = -1;
              }
              if (nextVertex) {
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, true, segment, lineDistances);
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false, segment, lineDistances);
              }
            }
            if (isSharpCorner && i < len - 1) {
              const nextSegmentLength = currentVertex.dist(nextVertex);
              if (nextSegmentLength > 2 * sharpCornerOffset) {
                const newCurrentVertex = currentVertex.add(
                  nextVertex.sub(currentVertex)._mult(sharpCornerOffset / nextSegmentLength)._round()
                );
                this.distance += newCurrentVertex.dist(currentVertex);
                this.addCurrentVertex(
                  newCurrentVertex,
                  this.distance,
                  nextNormal.mult(1),
                  0,
                  0,
                  false,
                  segment,
                  lineDistances
                );
                currentVertex = newCurrentVertex;
              }
            }
            startOfLine = false;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, feature, index, imagePositions);
        }
        /**
         * Add two vertices to the buffers.
         *
         * @param {Object} currentVertex the line vertex to add buffer vertices for
         * @param {number} distance the distance from the beginning of the line to the vertex
         * @param {number} endLeft extrude to shift the left vertex along the line
         * @param {number} endRight extrude to shift the left vertex along the line
         * @param {boolean} round whether this is a round cap
         * @private
         */
        addCurrentVertex(currentVertex, distance, normal, endLeft, endRight, round, segment, distancesForScaling) {
          let extrude;
          const layoutVertexArray = this.layoutVertexArray;
          const indexArray = this.indexArray;
          if (distancesForScaling) {
            distance = scaleDistance(distance, distancesForScaling);
          }
          extrude = normal.clone();
          if (endLeft) extrude._sub(normal.perp()._mult(endLeft));
          addLineVertex(layoutVertexArray, currentVertex, extrude, round, false, endLeft, distance);
          this.e3 = segment.vertexLength++;
          if (this.e1 >= 0 && this.e2 >= 0) {
            indexArray.emplaceBack(this.e1, this.e2, this.e3);
            segment.primitiveLength++;
          }
          this.e1 = this.e2;
          this.e2 = this.e3;
          extrude = normal.mult(-1);
          if (endRight) extrude._sub(normal.perp()._mult(endRight));
          addLineVertex(layoutVertexArray, currentVertex, extrude, round, true, -endRight, distance);
          this.e3 = segment.vertexLength++;
          if (this.e1 >= 0 && this.e2 >= 0) {
            indexArray.emplaceBack(this.e1, this.e2, this.e3);
            segment.primitiveLength++;
          }
          this.e1 = this.e2;
          this.e2 = this.e3;
          if (distance > MAX_LINE_DISTANCE / 2 && !distancesForScaling) {
            this.distance = 0;
            this.addCurrentVertex(currentVertex, this.distance, normal, endLeft, endRight, round, segment);
          }
        }
        /**
         * Add a single new vertex and a triangle using two previous vertices.
         * This adds a pie slice triangle near a join to simulate round joins
         *
         * @param currentVertex the line vertex to add buffer vertices for
         * @param distance the distance from the beginning of the line to the vertex
         * @param extrude the offset of the new vertex from the currentVertex
         * @param lineTurnsLeft whether the line is turning left or right at this angle
         * @private
         */
        addPieSliceVertex(currentVertex, distance, extrude, lineTurnsLeft, segment, distancesForScaling) {
          extrude = extrude.mult(lineTurnsLeft ? -1 : 1);
          const layoutVertexArray = this.layoutVertexArray;
          const indexArray = this.indexArray;
          if (distancesForScaling) distance = scaleDistance(distance, distancesForScaling);
          addLineVertex(layoutVertexArray, currentVertex, extrude, false, lineTurnsLeft, 0, distance);
          this.e3 = segment.vertexLength++;
          if (this.e1 >= 0 && this.e2 >= 0) {
            indexArray.emplaceBack(this.e1, this.e2, this.e3);
            segment.primitiveLength++;
          }
          if (lineTurnsLeft) {
            this.e2 = this.e3;
          } else {
            this.e1 = this.e3;
          }
        }
      };
      function scaleDistance(tileDistance, stats) {
        return (tileDistance / stats.tileTotal * (stats.end - stats.start) + stats.start) * (MAX_LINE_DISTANCE - 1);
      }
      function calculateFullDistance(vertices, first, len) {
        let currentVertex;
        let nextVertex;
        let total = 0;
        for (let i = first; i < len - 1; i++) {
          currentVertex = vertices[i];
          nextVertex = vertices[i + 1];
          total += currentVertex.dist(nextVertex);
        }
        return total;
      }
      register("LineBucket", LineBucket, { omit: ["layers", "features"] });
      module.exports = LineBucket;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/line_style_layer_properties.js
  var require_line_style_layer_properties = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/line_style_layer_properties.js"(exports, module) {
      var {
        Properties,
        ColorRampProperty,
        CrossFadedDataDrivenProperty,
        CrossFadedProperty,
        DataConstantProperty,
        DataDrivenProperty
      } = require_properties2();
      var layout = new Properties({
        "line-cap": new DataConstantProperty({
          type: "enum",
          values: ["butt", "round", "square"],
          default: "butt",
          expression: { parameters: ["zoom"] }
        }),
        "line-join": new DataDrivenProperty({
          type: "enum",
          values: ["bevel", "round", "miter"],
          default: "miter",
          expression: { parameters: ["zoom", "feature"] }
        }),
        "line-miter-limit": new DataConstantProperty({
          type: "number",
          default: 2,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "line-round-limit": new DataConstantProperty({
          type: "number",
          default: 1.05,
          expression: { interpolated: true, parameters: ["zoom"] }
        })
      });
      var paint = new Properties({
        "line-opacity": new DataDrivenProperty({
          type: "number",
          default: 1,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "line-color": new DataDrivenProperty({
          type: "color",
          default: "#000000",
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "line-translate": new DataConstantProperty({
          type: "array",
          value: "number",
          length: 2,
          default: [0, 0],
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "line-translate-anchor": new DataConstantProperty({
          type: "enum",
          values: ["map", "viewport"],
          default: "map",
          expression: { parameters: ["zoom"] }
        }),
        "line-width": new DataDrivenProperty({
          type: "number",
          default: 1,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "line-gap-width": new DataDrivenProperty({
          type: "number",
          default: 0,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "line-offset": new DataDrivenProperty({
          type: "number",
          default: 0,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "line-blur": new DataDrivenProperty({
          type: "number",
          default: 0,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "line-dasharray": new CrossFadedProperty({
          type: "array",
          value: "number",
          transition: true,
          expression: { parameters: ["zoom"] }
        }),
        "line-pattern": new CrossFadedDataDrivenProperty({
          type: "string",
          transition: true,
          expression: { parameters: ["zoom", "feature"] }
        }),
        "line-gradient": new ColorRampProperty({
          type: "color",
          expression: { interpolated: true, parameters: ["line-progress"] }
        })
      });
      module.exports = { paint, layout };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/line_style_layer.js
  var require_line_style_layer = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/line_style_layer.js"(exports, module) {
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      var StyleLayer = require_style_layer();
      var LineBucket = require_line_bucket();
      var { polygonIntersectsBufferedMultiLine } = require_intersection_tests();
      var { getMaximumPaintValue, translateDistance, translate } = require_query_utils();
      var properties = require_line_style_layer_properties();
      var EvaluationParameters = require_evaluation_parameters();
      var renderColorRamp = require_color_ramp();
      var { DataDrivenProperty } = require_properties2();
      var LineFloorwidthProperty = class extends DataDrivenProperty {
        possiblyEvaluate(value, parameters) {
          parameters = new EvaluationParameters(Math.floor(parameters.zoom), {
            now: parameters.now,
            fadeDuration: parameters.fadeDuration,
            zoomHistory: parameters.zoomHistory,
            transition: parameters.transition
          });
          return super.possiblyEvaluate(value, parameters);
        }
        evaluate(value, globals, feature, featureState) {
          globals = Object.assign({}, globals, { zoom: Math.floor(globals.zoom) });
          return super.evaluate(value, globals, feature, featureState);
        }
      };
      var lineFloorwidthProperty = new LineFloorwidthProperty(properties.paint.properties["line-width"].specification);
      lineFloorwidthProperty.useIntegerZoom = true;
      var LineStyleLayer = class extends StyleLayer {
        constructor(layer) {
          super(layer, properties);
        }
        _handleSpecialPaintPropertyUpdate(name) {
          if (name === "line-gradient") {
            this._updateGradient();
          }
        }
        _updateGradient() {
          const expression = this._transitionablePaint._values["line-gradient"].value.expression;
          this.gradient = renderColorRamp(expression, "lineProgress");
          this.gradientTexture = null;
        }
        recalculate(parameters) {
          super.recalculate(parameters);
          this.paint._values["line-floorwidth"] = lineFloorwidthProperty.possiblyEvaluate(
            this._transitioningPaint._values["line-width"].value,
            parameters
          );
        }
        createBucket(parameters) {
          return new LineBucket(parameters);
        }
        queryRadius(bucket) {
          const lineBucket = bucket;
          const width = getLineWidth(
            getMaximumPaintValue("line-width", this, lineBucket),
            getMaximumPaintValue("line-gap-width", this, lineBucket)
          );
          const offset = getMaximumPaintValue("line-offset", this, lineBucket);
          return width / 2 + Math.abs(offset) + translateDistance(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(queryGeometry, feature, featureState, geometry, zoom, transform, pixelsToTileUnits) {
          const translatedPolygon = translate(
            queryGeometry,
            this.paint.get("line-translate"),
            this.paint.get("line-translate-anchor"),
            transform.angle,
            pixelsToTileUnits
          );
          const halfWidth = pixelsToTileUnits / 2 * getLineWidth(
            this.paint.get("line-width").evaluate(feature, featureState),
            this.paint.get("line-gap-width").evaluate(feature, featureState)
          );
          const lineOffset = this.paint.get("line-offset").evaluate(feature, featureState);
          if (lineOffset) {
            geometry = offsetLine(geometry, lineOffset * pixelsToTileUnits);
          }
          return polygonIntersectsBufferedMultiLine(translatedPolygon, geometry, halfWidth);
        }
        isTileClipped() {
          return true;
        }
      };
      module.exports = LineStyleLayer;
      function getLineWidth(lineWidth, lineGapWidth) {
        if (lineGapWidth > 0) {
          return lineGapWidth + 2 * lineWidth;
        }
        return lineWidth;
      }
      function offsetLine(rings, offset) {
        const newRings = [];
        const zero = new Point3(0, 0);
        for (let k = 0; k < rings.length; k++) {
          const ring = rings[k];
          const newRing = [];
          for (let i = 0; i < ring.length; i++) {
            const a = ring[i - 1];
            const b = ring[i];
            const c = ring[i + 1];
            const aToB = i === 0 ? zero : b.sub(a)._unit()._perp();
            const bToC = i === ring.length - 1 ? zero : c.sub(b)._unit()._perp();
            const extrude = aToB._add(bToC)._unit();
            const cosHalfAngle = extrude.x * bToC.x + extrude.y * bToC.y;
            extrude._mult(1 / cosHalfAngle);
            newRing.push(extrude._mult(offset)._add(b));
          }
          newRings.push(newRing);
        }
        return newRings;
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/bucket/symbol_attributes.js
  var require_symbol_attributes = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/bucket/symbol_attributes.js"(exports, module) {
      var { createLayout } = require_struct_array();
      var symbolLayoutAttributes = createLayout([
        { name: "a_pos_offset", components: 4, type: "Int16" },
        { name: "a_data", components: 4, type: "Uint16" }
      ]);
      var dynamicLayoutAttributes = createLayout([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      var placementOpacityAttributes = createLayout([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      var collisionVertexAttributes = createLayout([{ name: "a_placed", components: 2, type: "Uint8" }], 4);
      var collisionBox = createLayout([
        // the box is centered around the anchor point
        { type: "Int16", name: "anchorPointX" },
        { type: "Int16", name: "anchorPointY" },
        // distances to the edges from the anchor
        { type: "Int16", name: "x1" },
        { type: "Int16", name: "y1" },
        { type: "Int16", name: "x2" },
        { type: "Int16", name: "y2" },
        // the index of the feature in the original vectortile
        { type: "Uint32", name: "featureIndex" },
        // the source layer the feature appears in
        { type: "Uint16", name: "sourceLayerIndex" },
        // the bucket the feature appears in
        { type: "Uint16", name: "bucketIndex" },
        // collision circles for lines store their distance to the anchor in tile units
        // so that they can be ignored if the projected label doesn't extend into
        // the box area
        { type: "Int16", name: "radius" },
        { type: "Int16", name: "signedDistanceFromAnchor" }
      ]);
      var collisionBoxLayout = createLayout(
        [
          // used to render collision boxes for debugging purposes
          { name: "a_pos", components: 2, type: "Int16" },
          { name: "a_anchor_pos", components: 2, type: "Int16" },
          { name: "a_extrude", components: 2, type: "Int16" }
        ],
        4
      );
      var collisionCircleLayout = createLayout(
        [
          // used to render collision circles for debugging purposes
          { name: "a_pos", components: 2, type: "Int16" },
          { name: "a_anchor_pos", components: 2, type: "Int16" },
          { name: "a_extrude", components: 2, type: "Int16" }
        ],
        4
      );
      var placement = createLayout([
        { type: "Int16", name: "anchorX" },
        { type: "Int16", name: "anchorY" },
        { type: "Uint16", name: "glyphStartIndex" },
        { type: "Uint16", name: "numGlyphs" },
        { type: "Uint32", name: "vertexStartIndex" },
        { type: "Uint32", name: "lineStartIndex" },
        { type: "Uint32", name: "lineLength" },
        { type: "Uint16", name: "segment" },
        { type: "Uint16", name: "lowerSize" },
        { type: "Uint16", name: "upperSize" },
        { type: "Float32", name: "lineOffsetX" },
        { type: "Float32", name: "lineOffsetY" },
        { type: "Uint8", name: "writingMode" },
        { type: "Uint8", name: "hidden" }
      ]);
      var symbolInstance = createLayout([
        { type: "Int16", name: "anchorX" },
        { type: "Int16", name: "anchorY" },
        { type: "Int16", name: "horizontalPlacedTextSymbolIndex" },
        { type: "Int16", name: "verticalPlacedTextSymbolIndex" },
        { type: "Uint16", name: "key" },
        { type: "Uint16", name: "textBoxStartIndex" },
        { type: "Uint16", name: "textBoxEndIndex" },
        { type: "Uint16", name: "iconBoxStartIndex" },
        { type: "Uint16", name: "iconBoxEndIndex" },
        { type: "Uint16", name: "featureIndex" },
        { type: "Uint16", name: "numGlyphVertices" },
        { type: "Uint16", name: "numVerticalGlyphVertices" },
        { type: "Uint16", name: "numIconVertices" },
        { type: "Uint32", name: "crossTileID" }
      ]);
      var glyphOffset = createLayout([{ type: "Float32", name: "offsetX" }]);
      var lineVertex = createLayout([
        { type: "Int16", name: "x" },
        { type: "Int16", name: "y" },
        { type: "Int16", name: "tileUnitDistanceFromAnchor" }
      ]);
      module.exports = {
        symbolLayoutAttributes,
        dynamicLayoutAttributes,
        placementOpacityAttributes,
        collisionVertexAttributes,
        collisionBox,
        collisionBoxLayout,
        collisionCircleLayout,
        placement,
        symbolInstance,
        glyphOffset,
        lineVertex
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/symbol/transform_text.js
  var require_transform_text = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/symbol/transform_text.js"(exports, module) {
      var { plugin: rtlTextPlugin } = require_rtl_text_plugin();
      function transformText(text, layer, feature) {
        const transform = layer.layout.get("text-transform").evaluate(feature, {});
        if (transform === "uppercase") {
          text = text.toLocaleUpperCase();
        } else if (transform === "lowercase") {
          text = text.toLocaleLowerCase();
        }
        if (rtlTextPlugin.applyArabicShaping) {
          text = rtlTextPlugin.applyArabicShaping(text);
        }
        return text;
      }
      module.exports = function(text, layer, feature) {
        text.sections.forEach((section) => {
          section.text = transformText(section.text, layer, feature);
        });
        return text;
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/symbol/mergelines.js
  var require_mergelines = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/symbol/mergelines.js"(exports, module) {
      module.exports = function(features) {
        const leftIndex = /* @__PURE__ */ new Map();
        const rightIndex = /* @__PURE__ */ new Map();
        const mergedFeatures = [];
        let mergedIndex = 0;
        for (let k = 0; k < features.length; k++) {
          const { geometry, text: featureText } = features[k];
          const text = featureText ? featureText.toString() : null;
          if (!text) {
            add(k);
            continue;
          }
          const leftKey = getKey(text, geometry);
          const rightKey = getKey(text, geometry, true);
          if (rightIndex.has(leftKey) && leftIndex.has(rightKey) && rightIndex.get(leftKey) !== leftIndex.get(rightKey)) {
            const j = mergeFromLeft(leftKey, rightKey, geometry);
            const i = mergeFromRight(leftKey, rightKey, mergedFeatures[j].geometry);
            leftIndex.delete(leftKey);
            rightIndex.delete(rightKey);
            rightIndex.set(getKey(text, mergedFeatures[i].geometry, true), i);
            mergedFeatures[j].geometry = null;
          } else if (rightIndex.has(leftKey)) {
            mergeFromRight(leftKey, rightKey, geometry);
          } else if (leftIndex.has(rightKey)) {
            mergeFromLeft(leftKey, rightKey, geometry);
          } else {
            add(k);
            leftIndex.set(leftKey, mergedIndex - 1);
            rightIndex.set(rightKey, mergedIndex - 1);
          }
        }
        return mergedFeatures.filter((f) => f.geometry);
        function add(k) {
          mergedFeatures.push(features[k]);
          mergedIndex++;
        }
        function mergeFromRight(leftKey, rightKey, [geom]) {
          const i = rightIndex.get(leftKey);
          rightIndex.delete(leftKey);
          rightIndex.set(rightKey, i);
          const feature = mergedFeatures[i];
          feature.geometry[0].pop();
          feature.geometry[0].push(...geom);
          return i;
        }
        function mergeFromLeft(leftKey, rightKey, [geom]) {
          const i = leftIndex.get(rightKey);
          leftIndex.delete(rightKey);
          leftIndex.set(leftKey, i);
          const feature = mergedFeatures[i];
          feature.geometry[0].shift();
          feature.geometry[0].unshift(...geom);
          return i;
        }
        function getKey(text, [geom], onRight) {
          const { x, y } = geom.at(onRight ? -1 : 0);
          return `${text}:${x}:${y}`;
        }
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/verticalize_punctuation.js
  var require_verticalize_punctuation = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/verticalize_punctuation.js"(exports, module) {
      var { charHasRotatedVerticalOrientation } = require_script_detection();
      var verticalizedCharacterMap = {
        "!": "\uFE15",
        "#": "\uFF03",
        $: "\uFF04",
        "%": "\uFF05",
        "&": "\uFF06",
        "(": "\uFE35",
        ")": "\uFE36",
        "*": "\uFF0A",
        "+": "\uFF0B",
        ",": "\uFE10",
        "-": "\uFE32",
        ".": "\u30FB",
        "/": "\uFF0F",
        ":": "\uFE13",
        ";": "\uFE14",
        "<": "\uFE3F",
        "=": "\uFF1D",
        ">": "\uFE40",
        "?": "\uFE16",
        "@": "\uFF20",
        "[": "\uFE47",
        "\\": "\uFF3C",
        "]": "\uFE48",
        "^": "\uFF3E",
        _: "\uFE33",
        "`": "\uFF40",
        "{": "\uFE37",
        "|": "\u2015",
        "}": "\uFE38",
        "~": "\uFF5E",
        "\xA2": "\uFFE0",
        "\xA3": "\uFFE1",
        "\xA5": "\uFFE5",
        "\xA6": "\uFFE4",
        "\xAC": "\uFFE2",
        "\xAF": "\uFFE3",
        "\u2013": "\uFE32",
        "\u2014": "\uFE31",
        "\u2018": "\uFE43",
        "\u2019": "\uFE44",
        "\u201C": "\uFE41",
        "\u201D": "\uFE42",
        "\u2026": "\uFE19",
        "\u2027": "\u30FB",
        "\u20A9": "\uFFE6",
        "\u3001": "\uFE11",
        "\u3002": "\uFE12",
        "\u3008": "\uFE3F",
        "\u3009": "\uFE40",
        "\u300A": "\uFE3D",
        "\u300B": "\uFE3E",
        "\u300C": "\uFE41",
        "\u300D": "\uFE42",
        "\u300E": "\uFE43",
        "\u300F": "\uFE44",
        "\u3010": "\uFE3B",
        "\u3011": "\uFE3C",
        "\u3014": "\uFE39",
        "\u3015": "\uFE3A",
        "\u3016": "\uFE17",
        "\u3017": "\uFE18",
        "\uFF01": "\uFE15",
        "\uFF08": "\uFE35",
        "\uFF09": "\uFE36",
        "\uFF0C": "\uFE10",
        "\uFF0D": "\uFE32",
        "\uFF0E": "\u30FB",
        "\uFF1A": "\uFE13",
        "\uFF1B": "\uFE14",
        "\uFF1C": "\uFE3F",
        "\uFF1E": "\uFE40",
        "\uFF1F": "\uFE16",
        "\uFF3B": "\uFE47",
        "\uFF3D": "\uFE48",
        "\uFF3F": "\uFE33",
        "\uFF5B": "\uFE37",
        "\uFF5C": "\u2015",
        "\uFF5D": "\uFE38",
        "\uFF5F": "\uFE35",
        "\uFF60": "\uFE36",
        "\uFF61": "\uFE12",
        "\uFF62": "\uFE41",
        "\uFF63": "\uFE42"
      };
      function verticalizePunctuation(input) {
        let output = "";
        for (let i = 0; i < input.length; i++) {
          const nextCharCode = input.charCodeAt(i + 1) || null;
          const prevCharCode = input.charCodeAt(i - 1) || null;
          const canReplacePunctuation = (!nextCharCode || !charHasRotatedVerticalOrientation(nextCharCode) || verticalizedCharacterMap[input[i + 1]]) && (!prevCharCode || !charHasRotatedVerticalOrientation(prevCharCode) || verticalizedCharacterMap[input[i - 1]]);
          if (canReplacePunctuation && verticalizedCharacterMap[input[i]]) {
            output += verticalizedCharacterMap[input[i]];
          } else {
            output += input[i];
          }
        }
        return output;
      }
      verticalizePunctuation.verticalizedCharacterMap = verticalizedCharacterMap;
      module.exports = verticalizePunctuation;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/interpolate.js
  var require_interpolate3 = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/interpolate.js"(exports, module) {
      module.exports = interpolate2;
      function interpolate2(a, b, t) {
        return a * (1 - t) + b * t;
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/symbol/symbol_size.js
  var require_symbol_size = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/symbol/symbol_size.js"(exports, module) {
      var { normalizePropertyExpression } = require_style_expressions();
      var interpolate2 = require_interpolate3();
      var { clamp } = require_util();
      var EvaluationParameters = require_evaluation_parameters();
      module.exports = { getSizeData, evaluateSizeForFeature, evaluateSizeForZoom };
      function getSizeData(tileZoom, value) {
        const { expression } = value;
        if (expression.kind === "constant") {
          return {
            functionType: "constant",
            layoutSize: expression.evaluate(new EvaluationParameters(tileZoom + 1))
          };
        }
        if (expression.kind === "source") {
          return {
            functionType: "source"
          };
        }
        const levels = expression.zoomStops;
        let lower = 0;
        while (lower < levels.length && levels[lower] <= tileZoom) lower++;
        lower = Math.max(0, lower - 1);
        let upper = lower;
        while (upper < levels.length && levels[upper] < tileZoom + 1) upper++;
        upper = Math.min(levels.length - 1, upper);
        const zoomRange = {
          min: levels[lower],
          max: levels[upper]
        };
        if (expression.kind === "composite") {
          return {
            functionType: "composite",
            zoomRange,
            propertyValue: value.value
          };
        }
        return {
          functionType: "camera",
          layoutSize: expression.evaluate(new EvaluationParameters(tileZoom + 1)),
          zoomRange,
          sizeRange: {
            min: expression.evaluate(new EvaluationParameters(zoomRange.min)),
            max: expression.evaluate(new EvaluationParameters(zoomRange.max))
          },
          propertyValue: value.value
        };
      }
      function evaluateSizeForFeature(sizeData, partiallyEvaluatedSize, symbol) {
        const part = partiallyEvaluatedSize;
        if (sizeData.functionType === "source") {
          return symbol.lowerSize / 10;
        }
        if (sizeData.functionType === "composite") {
          return interpolate2(symbol.lowerSize / 10, symbol.upperSize / 10, part.uSizeT);
        }
        return part.uSize;
      }
      function evaluateSizeForZoom(sizeData, currentZoom, property) {
        if (sizeData.functionType === "constant") {
          return {
            uSizeT: 0,
            uSize: sizeData.layoutSize
          };
        }
        if (sizeData.functionType === "source") {
          return {
            uSizeT: 0,
            uSize: 0
          };
        }
        if (sizeData.functionType === "camera") {
          const { propertyValue: propertyValue2, zoomRange: zoomRange2, sizeRange } = sizeData;
          const expression2 = normalizePropertyExpression(propertyValue2, property.specification);
          const t = clamp(expression2.interpolationFactor(currentZoom, zoomRange2.min, zoomRange2.max), 0, 1);
          return {
            uSizeT: 0,
            uSize: sizeRange.min + t * (sizeRange.max - sizeRange.min)
          };
        }
        const { propertyValue, zoomRange } = sizeData;
        const expression = normalizePropertyExpression(propertyValue, property.specification);
        return {
          uSizeT: clamp(expression.interpolationFactor(currentZoom, zoomRange.min, zoomRange.max), 0, 1),
          uSize: 0
        };
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/bucket/symbol_bucket.js
  var require_symbol_bucket = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/bucket/symbol_bucket.js"(exports, module) {
      var {
        symbolLayoutAttributes,
        collisionVertexAttributes,
        collisionBoxLayout,
        collisionCircleLayout,
        dynamicLayoutAttributes
      } = require_symbol_attributes();
      var {
        SymbolLayoutArray,
        SymbolDynamicLayoutArray,
        SymbolOpacityArray,
        CollisionBoxLayoutArray,
        CollisionCircleLayoutArray,
        CollisionVertexArray,
        PlacedSymbolArray,
        SymbolInstanceArray,
        GlyphOffsetArray,
        SymbolLineVertexArray
      } = require_array_types();
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      var SegmentVector = require_segment();
      var { ProgramConfigurationSet } = require_program_configuration();
      var { TriangleIndexArray, LineIndexArray } = require_index_array_type();
      var transformText = require_transform_text();
      var mergeLines = require_mergelines();
      var { allowsVerticalWritingMode } = require_script_detection();
      var loadGeometry = require_load_geometry();
      var mvt = require_vector_tile();
      var vectorTileFeatureTypes = mvt.VectorTileFeature.types;
      var { verticalizedCharacterMap } = require_verticalize_punctuation();
      var { getSizeData } = require_symbol_size();
      var { register } = require_transfer_registry();
      var EvaluationParameters = require_evaluation_parameters();
      var { Formatted } = require_style_expressions();
      var shaderOpacityAttributes = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function addVertex(array, anchorX, anchorY, ox, oy, tx, ty, sizeVertex) {
        array.emplaceBack(
          // a_pos_offset
          anchorX,
          anchorY,
          Math.round(ox * 32),
          Math.round(oy * 32),
          // a_data
          tx,
          // x coordinate of symbol on glyph atlas texture
          ty,
          // y coordinate of symbol on glyph atlas texture
          sizeVertex ? sizeVertex[0] : 0,
          sizeVertex ? sizeVertex[1] : 0
        );
      }
      function addDynamicAttributes(dynamicLayoutVertexArray, p, angle) {
        dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
        dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
        dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
        dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
      }
      var SymbolBuffers = class {
        constructor(programConfigurations) {
          this.layoutVertexArray = new SymbolLayoutArray();
          this.indexArray = new TriangleIndexArray();
          this.programConfigurations = programConfigurations;
          this.segments = new SegmentVector();
          this.dynamicLayoutVertexArray = new SymbolDynamicLayoutArray();
          this.opacityVertexArray = new SymbolOpacityArray();
          this.placedSymbolArray = new PlacedSymbolArray();
        }
        upload(context, dynamicIndexBuffer, upload, update) {
          if (upload) {
            this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, symbolLayoutAttributes.members);
            this.indexBuffer = context.createIndexBuffer(this.indexArray, dynamicIndexBuffer);
            this.dynamicLayoutVertexBuffer = context.createVertexBuffer(
              this.dynamicLayoutVertexArray,
              dynamicLayoutAttributes.members,
              true
            );
            this.opacityVertexBuffer = context.createVertexBuffer(this.opacityVertexArray, shaderOpacityAttributes, true);
            this.opacityVertexBuffer.itemSize = 1;
          }
          if (upload || update) {
            this.programConfigurations.upload(context);
          }
        }
        destroy() {
          if (!this.layoutVertexBuffer) return;
          this.layoutVertexBuffer.destroy();
          this.indexBuffer.destroy();
          this.programConfigurations.destroy();
          this.segments.destroy();
          this.dynamicLayoutVertexBuffer.destroy();
          this.opacityVertexBuffer.destroy();
        }
      };
      register("SymbolBuffers", SymbolBuffers);
      var CollisionBuffers = class {
        constructor(LayoutArray, layoutAttributes, IndexArray) {
          this.layoutVertexArray = new LayoutArray();
          this.layoutAttributes = layoutAttributes;
          this.indexArray = new IndexArray();
          this.segments = new SegmentVector();
          this.collisionVertexArray = new CollisionVertexArray();
        }
        upload(context) {
          this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes);
          this.indexBuffer = context.createIndexBuffer(this.indexArray);
          this.collisionVertexBuffer = context.createVertexBuffer(
            this.collisionVertexArray,
            collisionVertexAttributes.members,
            true
          );
        }
        destroy() {
          if (!this.layoutVertexBuffer) return;
          this.layoutVertexBuffer.destroy();
          this.indexBuffer.destroy();
          this.segments.destroy();
          this.collisionVertexBuffer.destroy();
        }
      };
      register("CollisionBuffers", CollisionBuffers);
      var SymbolBucket = class {
        constructor(options) {
          this.collisionBoxArray = options.collisionBoxArray;
          this.zoom = options.zoom;
          this.overscaling = options.overscaling;
          this.layers = options.layers;
          this.layerIds = this.layers.map((layer2) => layer2.id);
          this.index = options.index;
          this.pixelRatio = options.pixelRatio;
          this.sourceLayerIndex = options.sourceLayerIndex;
          this.hasPattern = false;
          const layer = this.layers[0];
          const unevaluatedLayoutValues = layer._unevaluatedLayout._values;
          this.textSizeData = getSizeData(this.zoom, unevaluatedLayoutValues["text-size"]);
          this.iconSizeData = getSizeData(this.zoom, unevaluatedLayoutValues["icon-size"]);
          const layout = this.layers[0].layout;
          const zOrderByViewportY = layout.get("symbol-z-order") === "viewport-y";
          this.sortFeaturesByY = zOrderByViewportY && (layout.get("text-allow-overlap") || layout.get("icon-allow-overlap") || layout.get("text-ignore-placement") || layout.get("icon-ignore-placement"));
          this.sourceID = options.sourceID;
        }
        createArrays() {
          this.text = new SymbolBuffers(
            new ProgramConfigurationSet(
              symbolLayoutAttributes.members,
              this.layers,
              this.zoom,
              (property) => /^text/.test(property)
            )
          );
          this.icon = new SymbolBuffers(
            new ProgramConfigurationSet(
              symbolLayoutAttributes.members,
              this.layers,
              this.zoom,
              (property) => /^icon/.test(property)
            )
          );
          this.collisionBox = new CollisionBuffers(CollisionBoxLayoutArray, collisionBoxLayout.members, LineIndexArray);
          this.collisionCircle = new CollisionBuffers(
            CollisionCircleLayoutArray,
            collisionCircleLayout.members,
            TriangleIndexArray
          );
          this.glyphOffsetArray = new GlyphOffsetArray();
          this.lineVertexArray = new SymbolLineVertexArray();
          this.symbolInstances = new SymbolInstanceArray();
        }
        calculateGlyphDependencies(text, stack, textAlongLine, doesAllowVerticalWritingMode) {
          for (let i = 0; i < text.length; i++) {
            stack[text.charCodeAt(i)] = true;
            if (textAlongLine && doesAllowVerticalWritingMode) {
              const verticalChar = verticalizedCharacterMap[text.charAt(i)];
              if (verticalChar) {
                stack[verticalChar.charCodeAt(0)] = true;
              }
            }
          }
        }
        populate(features, options) {
          const layer = this.layers[0];
          const layout = layer.layout;
          const textFont = layout.get("text-font");
          const textField = layout.get("text-field");
          const iconImage = layout.get("icon-image");
          const hasText = (textField.value.kind !== "constant" || textField.value.value.toString().length > 0) && (textFont.value.kind !== "constant" || textFont.value.value.length > 0);
          const hasIcon = iconImage.value.kind !== "constant" || iconImage.value.value && iconImage.value.value.length > 0;
          this.features = [];
          if (!hasText && !hasIcon) {
            return;
          }
          const icons = options.iconDependencies;
          const stacks = options.glyphDependencies;
          const globalProperties = new EvaluationParameters(this.zoom);
          for (const { feature, index, sourceLayerIndex } of features) {
            if (!layer._featureFilter(globalProperties, feature)) {
              continue;
            }
            let text;
            if (hasText) {
              const resolvedTokens = layer.getValueAndResolveTokens("text-field", feature);
              text = transformText(
                resolvedTokens instanceof Formatted ? resolvedTokens : Formatted.fromString(resolvedTokens),
                layer,
                feature
              );
            }
            let icon;
            if (hasIcon) {
              icon = layer.getValueAndResolveTokens("icon-image", feature);
            }
            if (!text && !icon) {
              continue;
            }
            const symbolFeature = {
              text,
              icon,
              index,
              sourceLayerIndex,
              geometry: loadGeometry(feature),
              properties: feature.properties,
              type: vectorTileFeatureTypes[feature.type]
            };
            if (typeof feature.id !== "undefined") {
              symbolFeature.id = feature.id;
            }
            this.features.push(symbolFeature);
            if (icon) {
              icons[icon] = true;
            }
            if (text) {
              const fontStack = textFont.evaluate(feature, {}).join(",");
              const textAlongLine = layout.get("text-rotation-alignment") === "map" && layout.get("symbol-placement") !== "point";
              for (const section of text.sections) {
                const doesAllowVerticalWritingMode = allowsVerticalWritingMode(text.toString());
                const sectionFont = section.fontStack || fontStack;
                const sectionStack = stacks[sectionFont] = stacks[sectionFont] || {};
                this.calculateGlyphDependencies(section.text, sectionStack, textAlongLine, doesAllowVerticalWritingMode);
              }
            }
          }
          if (layout.get("symbol-placement") === "line") {
            this.features = mergeLines(this.features);
          }
        }
        update(states, vtLayer, imagePositions) {
          if (!this.stateDependentLayers.length) return;
          this.text.programConfigurations.updatePaintArrays(states, vtLayer, this.layers, imagePositions);
          this.icon.programConfigurations.updatePaintArrays(states, vtLayer, this.layers, imagePositions);
        }
        isEmpty() {
          return this.symbolInstances.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(context) {
          if (!this.uploaded) {
            this.collisionBox.upload(context);
            this.collisionCircle.upload(context);
          }
          this.text.upload(context, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload);
          this.icon.upload(context, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload);
          this.uploaded = true;
        }
        destroy() {
          this.text.destroy();
          this.icon.destroy();
          this.collisionBox.destroy();
          this.collisionCircle.destroy();
        }
        addToLineVertexArray(anchor, line) {
          const lineStartIndex = this.lineVertexArray.length;
          if (anchor.segment !== void 0) {
            let sumForwardLength = anchor.dist(line[anchor.segment + 1]);
            let sumBackwardLength = anchor.dist(line[anchor.segment]);
            const vertices = {};
            for (let i = anchor.segment + 1; i < line.length; i++) {
              vertices[i] = { x: line[i].x, y: line[i].y, tileUnitDistanceFromAnchor: sumForwardLength };
              if (i < line.length - 1) {
                sumForwardLength += line[i + 1].dist(line[i]);
              }
            }
            for (let i = anchor.segment || 0; i >= 0; i--) {
              vertices[i] = { x: line[i].x, y: line[i].y, tileUnitDistanceFromAnchor: sumBackwardLength };
              if (i > 0) {
                sumBackwardLength += line[i - 1].dist(line[i]);
              }
            }
            for (let i = 0; i < line.length; i++) {
              const vertex = vertices[i];
              this.lineVertexArray.emplaceBack(vertex.x, vertex.y, vertex.tileUnitDistanceFromAnchor);
            }
          }
          return {
            lineStartIndex,
            lineLength: this.lineVertexArray.length - lineStartIndex
          };
        }
        addSymbols(arrays, quads, sizeVertex, lineOffset, alongLine, feature, writingMode, labelAnchor, lineStartIndex, lineLength) {
          const indexArray = arrays.indexArray;
          const layoutVertexArray = arrays.layoutVertexArray;
          const dynamicLayoutVertexArray = arrays.dynamicLayoutVertexArray;
          const segment = arrays.segments.prepareSegment(4 * quads.length, arrays.layoutVertexArray, arrays.indexArray);
          const glyphOffsetArrayStart = this.glyphOffsetArray.length;
          const vertexStartIndex = segment.vertexLength;
          for (const symbol of quads) {
            const tl = symbol.tl;
            const tr = symbol.tr;
            const bl = symbol.bl;
            const br = symbol.br;
            const tex = symbol.tex;
            const index = segment.vertexLength;
            const y = symbol.glyphOffset[1];
            addVertex(layoutVertexArray, labelAnchor.x, labelAnchor.y, tl.x, y + tl.y, tex.x, tex.y, sizeVertex);
            addVertex(layoutVertexArray, labelAnchor.x, labelAnchor.y, tr.x, y + tr.y, tex.x + tex.w, tex.y, sizeVertex);
            addVertex(layoutVertexArray, labelAnchor.x, labelAnchor.y, bl.x, y + bl.y, tex.x, tex.y + tex.h, sizeVertex);
            addVertex(
              layoutVertexArray,
              labelAnchor.x,
              labelAnchor.y,
              br.x,
              y + br.y,
              tex.x + tex.w,
              tex.y + tex.h,
              sizeVertex
            );
            addDynamicAttributes(dynamicLayoutVertexArray, labelAnchor, 0);
            indexArray.emplaceBack(index, index + 1, index + 2);
            indexArray.emplaceBack(index + 1, index + 2, index + 3);
            segment.vertexLength += 4;
            segment.primitiveLength += 2;
            this.glyphOffsetArray.emplaceBack(symbol.glyphOffset[0]);
          }
          arrays.placedSymbolArray.emplaceBack(
            labelAnchor.x,
            labelAnchor.y,
            glyphOffsetArrayStart,
            this.glyphOffsetArray.length - glyphOffsetArrayStart,
            vertexStartIndex,
            lineStartIndex,
            lineLength,
            labelAnchor.segment,
            sizeVertex ? sizeVertex[0] : 0,
            sizeVertex ? sizeVertex[1] : 0,
            lineOffset[0],
            lineOffset[1],
            writingMode,
            false
          );
          arrays.programConfigurations.populatePaintArrays(arrays.layoutVertexArray.length, feature, feature.index, {});
        }
        _addCollisionDebugVertex(layoutVertexArray, collisionVertexArray, point, anchorX, anchorY, extrude) {
          collisionVertexArray.emplaceBack(0, 0);
          return layoutVertexArray.emplaceBack(
            // pos
            point.x,
            point.y,
            // a_anchor_pos
            anchorX,
            anchorY,
            // extrude
            Math.round(extrude.x),
            Math.round(extrude.y)
          );
        }
        addCollisionDebugVertices(x1, y1, x2, y2, arrays, boxAnchorPoint, symbolInstance, isCircle) {
          const segment = arrays.segments.prepareSegment(4, arrays.layoutVertexArray, arrays.indexArray);
          const index = segment.vertexLength;
          const layoutVertexArray = arrays.layoutVertexArray;
          const collisionVertexArray = arrays.collisionVertexArray;
          const anchorX = symbolInstance.anchorX;
          const anchorY = symbolInstance.anchorY;
          this._addCollisionDebugVertex(
            layoutVertexArray,
            collisionVertexArray,
            boxAnchorPoint,
            anchorX,
            anchorY,
            new Point3(x1, y1)
          );
          this._addCollisionDebugVertex(
            layoutVertexArray,
            collisionVertexArray,
            boxAnchorPoint,
            anchorX,
            anchorY,
            new Point3(x2, y1)
          );
          this._addCollisionDebugVertex(
            layoutVertexArray,
            collisionVertexArray,
            boxAnchorPoint,
            anchorX,
            anchorY,
            new Point3(x2, y2)
          );
          this._addCollisionDebugVertex(
            layoutVertexArray,
            collisionVertexArray,
            boxAnchorPoint,
            anchorX,
            anchorY,
            new Point3(x1, y2)
          );
          segment.vertexLength += 4;
          if (isCircle) {
            const indexArray = arrays.indexArray;
            indexArray.emplaceBack(index, index + 1, index + 2);
            indexArray.emplaceBack(index, index + 2, index + 3);
            segment.primitiveLength += 2;
          } else {
            const indexArray = arrays.indexArray;
            indexArray.emplaceBack(index, index + 1);
            indexArray.emplaceBack(index + 1, index + 2);
            indexArray.emplaceBack(index + 2, index + 3);
            indexArray.emplaceBack(index + 3, index);
            segment.primitiveLength += 4;
          }
        }
        addDebugCollisionBoxes(startIndex, endIndex, symbolInstance) {
          for (let b = startIndex; b < endIndex; b++) {
            const box = this.collisionBoxArray.get(b);
            const x1 = box.x1;
            const y1 = box.y1;
            const x2 = box.x2;
            const y2 = box.y2;
            const isCircle = box.radius > 0;
            this.addCollisionDebugVertices(
              x1,
              y1,
              x2,
              y2,
              isCircle ? this.collisionCircle : this.collisionBox,
              box.anchorPoint,
              symbolInstance,
              isCircle
            );
          }
        }
        generateCollisionDebugBuffers() {
          for (let i = 0; i < this.symbolInstances.length; i++) {
            const symbolInstance = this.symbolInstances.get(i);
            this.addDebugCollisionBoxes(symbolInstance.textBoxStartIndex, symbolInstance.textBoxEndIndex, symbolInstance);
            this.addDebugCollisionBoxes(symbolInstance.iconBoxStartIndex, symbolInstance.iconBoxEndIndex, symbolInstance);
          }
        }
        // These flat arrays are meant to be quicker to iterate over than the source
        // CollisionBoxArray
        _deserializeCollisionBoxesForSymbol(collisionBoxArray, textStartIndex, textEndIndex, iconStartIndex, iconEndIndex) {
          const collisionArrays = {};
          for (let k = textStartIndex; k < textEndIndex; k++) {
            const box = collisionBoxArray.get(k);
            if (box.radius === 0) {
              collisionArrays.textBox = {
                x1: box.x1,
                y1: box.y1,
                x2: box.x2,
                y2: box.y2,
                anchorPointX: box.anchorPointX,
                anchorPointY: box.anchorPointY
              };
              collisionArrays.textFeatureIndex = box.featureIndex;
              break;
            }
            if (!collisionArrays.textCircles) {
              collisionArrays.textCircles = [];
              collisionArrays.textFeatureIndex = box.featureIndex;
            }
            const used = 1;
            collisionArrays.textCircles.push(
              box.anchorPointX,
              box.anchorPointY,
              box.radius,
              box.signedDistanceFromAnchor,
              used
            );
          }
          for (let k = iconStartIndex; k < iconEndIndex; k++) {
            const box = collisionBoxArray.get(k);
            if (box.radius === 0) {
              collisionArrays.iconBox = {
                x1: box.x1,
                y1: box.y1,
                x2: box.x2,
                y2: box.y2,
                anchorPointX: box.anchorPointX,
                anchorPointY: box.anchorPointY
              };
              collisionArrays.iconFeatureIndex = box.featureIndex;
              break;
            }
          }
          return collisionArrays;
        }
        deserializeCollisionBoxes(collisionBoxArray) {
          this.collisionArrays = [];
          for (let i = 0; i < this.symbolInstances.length; i++) {
            const symbolInstance = this.symbolInstances.get(i);
            this.collisionArrays.push(
              this._deserializeCollisionBoxesForSymbol(
                collisionBoxArray,
                symbolInstance.textBoxStartIndex,
                symbolInstance.textBoxEndIndex,
                symbolInstance.iconBoxStartIndex,
                symbolInstance.iconBoxEndIndex
              )
            );
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasCollisionBoxData() {
          return this.collisionBox.segments.get().length > 0;
        }
        hasCollisionCircleData() {
          return this.collisionCircle.segments.get().length > 0;
        }
        addIndicesForPlacedTextSymbol(placedTextSymbolIndex) {
          const placedSymbol = this.text.placedSymbolArray.get(placedTextSymbolIndex);
          const endIndex = placedSymbol.vertexStartIndex + placedSymbol.numGlyphs * 4;
          for (let vertexIndex = placedSymbol.vertexStartIndex; vertexIndex < endIndex; vertexIndex += 4) {
            this.text.indexArray.emplaceBack(vertexIndex, vertexIndex + 1, vertexIndex + 2);
            this.text.indexArray.emplaceBack(vertexIndex + 1, vertexIndex + 2, vertexIndex + 3);
          }
        }
        sortFeatures(angle) {
          if (!this.sortFeaturesByY) return;
          if (this.sortedAngle === angle) return;
          this.sortedAngle = angle;
          if (this.text.segments.get().length > 1 || this.icon.segments.get().length > 1) return;
          const symbolInstanceIndexes = [];
          for (let i = 0; i < this.symbolInstances.length; i++) {
            symbolInstanceIndexes.push(i);
          }
          const sin = Math.sin(angle);
          const cos = Math.cos(angle);
          const rotatedYs = [];
          const featureIndexes = [];
          for (let i = 0; i < this.symbolInstances.length; i++) {
            const symbolInstance = this.symbolInstances.get(i);
            rotatedYs.push(Math.round(sin * symbolInstance.anchorX + cos * symbolInstance.anchorY) | 0);
            featureIndexes.push(symbolInstance.featureIndex);
          }
          symbolInstanceIndexes.sort((aIndex, bIndex) => {
            return rotatedYs[aIndex] - rotatedYs[bIndex] || featureIndexes[bIndex] - featureIndexes[aIndex];
          });
          this.text.indexArray.clear();
          this.icon.indexArray.clear();
          this.featureSortOrder = [];
          for (const i of symbolInstanceIndexes) {
            const symbolInstance = this.symbolInstances.get(i);
            this.featureSortOrder.push(symbolInstance.featureIndex);
            if (symbolInstance.horizontalPlacedTextSymbolIndex >= 0) {
              this.addIndicesForPlacedTextSymbol(symbolInstance.horizontalPlacedTextSymbolIndex);
            }
            if (symbolInstance.verticalPlacedTextSymbolIndex >= 0) {
              this.addIndicesForPlacedTextSymbol(symbolInstance.verticalPlacedTextSymbolIndex);
            }
            const placedIcon = this.icon.placedSymbolArray.get(i);
            if (placedIcon.numGlyphs) {
              const vertexIndex = placedIcon.vertexStartIndex;
              this.icon.indexArray.emplaceBack(vertexIndex, vertexIndex + 1, vertexIndex + 2);
              this.icon.indexArray.emplaceBack(vertexIndex + 1, vertexIndex + 2, vertexIndex + 3);
            }
          }
          if (this.text.indexBuffer) this.text.indexBuffer.updateData(this.text.indexArray);
          if (this.icon.indexBuffer) this.icon.indexBuffer.updateData(this.icon.indexArray);
        }
      };
      register("SymbolBucket", SymbolBucket, {
        omit: ["layers", "collisionBoxArray", "features", "compareText"]
      });
      SymbolBucket.MAX_GLYPHS = 65535;
      SymbolBucket.addDynamicAttributes = addDynamicAttributes;
      module.exports = SymbolBucket;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/token.js
  var require_token = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/token.js"(exports, module) {
      module.exports = resolveTokens;
      function resolveTokens(properties, text) {
        return text.replace(/{([^{}]+)}/g, (match, key) => String(properties[key] ?? ""));
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/symbol_style_layer_properties.js
  var require_symbol_style_layer_properties = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/symbol_style_layer_properties.js"(exports, module) {
      var { Properties, DataConstantProperty, DataDrivenProperty } = require_properties2();
      var layout = new Properties({
        "symbol-placement": new DataConstantProperty({
          type: "enum",
          values: ["point", "line", "line-center"],
          default: "point",
          expression: { parameters: ["zoom"] }
        }),
        "symbol-spacing": new DataConstantProperty({
          type: "number",
          default: 250,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "symbol-avoid-edges": new DataConstantProperty({
          type: "boolean",
          default: false,
          expression: { parameters: ["zoom"] }
        }),
        "symbol-z-order": new DataConstantProperty({
          type: "enum",
          values: ["viewport-y", "source"],
          default: "viewport-y",
          expression: { parameters: ["zoom"] }
        }),
        "icon-allow-overlap": new DataConstantProperty({
          type: "boolean",
          default: false,
          expression: { parameters: ["zoom"] }
        }),
        "icon-ignore-placement": new DataConstantProperty({
          type: "boolean",
          default: false,
          expression: { parameters: ["zoom"] }
        }),
        "icon-optional": new DataConstantProperty({ type: "boolean", default: false, expression: { parameters: ["zoom"] } }),
        "icon-rotation-alignment": new DataConstantProperty({
          type: "enum",
          values: ["map", "viewport", "auto"],
          default: "auto",
          expression: { parameters: ["zoom"] }
        }),
        "icon-size": new DataDrivenProperty({
          type: "number",
          default: 1,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "icon-text-fit": new DataConstantProperty({
          type: "enum",
          values: ["none", "width", "height", "both"],
          default: "none",
          expression: { parameters: ["zoom"] }
        }),
        "icon-text-fit-padding": new DataConstantProperty({
          type: "array",
          value: "number",
          length: 4,
          default: [0, 0, 0, 0],
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "icon-image": new DataDrivenProperty({
          type: "string",
          tokens: true,
          expression: { parameters: ["zoom", "feature"] }
        }),
        "icon-rotate": new DataDrivenProperty({
          type: "number",
          default: 0,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "icon-padding": new DataConstantProperty({
          type: "number",
          default: 2,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "icon-keep-upright": new DataConstantProperty({
          type: "boolean",
          default: false,
          expression: { parameters: ["zoom"] }
        }),
        "icon-offset": new DataDrivenProperty({
          type: "array",
          value: "number",
          length: 2,
          default: [0, 0],
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "icon-anchor": new DataDrivenProperty({
          type: "enum",
          values: ["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"],
          default: "center",
          expression: { parameters: ["zoom", "feature"] }
        }),
        "icon-pitch-alignment": new DataConstantProperty({
          type: "enum",
          values: ["map", "viewport", "auto"],
          default: "auto",
          expression: { parameters: ["zoom"] }
        }),
        "text-pitch-alignment": new DataConstantProperty({
          type: "enum",
          values: ["map", "viewport", "auto"],
          default: "auto",
          expression: { parameters: ["zoom"] }
        }),
        "text-rotation-alignment": new DataConstantProperty({
          type: "enum",
          values: ["map", "viewport", "auto"],
          default: "auto",
          expression: { parameters: ["zoom"] }
        }),
        "text-field": new DataDrivenProperty({
          type: "formatted",
          default: "",
          tokens: true,
          expression: { parameters: ["zoom", "feature"] }
        }),
        "text-font": new DataDrivenProperty({
          type: "array",
          value: "string",
          default: ["Open Sans Regular", "Arial Unicode MS Regular"],
          expression: { parameters: ["zoom", "feature"] }
        }),
        "text-size": new DataDrivenProperty({
          type: "number",
          default: 16,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "text-max-width": new DataDrivenProperty({
          type: "number",
          default: 10,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "text-line-height": new DataConstantProperty({
          type: "number",
          default: 1.2,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "text-letter-spacing": new DataDrivenProperty({
          type: "number",
          default: 0,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "text-justify": new DataDrivenProperty({
          type: "enum",
          values: ["left", "center", "right"],
          default: "center",
          expression: { parameters: ["zoom", "feature"] }
        }),
        "text-anchor": new DataDrivenProperty({
          type: "enum",
          values: ["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"],
          default: "center",
          expression: { parameters: ["zoom", "feature"] }
        }),
        "text-max-angle": new DataConstantProperty({
          type: "number",
          default: 45,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "text-rotate": new DataDrivenProperty({
          type: "number",
          default: 0,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "text-padding": new DataConstantProperty({
          type: "number",
          default: 2,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "text-keep-upright": new DataConstantProperty({
          type: "boolean",
          default: true,
          expression: { parameters: ["zoom"] }
        }),
        "text-transform": new DataDrivenProperty({
          type: "enum",
          values: ["none", "uppercase", "lowercase"],
          default: "none",
          expression: { parameters: ["zoom", "feature"] }
        }),
        "text-offset": new DataDrivenProperty({
          type: "array",
          value: "number",
          length: 2,
          default: [0, 0],
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "text-allow-overlap": new DataConstantProperty({
          type: "boolean",
          default: false,
          expression: { parameters: ["zoom"] }
        }),
        "text-ignore-placement": new DataConstantProperty({
          type: "boolean",
          default: false,
          expression: { parameters: ["zoom"] }
        }),
        "text-optional": new DataConstantProperty({ type: "boolean", default: false, expression: { parameters: ["zoom"] } })
      });
      var paint = new Properties({
        "icon-opacity": new DataDrivenProperty({
          type: "number",
          default: 1,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "icon-color": new DataDrivenProperty({
          type: "color",
          default: "#000000",
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "icon-halo-color": new DataDrivenProperty({
          type: "color",
          default: "rgba(0, 0, 0, 0)",
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "icon-halo-width": new DataDrivenProperty({
          type: "number",
          default: 0,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "icon-halo-blur": new DataDrivenProperty({
          type: "number",
          default: 0,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "icon-translate": new DataConstantProperty({
          type: "array",
          value: "number",
          length: 2,
          default: [0, 0],
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "icon-translate-anchor": new DataConstantProperty({
          type: "enum",
          values: ["map", "viewport"],
          default: "map",
          expression: { parameters: ["zoom"] }
        }),
        "text-opacity": new DataDrivenProperty({
          type: "number",
          default: 1,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "text-color": new DataDrivenProperty({
          type: "color",
          default: "#000000",
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "text-halo-color": new DataDrivenProperty({
          type: "color",
          default: "rgba(0, 0, 0, 0)",
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "text-halo-width": new DataDrivenProperty({
          type: "number",
          default: 0,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "text-halo-blur": new DataDrivenProperty({
          type: "number",
          default: 0,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom", "feature"] }
        }),
        "text-translate": new DataConstantProperty({
          type: "array",
          value: "number",
          length: 2,
          default: [0, 0],
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "text-translate-anchor": new DataConstantProperty({
          type: "enum",
          values: ["map", "viewport"],
          default: "map",
          expression: { parameters: ["zoom"] }
        })
      });
      module.exports = { paint, layout };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/symbol_style_layer.js
  var require_symbol_style_layer = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/symbol_style_layer.js"(exports, module) {
      var StyleLayer = require_style_layer();
      var SymbolBucket = require_symbol_bucket();
      var resolveTokens = require_token();
      var { isExpression } = require_style_expressions();
      var assert = require_nanoassert();
      var properties = require_symbol_style_layer_properties();
      var SymbolStyleLayer = class extends StyleLayer {
        constructor(layer) {
          super(layer, properties);
        }
        recalculate(parameters) {
          super.recalculate(parameters);
          if (this.layout.get("icon-rotation-alignment") === "auto") {
            if (this.layout.get("symbol-placement") !== "point") {
              this.layout._values["icon-rotation-alignment"] = "map";
            } else {
              this.layout._values["icon-rotation-alignment"] = "viewport";
            }
          }
          if (this.layout.get("text-rotation-alignment") === "auto") {
            if (this.layout.get("symbol-placement") !== "point") {
              this.layout._values["text-rotation-alignment"] = "map";
            } else {
              this.layout._values["text-rotation-alignment"] = "viewport";
            }
          }
          if (this.layout.get("text-pitch-alignment") === "auto") {
            this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment");
          }
          if (this.layout.get("icon-pitch-alignment") === "auto") {
            this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment");
          }
        }
        getValueAndResolveTokens(name, feature) {
          const value = this.layout.get(name).evaluate(feature, {});
          const unevaluated = this._unevaluatedLayout._values[name];
          if (!unevaluated.isDataDriven() && !isExpression(unevaluated.value)) {
            return resolveTokens(feature.properties, value);
          }
          return value;
        }
        createBucket(parameters) {
          return new SymbolBucket(parameters);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          assert(false);
          return false;
        }
      };
      module.exports = SymbolStyleLayer;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/background_style_layer_properties.js
  var require_background_style_layer_properties = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/background_style_layer_properties.js"(exports, module) {
      var { Properties, CrossFadedProperty, DataConstantProperty } = require_properties2();
      var paint = new Properties({
        "background-color": new DataConstantProperty({
          type: "color",
          default: "#000000",
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "background-pattern": new CrossFadedProperty({
          type: "string",
          transition: true,
          expression: { parameters: ["zoom"] }
        }),
        "background-opacity": new DataConstantProperty({
          type: "number",
          default: 1,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        })
      });
      module.exports = { paint };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/background_style_layer.js
  var require_background_style_layer = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/background_style_layer.js"(exports, module) {
      var StyleLayer = require_style_layer();
      var properties = require_background_style_layer_properties();
      var BackgroundStyleLayer = class extends StyleLayer {
        constructor(layer) {
          super(layer, properties);
        }
      };
      module.exports = BackgroundStyleLayer;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/raster_style_layer_properties.js
  var require_raster_style_layer_properties = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/raster_style_layer_properties.js"(exports, module) {
      var { Properties, DataConstantProperty } = require_properties2();
      var paint = new Properties({
        "raster-opacity": new DataConstantProperty({
          type: "number",
          default: 1,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "raster-hue-rotate": new DataConstantProperty({
          type: "number",
          default: 0,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "raster-brightness-min": new DataConstantProperty({
          type: "number",
          default: 0,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "raster-brightness-max": new DataConstantProperty({
          type: "number",
          default: 1,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "raster-saturation": new DataConstantProperty({
          type: "number",
          default: 0,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "raster-contrast": new DataConstantProperty({
          type: "number",
          default: 0,
          transition: true,
          expression: { interpolated: true, parameters: ["zoom"] }
        }),
        "raster-resampling": new DataConstantProperty({
          type: "enum",
          values: ["linear", "nearest"],
          default: "linear",
          expression: { parameters: ["zoom"] }
        }),
        "raster-fade-duration": new DataConstantProperty({
          type: "number",
          default: 300,
          expression: { interpolated: true, parameters: ["zoom"] }
        })
      });
      module.exports = { paint };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style_layer/raster_style_layer.js
  var require_raster_style_layer = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style_layer/raster_style_layer.js"(exports, module) {
      var StyleLayer = require_style_layer();
      var properties = require_raster_style_layer_properties();
      var RasterStyleLayer = class extends StyleLayer {
        constructor(layer) {
          super(layer, properties);
        }
      };
      module.exports = RasterStyleLayer;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/create_style_layer.js
  var require_create_style_layer = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/create_style_layer.js"(exports, module) {
      var circle = require_circle_style_layer();
      var heatmap = require_heatmap_style_layer();
      var hillshade = require_hillshade_style_layer();
      var fill = require_fill_style_layer();
      var fillExtrusion = require_fill_extrusion_style_layer();
      var line = require_line_style_layer();
      var symbol = require_symbol_style_layer();
      var background = require_background_style_layer();
      var raster = require_raster_style_layer();
      var subclasses = {
        circle,
        heatmap,
        hillshade,
        fill,
        "fill-extrusion": fillExtrusion,
        line,
        symbol,
        background,
        raster
      };
      module.exports = function createStyleLayer(layer) {
        return new subclasses[layer.type](layer);
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/load_sprite.js
  var require_load_sprite = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/load_sprite.js"(exports, module) {
      var browser = require_browser();
      var { RGBAImage } = require_image2();
      var loadImage = require_image();
      module.exports = loadSprite;
      async function loadSprite(sprite) {
        const image = await loadImage(sprite.image);
        const { json } = sprite;
        if (json && image) {
          const imageData = browser.getImageData(image);
          const result = {};
          for (const id in json) {
            const { width, height, x, y, sdf, pixelRatio } = json[id];
            const data = new RGBAImage({ width, height });
            RGBAImage.copy(imageData, data, { x, y }, { x: 0, y: 0 }, { width, height });
            result[id] = { data, pixelRatio, sdf };
          }
          return result;
        }
      }
    }
  });

  // node_modules/potpack/index.js
  var require_potpack = __commonJS({
    "node_modules/potpack/index.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.potpack = factory());
      })(exports, function() {
        "use strict";
        function potpack(boxes) {
          var area2 = 0;
          var maxWidth = 0;
          for (var i$1 = 0, list = boxes; i$1 < list.length; i$1 += 1) {
            var box = list[i$1];
            area2 += box.w * box.h;
            maxWidth = Math.max(maxWidth, box.w);
          }
          boxes.sort(function(a, b) {
            return b.h - a.h;
          });
          var startWidth = Math.max(Math.ceil(Math.sqrt(area2 / 0.95)), maxWidth);
          var spaces = [{ x: 0, y: 0, w: startWidth, h: Infinity }];
          var width = 0;
          var height = 0;
          for (var i$2 = 0, list$1 = boxes; i$2 < list$1.length; i$2 += 1) {
            var box$1 = list$1[i$2];
            for (var i = spaces.length - 1; i >= 0; i--) {
              var space = spaces[i];
              if (box$1.w > space.w || box$1.h > space.h) {
                continue;
              }
              box$1.x = space.x;
              box$1.y = space.y;
              height = Math.max(height, box$1.y + box$1.h);
              width = Math.max(width, box$1.x + box$1.w);
              if (box$1.w === space.w && box$1.h === space.h) {
                var last = spaces.pop();
                if (i < spaces.length) {
                  spaces[i] = last;
                }
              } else if (box$1.h === space.h) {
                space.x += box$1.w;
                space.w -= box$1.w;
              } else if (box$1.w === space.w) {
                space.y += box$1.h;
                space.h -= box$1.h;
              } else {
                spaces.push({
                  x: space.x + box$1.w,
                  y: space.y,
                  w: space.w - box$1.w,
                  h: box$1.h
                });
                space.y += box$1.h;
                space.h -= box$1.h;
              }
              break;
            }
          }
          return {
            w: width,
            // container width
            h: height,
            // container height
            fill: area2 / (width * height) || 0
            // space utilization
          };
        }
        return potpack;
      });
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/image_atlas.js
  var require_image_atlas = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/image_atlas.js"(exports, module) {
      var { RGBAImage } = require_image2();
      var { register } = require_transfer_registry();
      var potpack = require_potpack();
      var padding = 1;
      var ImagePosition = class {
        constructor(paddedRect, { pixelRatio }) {
          this.paddedRect = paddedRect;
          this.pixelRatio = pixelRatio;
        }
        get tl() {
          return [this.paddedRect.x + padding, this.paddedRect.y + padding];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - padding, this.paddedRect.y + this.paddedRect.h - padding];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - padding * 2) / this.pixelRatio, (this.paddedRect.h - padding * 2) / this.pixelRatio];
        }
      };
      var ImageAtlas = class {
        constructor(icons, patterns) {
          const iconPositions = {};
          const patternPositions = {};
          const bins = [];
          for (const id in icons) {
            const src = icons[id];
            const bin = {
              x: 0,
              y: 0,
              w: src.data.width + 2 * padding,
              h: src.data.height + 2 * padding
            };
            bins.push(bin);
            iconPositions[id] = new ImagePosition(bin, src);
          }
          for (const id in patterns) {
            const src = patterns[id];
            const bin = {
              x: 0,
              y: 0,
              w: src.data.width + 2 * padding,
              h: src.data.height + 2 * padding
            };
            bins.push(bin);
            patternPositions[id] = new ImagePosition(bin, src);
          }
          const { w, h } = potpack(bins);
          const image = new RGBAImage({ width: w || 1, height: h || 1 });
          for (const id in icons) {
            const src = icons[id];
            const bin = iconPositions[id].paddedRect;
            RGBAImage.copy(src.data, image, { x: 0, y: 0 }, { x: bin.x + padding, y: bin.y + padding }, src.data);
          }
          for (const id in patterns) {
            const src = patterns[id];
            const bin = patternPositions[id].paddedRect;
            const x = bin.x + padding;
            const y = bin.y + padding;
            const w2 = src.data.width;
            const h2 = src.data.height;
            RGBAImage.copy(src.data, image, { x: 0, y: 0 }, { x, y }, src.data);
            RGBAImage.copy(src.data, image, { x: 0, y: h2 - 1 }, { x, y: y - 1 }, { width: w2, height: 1 });
            RGBAImage.copy(src.data, image, { x: 0, y: 0 }, { x, y: y + h2 }, { width: w2, height: 1 });
            RGBAImage.copy(src.data, image, { x: w2 - 1, y: 0 }, { x: x - 1, y }, { width: 1, height: h2 });
            RGBAImage.copy(src.data, image, { x: 0, y: 0 }, { x: x + w2, y }, { width: 1, height: h2 });
          }
          this.image = image;
          this.iconPositions = iconPositions;
          this.patternPositions = patternPositions;
        }
      };
      ImageAtlas.ImagePosition = ImagePosition;
      module.exports = ImageAtlas;
      register("ImagePosition", ImagePosition);
      register("ImageAtlas", ImageAtlas);
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/texture.js
  var require_texture = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/texture.js"(exports, module) {
      var Texture = class {
        constructor(context, image, format, options) {
          this.context = context;
          this.format = format;
          this.texture = context.gl.createTexture();
          this.update(image, options);
        }
        update(image, options) {
          const { width, height } = image;
          const resize = !this.size || this.size[0] !== width || this.size[1] !== height;
          const { context } = this;
          const { gl } = context;
          this.useMipmap = Boolean(options?.useMipmap);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          if (resize) {
            this.size = [width, height];
            context.pixelStoreUnpack.set(1);
            if (this.format === gl.RGBA && (!options || options.premultiply !== false)) {
              context.pixelStoreUnpackPremultiplyAlpha.set(true);
            }
            if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement || image instanceof ImageData) {
              gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, gl.UNSIGNED_BYTE, image);
            } else {
              gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, gl.UNSIGNED_BYTE, image.data);
            }
          } else {
            if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement || image instanceof ImageData) {
              gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
            } else {
              gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, image.data);
            }
          }
          if (this.useMipmap && this.isSizePowerOfTwo()) {
            gl.generateMipmap(gl.TEXTURE_2D);
          }
        }
        bind(filter, wrap, minFilter) {
          const { context } = this;
          const { gl } = context;
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          if (minFilter === gl.LINEAR_MIPMAP_NEAREST && !this.isSizePowerOfTwo()) {
            minFilter = gl.LINEAR;
          }
          if (filter !== this.filter) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter || filter);
            this.filter = filter;
          }
          if (wrap !== this.wrap) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);
            this.wrap = wrap;
          }
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 === 0;
        }
        destroy() {
          const { gl } = this.context;
          gl.deleteTexture(this.texture);
          this.texture = null;
        }
      };
      module.exports = Texture;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/image_manager.js
  var require_image_manager = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/image_manager.js"(exports, module) {
      var potpack = require_potpack();
      var { RGBAImage } = require_image2();
      var { ImagePosition } = require_image_atlas();
      var Texture = require_texture();
      var assert = require_nanoassert();
      var padding = 1;
      var ImageManager = class {
        #loadedState = Promise.withResolvers();
        constructor() {
          this.images = {};
          this.patterns = {};
          this.atlasImage = new RGBAImage({ width: 1, height: 1 });
          this.dirty = true;
        }
        isLoaded() {
          return !!this.#loadedState.loaded;
        }
        setLoaded() {
          if (this.#loadedState.loaded) {
            return;
          }
          this.#loadedState.loaded = true;
          this.#loadedState.resolve();
        }
        getImage(id) {
          return this.images[id];
        }
        addImage(id, image) {
          assert(!this.images[id]);
          this.images[id] = image;
        }
        removeImage(id) {
          assert(this.images[id]);
          delete this.images[id];
          delete this.patterns[id];
        }
        listImages() {
          return Object.keys(this.images);
        }
        async getImages(ids) {
          await this.#loadedState.promise;
          const response = {};
          for (const id of ids) {
            const image = this.images[id];
            if (image) {
              response[id] = {
                data: image.data.clone(),
                pixelRatio: image.pixelRatio,
                sdf: image.sdf
              };
            }
          }
          return response;
        }
        // Pattern stuff
        getPixelSize() {
          const { width, height } = this.atlasImage;
          return { width, height };
        }
        getPattern(id) {
          const pattern = this.patterns[id];
          if (pattern) {
            return pattern.position;
          }
          const image = this.getImage(id);
          if (!image) {
            return null;
          }
          const w = image.data.width + padding * 2;
          const h = image.data.height + padding * 2;
          const bin = { w, h, x: 0, y: 0 };
          const position = new ImagePosition(bin, image);
          this.patterns[id] = { bin, position };
          this._updatePatternAtlas();
          return position;
        }
        bind(context) {
          const gl = context.gl;
          if (!this.atlasTexture) {
            this.atlasTexture = new Texture(context, this.atlasImage, gl.RGBA);
          } else if (this.dirty) {
            this.atlasTexture.update(this.atlasImage);
            this.dirty = false;
          }
          this.atlasTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const bins = [];
          for (const id in this.patterns) {
            bins.push(this.patterns[id].bin);
          }
          const { w, h } = potpack(bins);
          const dst = this.atlasImage;
          dst.resize({ width: w ?? 1, height: h ?? 1 });
          for (const id in this.patterns) {
            const { bin } = this.patterns[id];
            const x = bin.x + padding;
            const y = bin.y + padding;
            const src = this.images[id].data;
            const w2 = src.width;
            const h2 = src.height;
            RGBAImage.copy(src, dst, { x: 0, y: 0 }, { x, y }, { width: w2, height: h2 });
            RGBAImage.copy(src, dst, { x: 0, y: h2 - 1 }, { x, y: y - 1 }, { width: w2, height: 1 });
            RGBAImage.copy(src, dst, { x: 0, y: 0 }, { x, y: y + h2 }, { width: w2, height: 1 });
            RGBAImage.copy(src, dst, { x: w2 - 1, y: 0 }, { x: x - 1, y }, { width: 1, height: h2 });
            RGBAImage.copy(src, dst, { x: 0, y: 0 }, { x: x + w2, y }, { width: 1, height: h2 });
          }
          this.dirty = true;
        }
      };
      module.exports = ImageManager;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/glyph_manager.js
  var require_glyph_manager = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/glyph_manager.js"(exports, module) {
      var GlyphManager = class {
        #cache = {};
        setGlyphsLoader(loader) {
          this.loader = loader;
        }
        async loadGlyphRange(stack, range) {
          this.#cache[stack] ??= {};
          const promise = this.#cache[stack][range] ??= this.loader(stack, range);
          const response = await promise;
          return response.slice();
        }
      };
      module.exports = GlyphManager;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/light.js
  var require_light = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/light.js"(exports, module) {
      var { sphericalToCartesian } = require_util();
      var { Evented: Evented3 } = (init_events(), __toCommonJS(events_exports));
      var interpolate2 = require_interpolate3();
      var lightSpec = {
        anchor: {
          type: "enum",
          default: "viewport",
          values: ["map", "viewport"],
          expression: {
            parameters: ["zoom"]
          }
        },
        position: {
          type: "array",
          default: [1.15, 210, 30],
          transition: true,
          expression: {
            interpolated: true,
            parameters: ["zoom"]
          }
        },
        color: {
          type: "color",
          default: "#ffffff",
          transition: true,
          expression: {
            interpolated: true,
            parameters: ["zoom"]
          }
        },
        intensity: {
          type: "number",
          default: 0.5,
          transition: true,
          expression: {
            interpolated: true,
            parameters: ["zoom"]
          }
        }
      };
      var { Properties, Transitionable, DataConstantProperty } = require_properties2();
      var LightPositionProperty = class {
        constructor(specification) {
          this.specification = specification;
          this.specification["property-type"] = "data-constant";
        }
        possiblyEvaluate(value, parameters) {
          return sphericalToCartesian(value.expression.evaluate(parameters));
        }
        interpolate(a, b, t) {
          return {
            x: interpolate2(a.x, b.x, t),
            y: interpolate2(a.y, b.y, t),
            z: interpolate2(a.z, b.z, t)
          };
        }
      };
      var properties = new Properties({
        anchor: new DataConstantProperty(lightSpec.anchor),
        position: new LightPositionProperty(lightSpec.position),
        color: new DataConstantProperty(lightSpec.color),
        intensity: new DataConstantProperty(lightSpec.intensity)
      });
      var TRANSITION_SUFFIX = "-transition";
      var Light = class extends Evented3 {
        constructor(lightOptions) {
          super();
          this._transitionable = new Transitionable(properties);
          this.setLight(lightOptions);
          this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(options) {
          for (const name in options) {
            const value = options[name];
            if (name.endsWith(TRANSITION_SUFFIX)) {
              this._transitionable.setTransition(name.slice(0, -TRANSITION_SUFFIX.length), value);
            } else {
              this._transitionable.setValue(name, value);
            }
          }
        }
        updateTransitions(parameters) {
          this._transitioning = this._transitionable.transitioned(parameters, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(parameters) {
          this.properties = this._transitioning.possiblyEvaluate(parameters);
        }
      };
      module.exports = Light;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/line_atlas.js
  var require_line_atlas = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/line_atlas.js"(exports, module) {
      var warn = require_warn();
      var LineAtlas = class {
        constructor(width, height) {
          this.width = width;
          this.height = height;
          this.nextRow = 0;
          this.bytes = 4;
          this.data = new Uint8Array(this.width * this.height * this.bytes);
          this.positions = {};
        }
        /**
         * Get or create a dash line pattern.
         *
         * @param {Array<number>} dasharray
         * @param {boolean} round whether to add circle caps in between dash segments
         * @returns {Object} position of dash texture in { y, height, width }
         * @private
         */
        getDash(dasharray, round) {
          const key = dasharray.join(",") + String(round);
          if (!this.positions[key]) {
            this.positions[key] = this.addDash(dasharray, round);
          }
          return this.positions[key];
        }
        addDash(dasharray, round) {
          const n = round ? 7 : 0;
          const height = 2 * n + 1;
          const offset = 128;
          if (this.nextRow + height > this.height) {
            warn.once("LineAtlas out of space");
            return null;
          }
          let length = 0;
          for (let i = 0; i < dasharray.length; i++) {
            length += dasharray[i];
          }
          const stretch = this.width / length;
          const halfWidth = stretch / 2;
          const oddLength = dasharray.length % 2 === 1;
          for (let y = -n; y <= n; y++) {
            const row = this.nextRow + n + y;
            const index = this.width * row;
            let left = oddLength ? -dasharray[dasharray.length - 1] : 0;
            let right = dasharray[0];
            let partIndex = 1;
            for (let x = 0; x < this.width; x++) {
              while (right < x / stretch) {
                left = right;
                right = right + dasharray[partIndex];
                if (oddLength && partIndex === dasharray.length - 1) {
                  right += dasharray[0];
                }
                partIndex++;
              }
              const distLeft = Math.abs(x - left * stretch);
              const distRight = Math.abs(x - right * stretch);
              const dist = Math.min(distLeft, distRight);
              const inside = partIndex % 2 === 1;
              let signedDistance;
              if (round) {
                const distMiddle = n ? y / n * (halfWidth + 1) : 0;
                if (inside) {
                  const distEdge = halfWidth - Math.abs(distMiddle);
                  signedDistance = Math.sqrt(dist * dist + distEdge * distEdge);
                } else {
                  signedDistance = halfWidth - Math.sqrt(dist * dist + distMiddle * distMiddle);
                }
              } else {
                signedDistance = (inside ? 1 : -1) * dist;
              }
              this.data[3 + (index + x) * 4] = Math.max(0, Math.min(255, signedDistance + offset));
            }
          }
          const pos = {
            y: (this.nextRow + n + 0.5) / this.height,
            height: 2 * n / this.height,
            width: length
          };
          this.nextRow += height;
          this.dirty = true;
          return pos;
        }
        bind(context) {
          const gl = context.gl;
          if (!this.texture) {
            this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
          } else {
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            if (this.dirty) {
              this.dirty = false;
              gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
            }
          }
        }
      };
      module.exports = LineAtlas;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/unique_id.js
  var require_unique_id = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/unique_id.js"(exports, module) {
      var id = 1;
      module.exports = function uniqueId() {
        return id++;
      };
    }
  });

  // node_modules/grid-index/grid-index.js
  var require_grid_index = __commonJS({
    "node_modules/grid-index/grid-index.js"(exports, module) {
      "use strict";
      module.exports = GridIndex;
      var NUM_PARAMS = 3;
      function GridIndex(extent, n, padding) {
        var cells = this.cells = [];
        if (extent instanceof ArrayBuffer) {
          this.arrayBuffer = extent;
          var array = new Int32Array(this.arrayBuffer);
          extent = array[0];
          n = array[1];
          padding = array[2];
          this.d = n + 2 * padding;
          for (var k = 0; k < this.d * this.d; k++) {
            var start = array[NUM_PARAMS + k];
            var end = array[NUM_PARAMS + k + 1];
            cells.push(start === end ? null : array.subarray(start, end));
          }
          var keysOffset = array[NUM_PARAMS + cells.length];
          var bboxesOffset = array[NUM_PARAMS + cells.length + 1];
          this.keys = array.subarray(keysOffset, bboxesOffset);
          this.bboxes = array.subarray(bboxesOffset);
          this.insert = this._insertReadonly;
        } else {
          this.d = n + 2 * padding;
          for (var i = 0; i < this.d * this.d; i++) {
            cells.push([]);
          }
          this.keys = [];
          this.bboxes = [];
        }
        this.n = n;
        this.extent = extent;
        this.padding = padding;
        this.scale = n / extent;
        this.uid = 0;
        var p = padding / n * extent;
        this.min = -p;
        this.max = extent + p;
      }
      GridIndex.prototype.insert = function(key, x1, y1, x2, y2) {
        this._forEachCell(x1, y1, x2, y2, this._insertCell, this.uid++);
        this.keys.push(key);
        this.bboxes.push(x1);
        this.bboxes.push(y1);
        this.bboxes.push(x2);
        this.bboxes.push(y2);
      };
      GridIndex.prototype._insertReadonly = function() {
        throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
      };
      GridIndex.prototype._insertCell = function(x1, y1, x2, y2, cellIndex, uid) {
        this.cells[cellIndex].push(uid);
      };
      GridIndex.prototype.query = function(x1, y1, x2, y2, intersectionTest) {
        var min = this.min;
        var max = this.max;
        if (x1 <= min && y1 <= min && max <= x2 && max <= y2 && !intersectionTest) {
          return Array.prototype.slice.call(this.keys);
        } else {
          var result = [];
          var seenUids = {};
          this._forEachCell(x1, y1, x2, y2, this._queryCell, result, seenUids, intersectionTest);
          return result;
        }
      };
      GridIndex.prototype._queryCell = function(x1, y1, x2, y2, cellIndex, result, seenUids, intersectionTest) {
        var cell = this.cells[cellIndex];
        if (cell !== null) {
          var keys = this.keys;
          var bboxes = this.bboxes;
          for (var u = 0; u < cell.length; u++) {
            var uid = cell[u];
            if (seenUids[uid] === void 0) {
              var offset = uid * 4;
              if (intersectionTest ? intersectionTest(bboxes[offset + 0], bboxes[offset + 1], bboxes[offset + 2], bboxes[offset + 3]) : x1 <= bboxes[offset + 2] && y1 <= bboxes[offset + 3] && x2 >= bboxes[offset + 0] && y2 >= bboxes[offset + 1]) {
                seenUids[uid] = true;
                result.push(keys[uid]);
              } else {
                seenUids[uid] = false;
              }
            }
          }
        }
      };
      GridIndex.prototype._forEachCell = function(x1, y1, x2, y2, fn, arg1, arg2, intersectionTest) {
        var cx1 = this._convertToCellCoord(x1);
        var cy1 = this._convertToCellCoord(y1);
        var cx2 = this._convertToCellCoord(x2);
        var cy2 = this._convertToCellCoord(y2);
        for (var x = cx1; x <= cx2; x++) {
          for (var y = cy1; y <= cy2; y++) {
            var cellIndex = this.d * y + x;
            if (intersectionTest && !intersectionTest(
              this._convertFromCellCoord(x),
              this._convertFromCellCoord(y),
              this._convertFromCellCoord(x + 1),
              this._convertFromCellCoord(y + 1)
            )) continue;
            if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2, intersectionTest)) return;
          }
        }
      };
      GridIndex.prototype._convertFromCellCoord = function(x) {
        return (x - this.padding) / this.scale;
      };
      GridIndex.prototype._convertToCellCoord = function(x) {
        return Math.max(0, Math.min(this.d - 1, Math.floor(x * this.scale) + this.padding));
      };
      GridIndex.prototype.toArrayBuffer = function() {
        if (this.arrayBuffer) return this.arrayBuffer;
        var cells = this.cells;
        var metadataLength = NUM_PARAMS + this.cells.length + 1 + 1;
        var totalCellLength = 0;
        for (var i = 0; i < this.cells.length; i++) {
          totalCellLength += this.cells[i].length;
        }
        var array = new Int32Array(metadataLength + totalCellLength + this.keys.length + this.bboxes.length);
        array[0] = this.extent;
        array[1] = this.n;
        array[2] = this.padding;
        var offset = metadataLength;
        for (var k = 0; k < cells.length; k++) {
          var cell = cells[k];
          array[NUM_PARAMS + k] = offset;
          array.set(cell, offset);
          offset += cell.length;
        }
        array[NUM_PARAMS + cells.length] = offset;
        array.set(this.keys, offset);
        offset += this.keys.length;
        array[NUM_PARAMS + cells.length + 1] = offset;
        array.set(this.bboxes, offset);
        offset += this.bboxes.length;
        return array.buffer;
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/web_worker_transfer.js
  var require_web_worker_transfer = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/web_worker_transfer.js"(exports, module) {
      var Grid = require_grid_index();
      var { Color } = require_style_expressions();
      var {
        CompoundExpression,
        definitions: expressions,
        StylePropertyFunction,
        StyleExpression,
        ZoomDependentExpression,
        ZoomConstantExpression
      } = require_style_expressions();
      var { register, serialize, deserialize } = require_transfer_registry();
      module.exports = {
        serialize,
        deserialize
      };
      Grid.serialize = function serializeGrid(grid, transferables) {
        const buffer = grid.toArrayBuffer();
        if (transferables) {
          transferables.push(buffer);
        }
        return { buffer };
      };
      Grid.deserialize = function deserializeGrid(serialized) {
        return new Grid(serialized.buffer);
      };
      register("Grid", Grid);
      register("Color", Color);
      register("Error", Error);
      register("StylePropertyFunction", StylePropertyFunction);
      register("StyleExpression", StyleExpression, { omit: ["_evaluator"] });
      register("ZoomDependentExpression", ZoomDependentExpression);
      register("ZoomConstantExpression", ZoomConstantExpression);
      register("CompoundExpression", CompoundExpression, { omit: ["_evaluate"] });
      for (const name in expressions) {
        if (expressions[name]._classRegistryKey) continue;
        register(`Expression_${name}`, expressions[name]);
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/actor.js
  var require_actor = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/actor.js"(exports, module) {
      var { serialize, deserialize } = require_web_worker_transfer();
      module.exports = actor;
      function actor(target, parent, mapId, name) {
        const promises = /* @__PURE__ */ new Map();
        let callbackID = Number.MIN_SAFE_INTEGER;
        target.addEventListener("message", receive, false);
        return {
          send,
          receive,
          remove,
          name
        };
        function send(type, data, targetMapId) {
          const id = `${mapId}:${callbackID++}`;
          const p = Promise.withResolvers();
          promises.set(id, p);
          postMessage(targetMapId, id, type, data);
          return p.promise;
        }
        async function receive(message) {
          const { data } = message;
          const { id, type, targetMapId } = data;
          if (targetMapId && mapId !== targetMapId) return;
          if (type === "<response>") {
            const p = promises.get(id);
            if (p) {
              promises.delete(id);
              if (data.error) {
                p.reject(deserialize(data.error));
              } else {
                p.resolve(deserialize(data.data));
              }
            }
            return;
          }
          if (typeof id !== "undefined") {
            let perform;
            if (parent[type]) {
              perform = () => parent[type](data.sourceMapId, deserialize(data.data));
            } else if (parent.getWorkerSource) {
              const [sourcetype, method] = type.split(".");
              const params = deserialize(data.data);
              const workerSource = parent.getWorkerSource(data.sourceMapId, sourcetype, params.source);
              perform = () => workerSource[method](params);
            } else {
              return;
            }
            try {
              const result = await perform();
              postMessage(data.sourceMapId, id, "<response>", result);
            } catch (err) {
              postMessage(data.sourceMapId, id, "<response>", void 0, err);
            }
            return;
          }
          parent[type](deserialize(data.data));
        }
        function remove() {
          target.removeEventListener("message", receive, false);
        }
        function postMessage(targetMapId, id, type, data, err) {
          const buffers = [];
          const payload = {
            targetMapId,
            sourceMapId: mapId,
            type,
            id,
            data: serialize(data, buffers)
          };
          if (err) {
            payload.error = serialize(err);
          }
          target.postMessage(payload, buffers);
        }
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/dispatcher.js
  var require_dispatcher = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/dispatcher.js"(exports, module) {
      var uniqueId = require_unique_id();
      var actor = require_actor();
      module.exports = dispatcher;
      function dispatcher(workerPool, parent, makeActor = actor) {
        let currentActor = -1;
        const id = uniqueId();
        const workers = workerPool.acquire(id);
        const actors = workers.map((worker, i) => makeActor(worker, parent, id, `Worker ${i}`));
        function broadcast(type, data) {
          const tasks = actors.map((actor2) => actor2.send(type, data));
          return Promise.all(tasks);
        }
        function nextActorId() {
          currentActor += 1;
          if (currentActor === actors.length) {
            currentActor = 0;
          }
          return currentActor;
        }
        function send(type, data, targetID = nextActorId()) {
          return actors[targetID]?.send(type, data) ?? Promise.resolve();
        }
        function remove() {
          actors.forEach((actor2) => actor2.remove());
          actors.length = 0;
          workerPool.release(id);
        }
        function nextWorkerId(workerId = nextActorId()) {
          return workerId;
        }
        return {
          get id() {
            return id;
          },
          broadcast,
          send,
          nextWorkerId,
          remove
        };
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/load_tilejson.js
  var require_load_tilejson = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/load_tilejson.js"(exports, module) {
      var { pick } = require_object();
      module.exports = function(tileJSON) {
        return tileJSON.resourceSets ? fromResourseSets(tileJSON) : fromTileJSON(tileJSON);
      };
      function fromTileJSON(tileJSON) {
        const result = pick(tileJSON, ["tiles", "minzoom", "maxzoom", "attribution", "bounds"]);
        if (tileJSON.vector_layers) {
          result.vectorLayers = tileJSON.vector_layers;
          result.vectorLayerIds = result.vectorLayers.map((layer) => layer.id);
        }
        return result;
      }
      function fromResourseSets(tileJSON) {
        const { resourceSets } = tileJSON;
        if (!resourceSets.length) {
          throw new Error("expected resources");
        }
        const { resources } = resourceSets[0];
        if (!resources?.length) {
          throw new Error("expected resources");
        }
        const { imageUrl, imageUrlSubdomains } = resources[0];
        const result = {
          tiles: imageUrlSubdomains.map((sub) => imageUrl.replace("{subdomain}", sub).replace("http:", "https:")),
          ...tileJSON
        };
        delete result.url;
        return result;
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/geo/lng_lat.js
  var require_lng_lat = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/geo/lng_lat.js"(exports, module) {
      var { wrap } = require_util();
      var LngLat = class _LngLat {
        constructor(lng, lat) {
          if (isNaN(lng) || isNaN(lat)) {
            throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);
          }
          this.lng = +lng;
          this.lat = +lat;
          if (this.lat > 90 || this.lat < -90) {
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
        }
        /**
         * Returns a new `LngLat` object whose longitude is wrapped to the range (-180, 180).
         *
         * @returns {LngLat} The wrapped `LngLat` object.
         * @example
         * var ll = new mapboxgl.LngLat(286.0251, 40.7736);
         * var wrapped = ll.wrap();
         * wrapped.lng; // = -73.9749
         */
        wrap() {
          return new _LngLat(wrap(this.lng, -180, 180), this.lat);
        }
        /**
         * Returns the coordinates represented as an array of two numbers.
         *
         * @returns {Array<number>} The coordinates represeted as an array of longitude and latitude.
         * @example
         * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
         * ll.toArray(); // = [-73.9749, 40.7736]
         */
        toArray() {
          return [this.lng, this.lat];
        }
        /**
         * Returns the coordinates represent as a string.
         *
         * @returns {string} The coordinates represented as a string of the format `'LngLat(lng, lat)'`.
         * @example
         * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
         * ll.toString(); // = "LngLat(-73.9749, 40.7736)"
         */
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        /**
         * Returns a `LngLatBounds` from the coordinates extended by a given `radius`.
         *
         * @param {number} radius Distance in meters from the coordinates to extend the bounds.
         * @returns {LngLatBounds} A new `LngLatBounds` object representing the coordinates extended by the `radius`.
         * @example
         * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
         * ll.toBounds(100).toArray(); // = [[-73.97501862141328, 40.77351016847229], [-73.97478137858673, 40.77368983152771]]
         */
        toBounds(radius) {
          const earthCircumferenceInMetersAtEquator = 40075017;
          const latAccuracy = 360 * radius / earthCircumferenceInMetersAtEquator;
          const lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
          const LngLatBounds = require_lng_lat_bounds();
          return new LngLatBounds(
            new _LngLat(this.lng - lngAccuracy, this.lat - latAccuracy),
            new _LngLat(this.lng + lngAccuracy, this.lat + latAccuracy)
          );
        }
        /**
         * Converts an array of two numbers to a `LngLat` object.
         *
         * If a `LngLat` object is passed in, the function returns it unchanged.
         *
         * @param {LngLatLike} input An array of two numbers to convert, or a `LngLat` object to return.
         * @returns {LngLat} A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.
         * @example
         * var arr = [-73.9749, 40.7736];
         * var ll = mapboxgl.LngLat.convert(arr);
         * ll;   // = LngLat {lng: -73.9749, lat: 40.7736}
         */
        static convert(input) {
          if (input instanceof _LngLat) {
            return input;
          }
          if (Array.isArray(input) && (input.length === 2 || input.length === 3)) {
            return new _LngLat(Number(input[0]), Number(input[1]));
          }
          if (!Array.isArray(input) && typeof input === "object" && input !== null) {
            return new _LngLat(Number(input.lng), Number(input.lat));
          }
          throw new Error(
            "`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]"
          );
        }
      };
      module.exports = LngLat;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/geo/lng_lat_bounds.js
  var require_lng_lat_bounds = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/geo/lng_lat_bounds.js"(exports, module) {
      var LngLat = require_lng_lat();
      var LngLatBounds = class _LngLatBounds {
        // This constructor is too flexible to type. It should not be so flexible.
        constructor(sw, ne) {
          if (!sw) {
            return;
          }
          if (ne) {
            this.setSouthWest(sw).setNorthEast(ne);
          } else if (sw.length === 4) {
            this.setSouthWest([sw[0], sw[1]]).setNorthEast([sw[2], sw[3]]);
          } else {
            this.setSouthWest(sw[0]).setNorthEast(sw[1]);
          }
        }
        /**
         * Set the northeast corner of the bounding box
         *
         * @param {LngLatLike} ne
         * @returns {LngLatBounds} `this`
         */
        setNorthEast(ne) {
          this._ne = ne instanceof LngLat ? new LngLat(ne.lng, ne.lat) : LngLat.convert(ne);
          return this;
        }
        /**
         * Set the southwest corner of the bounding box
         *
         * @param {LngLatLike} sw
         * @returns {LngLatBounds} `this`
         */
        setSouthWest(sw) {
          this._sw = sw instanceof LngLat ? new LngLat(sw.lng, sw.lat) : LngLat.convert(sw);
          return this;
        }
        /**
         * Extend the bounds to include a given LngLat or LngLatBounds.
         *
         * @param {LngLat|LngLatBounds} obj object to extend to
         * @returns {LngLatBounds} `this`
         */
        extend(obj) {
          const sw = this._sw;
          const ne = this._ne;
          let sw2;
          let ne2;
          if (obj instanceof LngLat) {
            sw2 = obj;
            ne2 = obj;
          } else if (obj instanceof _LngLatBounds) {
            sw2 = obj._sw;
            ne2 = obj._ne;
            if (!sw2 || !ne2) return this;
          } else {
            if (Array.isArray(obj)) {
              if (obj.every(Array.isArray)) {
                return this.extend(_LngLatBounds.convert(obj));
              }
              return this.extend(LngLat.convert(obj));
            }
            return this;
          }
          if (!sw && !ne) {
            this._sw = new LngLat(sw2.lng, sw2.lat);
            this._ne = new LngLat(ne2.lng, ne2.lat);
          } else {
            sw.lng = Math.min(sw2.lng, sw.lng);
            sw.lat = Math.min(sw2.lat, sw.lat);
            ne.lng = Math.max(ne2.lng, ne.lng);
            ne.lat = Math.max(ne2.lat, ne.lat);
          }
          return this;
        }
        /**
         * Returns the geographical coordinate equidistant from the bounding box's corners.
         *
         * @returns {LngLat} The bounding box's center.
         * @example
         * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
         * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}
         */
        getCenter() {
          return new LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        /**
         * Returns the southwest corner of the bounding box.
         *
         * @returns {LngLat} The southwest corner of the bounding box.
         */
        getSouthWest() {
          return this._sw;
        }
        /**
         * Returns the northeast corner of the bounding box.
         *
         * @returns {LngLat} The northeast corner of the bounding box.
         */
        getNorthEast() {
          return this._ne;
        }
        /**
         * Returns the northwest corner of the bounding box.
         *
         * @returns {LngLat} The northwest corner of the bounding box.
         */
        getNorthWest() {
          return new LngLat(this.getWest(), this.getNorth());
        }
        /**
         * Returns the southeast corner of the bounding box.
         *
         * @returns {LngLat} The southeast corner of the bounding box.
         */
        getSouthEast() {
          return new LngLat(this.getEast(), this.getSouth());
        }
        /**
         * Returns the west edge of the bounding box.
         *
         * @returns {number} The west edge of the bounding box.
         */
        getWest() {
          return this._sw.lng;
        }
        /**
         * Returns the south edge of the bounding box.
         *
         * @returns {number} The south edge of the bounding box.
         */
        getSouth() {
          return this._sw.lat;
        }
        /**
         * Returns the east edge of the bounding box.
         *
         * @returns {number} The east edge of the bounding box.
         */
        getEast() {
          return this._ne.lng;
        }
        /**
         * Returns the north edge of the bounding box.
         *
         * @returns {number} The north edge of the bounding box.
         */
        getNorth() {
          return this._ne.lat;
        }
        /**
         * Returns the bounding box represented as an array.
         *
         * @returns {Array<Array<number>>} The bounding box represented as an array, consisting of the
         *   southwest and northeast coordinates of the bounding represented as arrays of numbers.
         * @example
         * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
         * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]
         */
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        /**
         * Return the bounding box represented as a string.
         *
         * @returns {string} The bounding box represents as a string of the format
         *   `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.
         * @example
         * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
         * llb.toString(); // = "LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))"
         */
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        /**
         * Check if the bounding box is an empty/`null`-type box.
         *
         * @returns {boolean} True if bounds have been defined, otherwise false.
         */
        isEmpty() {
          return !(this._sw && this._ne);
        }
        /**
         * Converts an array to a `LngLatBounds` object.
         *
         * If a `LngLatBounds` object is passed in, the function returns it unchanged.
         *
         * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.
         *
         * @param {LngLatBoundsLike} input An array of two coordinates to convert, or a `LngLatBounds` object to return.
         * @returns {LngLatBounds} A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.
         * @example
         * var arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
         * var llb = mapboxgl.LngLatBounds.convert(arr);
         * llb;   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}
         */
        static convert(input) {
          if (!input || input instanceof _LngLatBounds) return input;
          return new _LngLatBounds(input);
        }
      };
      module.exports = LngLatBounds;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/tile_bounds.js
  var require_tile_bounds = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/tile_bounds.js"(exports, module) {
      var LngLatBounds = require_lng_lat_bounds();
      var { clamp } = require_util();
      var TileBounds = class {
        constructor(bounds2, minzoom, maxzoom) {
          this.bounds = LngLatBounds.convert(this.validateBounds(bounds2));
          this.minzoom = minzoom || 0;
          this.maxzoom = maxzoom || 24;
        }
        validateBounds(bounds2) {
          if (!Array.isArray(bounds2) || bounds2.length !== 4) return [-180, -90, 180, 90];
          return [Math.max(-180, bounds2[0]), Math.max(-90, bounds2[1]), Math.min(180, bounds2[2]), Math.min(90, bounds2[3])];
        }
        contains(tileID) {
          const level = {
            minX: Math.floor(this.lngX(this.bounds.getWest(), tileID.z)),
            minY: Math.floor(this.latY(this.bounds.getNorth(), tileID.z)),
            maxX: Math.ceil(this.lngX(this.bounds.getEast(), tileID.z)),
            maxY: Math.ceil(this.latY(this.bounds.getSouth(), tileID.z))
          };
          const hit = tileID.x >= level.minX && tileID.x < level.maxX && tileID.y >= level.minY && tileID.y < level.maxY;
          return hit;
        }
        lngX(lng, zoom) {
          return (lng + 180) * (2 ** zoom / 360);
        }
        latY(lat, zoom) {
          const f = clamp(Math.sin(Math.PI / 180 * lat), -0.9999, 0.9999);
          const scale = 2 ** zoom / (2 * Math.PI);
          return 2 ** (zoom - 1) + 0.5 * Math.log((1 + f) / (1 - f)) * -scale;
        }
      };
      module.exports = TileBounds;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style-spec/feature_filter/index.js
  var require_feature_filter = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style-spec/feature_filter/index.js"(exports, module) {
      var { createExpression } = require_style_expressions();
      module.exports = createFilter;
      createFilter.isExpressionFilter = isExpressionFilter;
      function isExpressionFilter(filter) {
        if (filter === true || filter === false) {
          return true;
        }
        if (!Array.isArray(filter) || filter.length === 0) {
          return false;
        }
        switch (filter[0]) {
          case "has":
            return filter.length >= 2 && filter[1] !== "$id" && filter[1] !== "$type";
          case "in":
          case "!in":
          case "!has":
          case "none":
            return false;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return filter.length !== 3 || Array.isArray(filter[1]) || Array.isArray(filter[2]);
          case "any":
          case "all":
            for (let i = 1; i < filter.length; i++) {
              const f = filter[i];
              if (typeof f !== "boolean" && !isExpressionFilter(f)) {
                return false;
              }
            }
            return true;
          default:
            return true;
        }
      }
      var filterSpec = {
        type: "boolean",
        default: false,
        transition: false,
        "property-type": "data-driven",
        expression: {
          interpolated: false,
          parameters: ["zoom", "feature"]
        }
      };
      function createFilter(filter) {
        if (filter === null || filter === void 0) {
          return () => true;
        }
        if (!isExpressionFilter(filter)) {
          filter = convertFilter(filter);
        }
        const compiled = createExpression(filter, filterSpec);
        if (compiled.result === "error") {
          throw new Error(compiled.value.map((err) => `${err.key}: ${err.message}`).join(", "));
        }
        return (globalProperties, feature) => compiled.value.evaluate(globalProperties, feature);
      }
      function compare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      function convertFilter(filter) {
        if (!filter) return true;
        const [op, ...args] = filter;
        if (filter.length <= 1) return op !== "any";
        switch (op) {
          case "!=":
            return convertNegation(convertComparisonOp("==", ...args));
          case "==":
          case "<":
          case ">":
          case "<=":
          case ">=":
            return convertComparisonOp(op, ...args);
          case "any":
            return convertDisjunctionOp(args);
          case "all":
            return ["all", ...args.map(convertFilter)];
          case "none":
            return ["all", ...args.map(convertFilter).map(convertNegation)];
          case "in":
            return convertInOp(args);
          case "!in":
            return convertNegation(convertInOp(args));
          case "has":
            return convertHasOp(args[0]);
          case "!has":
            return convertNegation(convertHasOp(args[0]));
          default:
            return true;
        }
      }
      function convertComparisonOp(op, property, value) {
        switch (property) {
          case "$type":
            return [`filter-type-${op}`, value];
          case "$id":
            return [`filter-id-${op}`, value];
          default:
            return [`filter-${op}`, property, value];
        }
      }
      function convertDisjunctionOp(filters) {
        return ["any", ...filters.map(convertFilter)];
      }
      function convertInOp([property, ...values]) {
        if (values.length === 0) {
          return false;
        }
        switch (property) {
          case "$type":
            return ["filter-type-in", ["literal", values]];
          case "$id":
            return ["filter-id-in", ["literal", values]];
          default:
            return isUniformLarge(values) ? ["filter-in-large", property, ["literal", values.sort(compare)]] : ["filter-in-small", property, ["literal", values]];
        }
      }
      function isUniformLarge(values) {
        if (values.length < 200) return false;
        const type = typeof values[0];
        return values.every((v) => typeof v === type);
      }
      function convertHasOp(property) {
        switch (property) {
          case "$type":
            return true;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", property];
        }
      }
      function convertNegation(filter) {
        return ["!", filter];
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/dictionary_coder.js
  var require_dictionary_coder = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/dictionary_coder.js"(exports, module) {
      var assert = require_nanoassert();
      module.exports = dictionaryCoder;
      function dictionaryCoder(strings) {
        const numberToString = strings.sort();
        const stringToNumber = new Map(numberToString.map((s, i) => [s, i]));
        return {
          encode(string) {
            return stringToNumber.get(string);
          },
          decode(n) {
            assert(n < numberToString.length);
            return numberToString[n];
          }
        };
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }
  });

  // node_modules/@mapwhit/pbf/index.js
  var require_pbf = __commonJS({
    "node_modules/@mapwhit/pbf/index.js"(exports, module) {
      var assert = require_nanoassert();
      var ieee754 = require_ieee754();
      var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
      var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
      var TEXT_DECODER_MIN_LENGTH = 12;
      var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8");
      var Pbf = class _Pbf {
        constructor(buf) {
          this.buf = ArrayBuffer.isView?.(buf) ? buf : new Uint8Array(buf || 0);
          this.pos = 0;
          this.type = 0;
          this.length = this.buf.length;
        }
        destroy() {
          this.buf = null;
        }
        // === READING =================================================================
        readFields(readField, result, end = this.length) {
          while (this.pos < end) {
            const val = this.readVarint();
            const tag = val >> 3;
            const startPos = this.pos;
            this.type = val & 7;
            readField(tag, result, this);
            if (this.pos === startPos) this.skip(val);
          }
          return result;
        }
        readMessage(readField, result) {
          return this.readFields(readField, result, this.readVarint() + this.pos);
        }
        readFixed32() {
          const val = readUInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
        }
        readSFixed32() {
          const val = readInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
        }
        // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
        readFixed64() {
          const val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
        }
        readSFixed64() {
          const val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
        }
        readFloat() {
          const val = ieee754.read(this.buf, this.pos, true, 23, 4);
          this.pos += 4;
          return val;
        }
        readDouble() {
          const val = ieee754.read(this.buf, this.pos, true, 52, 8);
          this.pos += 8;
          return val;
        }
        readVarint(isSigned) {
          const buf = this.buf;
          let b = buf[this.pos++];
          let val = b & 127;
          if (b < 128) return val;
          b = buf[this.pos++];
          val |= (b & 127) << 7;
          if (b < 128) return val;
          b = buf[this.pos++];
          val |= (b & 127) << 14;
          if (b < 128) return val;
          b = buf[this.pos++];
          val |= (b & 127) << 21;
          if (b < 128) return val;
          b = buf[this.pos];
          val |= (b & 15) << 28;
          return readVarintRemainder(val, isSigned, this);
        }
        readVarint64() {
          return this.readVarint(true);
        }
        readSVarint() {
          const num = this.readVarint();
          return num % 2 === 1 ? (num + 1) / -2 : num / 2;
        }
        readBoolean() {
          return Boolean(this.readVarint());
        }
        readString() {
          const end = this.readVarint() + this.pos;
          const pos = this.pos;
          this.pos = end;
          if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
            return readUtf8TextDecoder(this.buf, pos, end);
          }
          return readUtf8(this.buf, pos, end);
        }
        readBytes() {
          const end = this.readVarint() + this.pos;
          const buffer = this.buf.subarray(this.pos, end);
          this.pos = end;
          return buffer;
        }
        // verbose for performance reasons; doesn't affect gzipped size
        readPackedVarint(arr = [], isSigned = false) {
          if (this.type !== _Pbf.Bytes) return arr.push(this.readVarint(isSigned));
          const end = readPackedEnd(this);
          while (this.pos < end) arr.push(this.readVarint(isSigned));
          return arr;
        }
        readPackedSVarint(arr = []) {
          if (this.type !== _Pbf.Bytes) return arr.push(this.readSVarint());
          const end = readPackedEnd(this);
          while (this.pos < end) arr.push(this.readSVarint());
          return arr;
        }
        readPackedBoolean(arr = []) {
          if (this.type !== _Pbf.Bytes) return arr.push(this.readBoolean());
          const end = readPackedEnd(this);
          while (this.pos < end) arr.push(this.readBoolean());
          return arr;
        }
        readPackedFloat(arr = []) {
          if (this.type !== _Pbf.Bytes) return arr.push(this.readFloat());
          const end = readPackedEnd(this);
          while (this.pos < end) arr.push(this.readFloat());
          return arr;
        }
        readPackedDouble(arr = []) {
          if (this.type !== _Pbf.Bytes) return arr.push(this.readDouble());
          const end = readPackedEnd(this);
          while (this.pos < end) arr.push(this.readDouble());
          return arr;
        }
        readPackedFixed32(arr = []) {
          if (this.type !== _Pbf.Bytes) return arr.push(this.readFixed32());
          const end = readPackedEnd(this);
          while (this.pos < end) arr.push(this.readFixed32());
          return arr;
        }
        readPackedSFixed32(arr = []) {
          if (this.type !== _Pbf.Bytes) return arr.push(this.readSFixed32());
          const end = readPackedEnd(this);
          while (this.pos < end) arr.push(this.readSFixed32());
          return arr;
        }
        readPackedFixed64(arr = []) {
          if (this.type !== _Pbf.Bytes) return arr.push(this.readFixed64());
          const end = readPackedEnd(this);
          while (this.pos < end) arr.push(this.readFixed64());
          return arr;
        }
        readPackedSFixed64(arr = []) {
          if (this.type !== _Pbf.Bytes) return arr.push(this.readSFixed64());
          const end = readPackedEnd(this);
          while (this.pos < end) arr.push(this.readSFixed64());
          return arr;
        }
        skip(val) {
          const type = val & 7;
          switch (type) {
            case _Pbf.Varint:
              while (this.buf[this.pos++] > 127) {
              }
              break;
            case _Pbf.Bytes:
              this.pos = this.readVarint() + this.pos;
              break;
            case _Pbf.Fixed32:
              this.pos += 4;
              break;
            case _Pbf.Fixed64:
              this.pos += 8;
              break;
            default:
              assert(false, `Unimplemented type: ${type}`);
          }
        }
        // === WRITING =================================================================
        writeTag(tag, type) {
          this.writeVarint(tag << 3 | type);
        }
        realloc(min) {
          let length = this.length || 16;
          while (length < this.pos + min) length *= 2;
          if (length !== this.length) {
            const buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
          }
        }
        finish() {
          this.length = this.pos;
          this.pos = 0;
          return this.buf.subarray(0, this.length);
        }
        writeFixed32(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
        }
        writeSFixed32(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
        }
        writeFixed64(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        }
        writeSFixed64(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        }
        writeVarint(val) {
          val = +val || 0;
          if (val > 268435455 || val < 0) {
            writeBigVarint(val, this);
            return;
          }
          this.realloc(4);
          this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
          if (val <= 127) return;
          this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
          if (val <= 127) return;
          this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
          if (val <= 127) return;
          this.buf[this.pos++] = val >>> 7 & 127;
        }
        writeSVarint(val) {
          this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
        }
        writeBoolean(val) {
          this.writeVarint(Boolean(val));
        }
        writeString(str) {
          str = String(str);
          this.realloc(str.length * 4);
          this.pos++;
          const startPos = this.pos;
          this.pos = writeUtf8(this.buf, str, this.pos);
          const len = this.pos - startPos;
          if (len >= 128) makeRoomForExtraLength(startPos, len, this);
          this.pos = startPos - 1;
          this.writeVarint(len);
          this.pos += len;
        }
        writeFloat(val) {
          this.realloc(4);
          ieee754.write(this.buf, val, this.pos, true, 23, 4);
          this.pos += 4;
        }
        writeDouble(val) {
          this.realloc(8);
          ieee754.write(this.buf, val, this.pos, true, 52, 8);
          this.pos += 8;
        }
        writeBytes(buffer) {
          const len = buffer.length;
          this.writeVarint(len);
          this.realloc(len);
          for (let i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
        }
        writeRawMessage(fn, obj) {
          this.pos++;
          const startPos = this.pos;
          fn(obj, this);
          const len = this.pos - startPos;
          if (len >= 128) makeRoomForExtraLength(startPos, len, this);
          this.pos = startPos - 1;
          this.writeVarint(len);
          this.pos += len;
        }
        writeMessage(tag, fn, obj) {
          this.writeTag(tag, _Pbf.Bytes);
          this.writeRawMessage(fn, obj);
        }
        writePackedVarint(tag, arr) {
          if (arr.length) this.writeMessage(tag, writePackedVarint, arr);
        }
        writePackedSVarint(tag, arr) {
          if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);
        }
        writePackedBoolean(tag, arr) {
          if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);
        }
        writePackedFloat(tag, arr) {
          if (arr.length) this.writeMessage(tag, writePackedFloat, arr);
        }
        writePackedDouble(tag, arr) {
          if (arr.length) this.writeMessage(tag, writePackedDouble, arr);
        }
        writePackedFixed32(tag, arr) {
          if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);
        }
        writePackedSFixed32(tag, arr) {
          if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr);
        }
        writePackedFixed64(tag, arr) {
          if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);
        }
        writePackedSFixed64(tag, arr) {
          if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr);
        }
        writeBytesField(tag, buffer) {
          this.writeTag(tag, _Pbf.Bytes);
          this.writeBytes(buffer);
        }
        writeFixed32Field(tag, val) {
          this.writeTag(tag, _Pbf.Fixed32);
          this.writeFixed32(val);
        }
        writeSFixed32Field(tag, val) {
          this.writeTag(tag, _Pbf.Fixed32);
          this.writeSFixed32(val);
        }
        writeFixed64Field(tag, val) {
          this.writeTag(tag, _Pbf.Fixed64);
          this.writeFixed64(val);
        }
        writeSFixed64Field(tag, val) {
          this.writeTag(tag, _Pbf.Fixed64);
          this.writeSFixed64(val);
        }
        writeVarintField(tag, val) {
          this.writeTag(tag, _Pbf.Varint);
          this.writeVarint(val);
        }
        writeSVarintField(tag, val) {
          this.writeTag(tag, _Pbf.Varint);
          this.writeSVarint(val);
        }
        writeStringField(tag, str) {
          this.writeTag(tag, _Pbf.Bytes);
          this.writeString(str);
        }
        writeFloatField(tag, val) {
          this.writeTag(tag, _Pbf.Fixed32);
          this.writeFloat(val);
        }
        writeDoubleField(tag, val) {
          this.writeTag(tag, _Pbf.Fixed64);
          this.writeDouble(val);
        }
        writeBooleanField(tag, val) {
          this.writeVarintField(tag, Boolean(val));
        }
      };
      Pbf.Varint = 0;
      Pbf.Fixed64 = 1;
      Pbf.Bytes = 2;
      Pbf.Fixed32 = 5;
      module.exports = Pbf;
      function readVarintRemainder(l, s, p) {
        const { buf } = p;
        let b = buf[p.pos++];
        let h = (b & 112) >> 4;
        if (b < 128) return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 3;
        if (b < 128) return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 10;
        if (b < 128) return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 17;
        if (b < 128) return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 24;
        if (b < 128) return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 1) << 31;
        if (b < 128) return toNum(l, h, s);
        assert(false, "Expected varint not more than 10 bytes");
      }
      function readPackedEnd(pbf) {
        return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
      }
      function toNum(low, high, isSigned) {
        if (isSigned) {
          return high * 4294967296 + (low >>> 0);
        }
        return (high >>> 0) * 4294967296 + (low >>> 0);
      }
      function writeBigVarint(val, pbf) {
        if (true) {
          assert(val < 18446744073709552e3 && val >= -18446744073709552e3, "Given varint doesn't fit into 10 bytes");
        }
        let low;
        let high;
        if (val >= 0) {
          low = val % 4294967296 | 0;
          high = val / 4294967296 | 0;
        } else {
          low = ~(-val % 4294967296);
          high = ~(-val / 4294967296);
          if (low ^ 4294967295) {
            low = low + 1 | 0;
          } else {
            low = 0;
            high = high + 1 | 0;
          }
        }
        pbf.realloc(10);
        writeBigVarintLow(low, high, pbf);
        writeBigVarintHigh(high, pbf);
      }
      function writeBigVarintLow(low, _high, pbf) {
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos] = low & 127;
      }
      function writeBigVarintHigh(high, pbf) {
        const lsb = (high & 7) << 4;
        pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
        if (!high) return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high) return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high) return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high) return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high) return;
        pbf.buf[pbf.pos++] = high & 127;
      }
      function makeRoomForExtraLength(startPos, len, pbf) {
        const extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
        pbf.realloc(extraLen);
        for (let i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
      }
      function writePackedVarint(arr, pbf) {
        for (let i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);
      }
      function writePackedSVarint(arr, pbf) {
        for (let i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);
      }
      function writePackedFloat(arr, pbf) {
        for (let i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);
      }
      function writePackedDouble(arr, pbf) {
        for (let i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);
      }
      function writePackedBoolean(arr, pbf) {
        for (let i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);
      }
      function writePackedFixed32(arr, pbf) {
        for (let i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);
      }
      function writePackedSFixed32(arr, pbf) {
        for (let i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]);
      }
      function writePackedFixed64(arr, pbf) {
        for (let i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);
      }
      function writePackedSFixed64(arr, pbf) {
        for (let i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]);
      }
      function readUInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
      }
      function writeInt32(buf, val, pos) {
        buf[pos] = val;
        buf[pos + 1] = val >>> 8;
        buf[pos + 2] = val >>> 16;
        buf[pos + 3] = val >>> 24;
      }
      function readInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
      }
      function readUtf8(buf, pos, end) {
        let str = "";
        let i = pos;
        while (i < end) {
          const b0 = buf[i];
          let c = null;
          let bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
          if (i + bytesPerSequence > end) break;
          let b1;
          let b2;
          let b3;
          if (bytesPerSequence === 1) {
            if (b0 < 128) {
              c = b0;
            }
          } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 192) === 128) {
              c = (b0 & 31) << 6 | b1 & 63;
              if (c <= 127) {
                c = null;
              }
            }
          } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 192) === 128 && (b2 & 192) === 128) {
              c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
              if (c <= 2047 || c >= 55296 && c <= 57343) {
                c = null;
              }
            }
          } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
              c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
              if (c <= 65535 || c >= 1114112) {
                c = null;
              }
            }
          }
          if (c === null) {
            c = 65533;
            bytesPerSequence = 1;
          } else if (c > 65535) {
            c -= 65536;
            str += String.fromCharCode(c >>> 10 & 1023 | 55296);
            c = 56320 | c & 1023;
          }
          str += String.fromCharCode(c);
          i += bytesPerSequence;
        }
        return str;
      }
      function readUtf8TextDecoder(buf, pos, end) {
        return utf8TextDecoder.decode(buf.subarray(pos, end));
      }
      function writeUtf8(buf, str, pos) {
        for (let i = 0, c, lead; i < str.length; i++) {
          c = str.charCodeAt(i);
          if (c > 55295 && c < 57344) {
            if (lead) {
              if (c < 56320) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
                lead = c;
                continue;
              }
              c = lead - 55296 << 10 | c - 56320 | 65536;
              lead = null;
            } else {
              if (c > 56319 || i + 1 === str.length) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
              } else {
                lead = c;
              }
              continue;
            }
          } else if (lead) {
            buf[pos++] = 239;
            buf[pos++] = 191;
            buf[pos++] = 189;
            lead = null;
          }
          if (c < 128) {
            buf[pos++] = c;
          } else {
            if (c < 2048) {
              buf[pos++] = c >> 6 | 192;
            } else {
              if (c < 65536) {
                buf[pos++] = c >> 12 | 224;
              } else {
                buf[pos++] = c >> 18 | 240;
                buf[pos++] = c >> 12 & 63 | 128;
              }
              buf[pos++] = c >> 6 & 63 | 128;
            }
            buf[pos++] = c & 63 | 128;
          }
        }
        return pos;
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/vectortile_to_geojson.js
  var require_vectortile_to_geojson = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/vectortile_to_geojson.js"(exports, module) {
      var Feature = class {
        constructor(vectorTileFeature, z, x, y) {
          this.type = "Feature";
          this._vectorTileFeature = vectorTileFeature;
          vectorTileFeature._z = z;
          vectorTileFeature._x = x;
          vectorTileFeature._y = y;
          this.properties = vectorTileFeature.properties;
          if (vectorTileFeature.id != null) {
            this.id = vectorTileFeature.id;
          }
        }
        get geometry() {
          if (this._geometry === void 0) {
            this._geometry = this._vectorTileFeature.toGeoJSON(
              this._vectorTileFeature._x,
              this._vectorTileFeature._y,
              this._vectorTileFeature._z
            ).geometry;
          }
          return this._geometry;
        }
        set geometry(g) {
          this._geometry = g;
        }
        toJSON() {
          const json = {
            geometry: this.geometry
          };
          for (const i in this) {
            if (i === "_geometry" || i === "_vectorTileFeature") continue;
            json[i] = this[i];
          }
          return json;
        }
      };
      module.exports = Feature;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/feature_index.js
  var require_feature_index = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/feature_index.js"(exports, module) {
      var loadGeometry = require_load_geometry();
      var EXTENT = require_extent();
      var featureFilter = require_feature_filter();
      var Grid = require_grid_index();
      var dictionaryCoder = require_dictionary_coder();
      var vt = require_vector_tile();
      var Protobuf = require_pbf();
      var GeoJSONFeature = require_vectortile_to_geojson();
      var { arraysIntersect } = require_object();
      var { register } = require_transfer_registry();
      var EvaluationParameters = require_evaluation_parameters();
      var { polygonIntersectsBox } = require_intersection_tests();
      var { FeatureIndexArray } = require_array_types();
      var FeatureIndex = class {
        constructor(tileID, grid = new Grid(EXTENT, 16, 0), featureIndexArray = new FeatureIndexArray()) {
          this.tileID = tileID;
          this.grid = grid;
          this.grid3D = new Grid(EXTENT, 16, 0);
          this.featureIndexArray = featureIndexArray;
        }
        insert(feature, geometry, featureIndex, sourceLayerIndex, bucketIndex, is3D) {
          const key = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(featureIndex, sourceLayerIndex, bucketIndex);
          const grid = is3D ? this.grid3D : this.grid;
          for (const ring of geometry) {
            const { minX, minY, maxX, maxY } = getBounds(ring);
            if (minX < EXTENT && minY < EXTENT && maxX >= 0 && maxY >= 0) {
              grid.insert(key, minX, minY, maxX, maxY);
            }
          }
        }
        loadVTLayers() {
          if (!this.vtLayers) {
            this.vtLayers = new vt.VectorTile(new Protobuf(this.rawTileData)).layers;
            this.sourceLayerCoder = dictionaryCoder(this.vtLayers ? Object.keys(this.vtLayers) : ["_geojsonTileLayer"]);
          }
          return this.vtLayers;
        }
        // Finds non-symbol features in this tile at a particular position.
        query(args, styleLayers, sourceFeatureState) {
          this.loadVTLayers();
          const params = args.params || {};
          const pixelsToTileUnits = EXTENT / args.tileSize / args.scale;
          const filter = featureFilter(params.filter);
          const queryGeometry = args.queryGeometry;
          const queryPadding = args.queryPadding * pixelsToTileUnits;
          const bounds2 = getBounds(queryGeometry);
          const matching = this.grid.query(
            bounds2.minX - queryPadding,
            bounds2.minY - queryPadding,
            bounds2.maxX + queryPadding,
            bounds2.maxY + queryPadding
          );
          const cameraBounds = getBounds(args.cameraQueryGeometry);
          const matching3D = this.grid3D.query(
            cameraBounds.minX - queryPadding,
            cameraBounds.minY - queryPadding,
            cameraBounds.maxX + queryPadding,
            cameraBounds.maxY + queryPadding,
            (bx1, by1, bx2, by2) => {
              return polygonIntersectsBox(
                args.cameraQueryGeometry,
                bx1 - queryPadding,
                by1 - queryPadding,
                bx2 + queryPadding,
                by2 + queryPadding
              );
            }
          );
          matching.push(...matching3D);
          matching.sort(topDownFeatureComparator);
          const result = {};
          let previousIndex;
          for (let k = 0; k < matching.length; k++) {
            const index = matching[k];
            if (index === previousIndex) continue;
            previousIndex = index;
            const match = this.featureIndexArray.get(index);
            let featureGeometry = null;
            const intersectionTest = (feature, styleLayer) => {
              if (!featureGeometry) {
                featureGeometry = loadGeometry(feature);
              }
              let featureState = {};
              if (feature.id) {
                featureState = sourceFeatureState.getState(styleLayer.sourceLayer || "_geojsonTileLayer", String(feature.id));
              }
              return styleLayer.queryIntersectsFeature(
                queryGeometry,
                feature,
                featureState,
                featureGeometry,
                this.tileID.canonical.z,
                args.transform,
                pixelsToTileUnits,
                args.pixelPosMatrix
              );
            };
            this.loadMatchingFeature(
              result,
              match.bucketIndex,
              match.sourceLayerIndex,
              match.featureIndex,
              filter,
              params.layers,
              styleLayers,
              intersectionTest
            );
          }
          return result;
        }
        loadMatchingFeature(result, bucketIndex, sourceLayerIndex, featureIndex, filter, filterLayerIDs, styleLayers, intersectionTest) {
          const layerIDs = this.bucketLayerIDs[bucketIndex];
          if (filterLayerIDs && !arraysIntersect(filterLayerIDs, layerIDs)) return;
          const sourceLayerName = this.sourceLayerCoder.decode(sourceLayerIndex);
          const sourceLayer = this.vtLayers[sourceLayerName];
          const feature = sourceLayer.feature(featureIndex);
          if (!filter(new EvaluationParameters(this.tileID.overscaledZ), feature)) return;
          const { x, y, z } = this.tileID.canonical;
          for (const layerID of layerIDs) {
            if (filterLayerIDs && !filterLayerIDs.includes(layerID)) {
              continue;
            }
            const styleLayer = styleLayers[layerID];
            if (!styleLayer) continue;
            const intersectionZ = !intersectionTest || intersectionTest(feature, styleLayer);
            if (!intersectionZ) {
              continue;
            }
            const geojsonFeature = new GeoJSONFeature(feature, z, x, y);
            geojsonFeature.layer = styleLayer.serialize();
            const layerResult = result[layerID] ??= [];
            layerResult.push({ featureIndex, feature: geojsonFeature, intersectionZ });
          }
        }
        // Given a set of symbol indexes that have already been looked up,
        // return a matching set of GeoJSONFeatures
        lookupSymbolFeatures(symbolFeatureIndexes, bucketIndex, sourceLayerIndex, filterSpec, filterLayerIDs, styleLayers) {
          const result = {};
          this.loadVTLayers();
          const filter = featureFilter(filterSpec);
          for (const symbolFeatureIndex of symbolFeatureIndexes) {
            this.loadMatchingFeature(
              result,
              bucketIndex,
              sourceLayerIndex,
              symbolFeatureIndex,
              filter,
              filterLayerIDs,
              styleLayers
            );
          }
          return result;
        }
      };
      register("FeatureIndex", FeatureIndex, { omit: ["rawTileData", "sourceLayerCoder"] });
      module.exports = FeatureIndex;
      function getBounds(geometry) {
        let minX = Number.POSITIVE_INFINITY;
        let minY = Number.POSITIVE_INFINITY;
        let maxX = Number.NEGATIVE_INFINITY;
        let maxY = Number.NEGATIVE_INFINITY;
        for (const { x, y } of geometry) {
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
        return { minX, minY, maxX, maxY };
      }
      function topDownFeatureComparator(a, b) {
        return b - a;
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/vector_tile_source.js
  var require_vector_tile_source = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/vector_tile_source.js"(exports, module) {
      var { Event: Event3, ErrorEvent: ErrorEvent3, Evented: Evented3 } = (init_events(), __toCommonJS(events_exports));
      var { pick } = require_object();
      var loadTileJSON = require_load_tilejson();
      var TileBounds = require_tile_bounds();
      var browser = require_browser();
      require_feature_index();
      var VectorTileSource = class extends Evented3 {
        constructor(id, options, dispatcher, eventedParent) {
          super();
          this.id = id;
          this.dispatcher = dispatcher;
          this.type = "vector";
          this.minzoom = 0;
          this.maxzoom = 22;
          this.scheme = "xyz";
          this.tileSize = 512;
          this.reparseOverscaled = true;
          this.isTileClipped = true;
          Object.assign(this, pick(options, ["url", "scheme", "tileSize"]));
          this._options = Object.assign({ type: "vector" }, options);
          if (this.tileSize !== 512) {
            throw new Error("vector tile sources must have a tileSize of 512");
          }
          this.setEventedParent(eventedParent);
        }
        async load() {
          this.fire(new Event3("dataloading", { dataType: "source" }));
          try {
            const tileJSON = await loadTileJSON(this._options);
            Object.assign(this, tileJSON);
            if (tileJSON.bounds) this.tileBounds = new TileBounds(tileJSON.bounds, this.minzoom, this.maxzoom);
            this.fire(new Event3("data", { dataType: "source", sourceDataType: "metadata" }));
            this.fire(new Event3("data", { dataType: "source", sourceDataType: "content" }));
          } catch (err) {
            this.fire(new ErrorEvent3(err));
          }
        }
        hasTile(tileID) {
          return !this.tileBounds || this.tileBounds.contains(tileID.canonical);
        }
        onAdd(map) {
          this.map = map;
          this.load();
        }
        serialize() {
          return Object.assign({}, this._options);
        }
        async loadTile(tile) {
          if (tile.workerID != null && tile.state === "loading") {
            tile.reloadPromise ??= Promise.withResolvers();
            return tile.reloadPromise.promise;
          }
          const data = await this.#loadTile(tile);
          if (tile.reloadPromise) {
            const { resolve, reject } = tile.reloadPromise;
            tile.reloadPromise = null;
            return this.loadTile(tile).then(resolve, reject);
          }
          return data;
        }
        async #loadTile(tile) {
          try {
            tile.abortController = new window.AbortController();
            const rawData = await this.tiles(tile.tileID.canonical, tile.abortController).catch(() => {
            });
            if (!rawData) {
              const err = new Error("Tile could not be loaded");
              err.status = 404;
              throw err;
            }
            const params = {
              response: { data: rawData.slice() },
              uid: tile.uid,
              tileID: tile.tileID,
              zoom: tile.tileID.overscaledZ,
              tileSize: this.tileSize * tile.tileID.overscaleFactor(),
              type: this.type,
              source: this.id,
              pixelRatio: browser.devicePixelRatio,
              showCollisionBoxes: this.map.showCollisionBoxes
            };
            tile.workerID ??= this.dispatcher.nextWorkerId();
            const data = await this.dispatcher.send("loadTile", params, tile.workerID);
            data.rawTileData = rawData;
            tile.loadVectorData(data, this.map.painter);
          } catch (err) {
            if (tile.aborted) {
              tile.state = "unloaded";
              return;
            }
            tile.state = "errored";
            throw err;
          }
        }
        abortTile(tile) {
          tile.aborted = true;
          tile.abortController.abort();
        }
        unloadTile(tile) {
          tile.unloadVectorData();
        }
        hasTransition() {
          return false;
        }
      };
      module.exports = VectorTileSource;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/raster_tile_source.js
  var require_raster_tile_source = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/raster_tile_source.js"(exports, module) {
      var { pick } = require_object();
      var loadImage = require_image();
      var { Event: Event3, ErrorEvent: ErrorEvent3, Evented: Evented3 } = (init_events(), __toCommonJS(events_exports));
      var loadTileJSON = require_load_tilejson();
      var TileBounds = require_tile_bounds();
      var Texture = require_texture();
      var RasterTileSource = class extends Evented3 {
        constructor(id, options, dispatcher, eventedParent) {
          super();
          this.id = id;
          this.dispatcher = dispatcher;
          this.setEventedParent(eventedParent);
          this.type = "raster";
          this.minzoom = 0;
          this.maxzoom = 22;
          this.roundZoom = true;
          this.scheme = "xyz";
          this.tileSize = 512;
          this._loaded = false;
          this._options = Object.assign({}, options);
          Object.assign(this, pick(options, ["url", "scheme", "tileSize"]));
        }
        async load() {
          this.fire(new Event3("dataloading", { dataType: "source" }));
          try {
            const tileJSON = await loadTileJSON(this._options);
            Object.assign(this, tileJSON);
            if (tileJSON.bounds) this.tileBounds = new TileBounds(tileJSON.bounds, this.minzoom, this.maxzoom);
            this.fire(new Event3("data", { dataType: "source", sourceDataType: "metadata" }));
            this.fire(new Event3("data", { dataType: "source", sourceDataType: "content" }));
          } catch (err) {
            this.fire(new ErrorEvent3(err));
          }
        }
        onAdd(map) {
          this.map = map;
          this.load();
        }
        serialize() {
          return Object.assign({}, this._options);
        }
        hasTile(tileID) {
          return !this.tileBounds || this.tileBounds.contains(tileID.canonical);
        }
        async loadTile(tile) {
          try {
            tile.abortController = new window.AbortController();
            const data = await this.tiles(tile.tileID.canonical, tile.abortController).catch(() => {
            });
            if (!data) {
              const err = new Error("Tile could not be loaded");
              err.status = 404;
              throw err;
            }
            const img = await loadImage(data);
            if (!img) {
              return;
            }
            tile.texture = this.map.painter.getTileTexture(img.width);
            if (tile.texture) {
              tile.texture.update(img, { useMipmap: true });
            } else {
              const { context } = this.map.painter;
              const { gl } = context;
              tile.texture = new Texture(context, img, gl.RGBA, { useMipmap: true });
              tile.texture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE, gl.LINEAR_MIPMAP_NEAREST);
              if (context.extTextureFilterAnisotropic) {
                gl.texParameterf(
                  gl.TEXTURE_2D,
                  context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
                  context.extTextureFilterAnisotropicMax
                );
              }
            }
            tile.state = "loaded";
          } catch (err) {
            if (tile.aborted) {
              tile.state = "unloaded";
              return;
            }
            tile.state = "errored";
            throw err;
          }
        }
        abortTile(tile) {
          if (tile.abortController) {
            tile.aborted = true;
            tile.abortController.abort();
            delete tile.abortController;
          }
        }
        unloadTile(tile) {
          if (tile.texture) this.map.painter.saveTileTexture(tile.texture);
        }
        hasTransition() {
          return false;
        }
      };
      module.exports = RasterTileSource;
    }
  });

  // node_modules/@mapbox/whoots-js/index.js
  var require_whoots_js = __commonJS({
    "node_modules/@mapbox/whoots-js/index.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.WhooTS = {});
      })(exports, function(exports2) {
        function getURL(baseUrl, layer, x, y, z, options) {
          options = options || {};
          var url = baseUrl + "?" + [
            "bbox=" + getTileBBox(x, y, z),
            "format=" + (options.format || "image/png"),
            "service=" + (options.service || "WMS"),
            "version=" + (options.version || "1.1.1"),
            "request=" + (options.request || "GetMap"),
            "srs=" + (options.srs || "EPSG:3857"),
            "width=" + (options.width || 256),
            "height=" + (options.height || 256),
            "layers=" + layer
          ].join("&");
          return url;
        }
        function getTileBBox(x, y, z) {
          y = Math.pow(2, z) - y - 1;
          var min = getMercCoords(x * 256, y * 256, z), max = getMercCoords((x + 1) * 256, (y + 1) * 256, z);
          return min[0] + "," + min[1] + "," + max[0] + "," + max[1];
        }
        function getMercCoords(x, y, z) {
          var resolution = 2 * Math.PI * 6378137 / 256 / Math.pow(2, z), merc_x = x * resolution - 2 * Math.PI * 6378137 / 2, merc_y = y * resolution - 2 * Math.PI * 6378137 / 2;
          return [merc_x, merc_y];
        }
        exports2.getURL = getURL;
        exports2.getTileBBox = getTileBBox;
        exports2.getMercCoords = getMercCoords;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/tile_id.js
  var require_tile_id = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/tile_id.js"(exports, module) {
      var { getTileBBox } = require_whoots_js();
      var assert = require_nanoassert();
      var { register } = require_transfer_registry();
      var Coordinate = require_coordinate();
      var CanonicalTileID = class {
        constructor(z, x, y) {
          assert(z >= 0 && z <= 25);
          assert(x >= 0 && x < 2 ** z);
          assert(y >= 0 && y < 2 ** z);
          this.z = z;
          this.x = x;
          this.y = y;
          this.key = calculateKey(0, z, x, y);
        }
        equals(id) {
          return this.z === id.z && this.x === id.x && this.y === id.y;
        }
        get cacheKey() {
          return this.key;
        }
      };
      var UnwrappedTileID = class {
        constructor(wrap, canonical) {
          this.wrap = wrap;
          this.canonical = canonical;
          this.key = calculateKey(wrap, canonical.z, canonical.x, canonical.y);
        }
      };
      var OverscaledTileID = class _OverscaledTileID {
        constructor(overscaledZ, wrap, z, x, y) {
          assert(overscaledZ >= z);
          this.overscaledZ = overscaledZ;
          this.wrap = wrap;
          this.canonical = new CanonicalTileID(z, +x, +y);
          this.key = calculateKey(wrap, overscaledZ, x, y);
        }
        equals(id) {
          return this.overscaledZ === id.overscaledZ && this.wrap === id.wrap && this.canonical.equals(id.canonical);
        }
        scaledTo(targetZ) {
          assert(targetZ <= this.overscaledZ);
          const zDifference = this.canonical.z - targetZ;
          if (targetZ > this.canonical.z) {
            return new _OverscaledTileID(targetZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          return new _OverscaledTileID(
            targetZ,
            this.wrap,
            targetZ,
            this.canonical.x >> zDifference,
            this.canonical.y >> zDifference
          );
        }
        isChildOf(parent) {
          const zDifference = this.canonical.z - parent.canonical.z;
          return parent.overscaledZ === 0 || parent.overscaledZ < this.overscaledZ && parent.canonical.x === this.canonical.x >> zDifference && parent.canonical.y === this.canonical.y >> zDifference;
        }
        children(sourceMaxZoom) {
          if (this.overscaledZ >= sourceMaxZoom) {
            return [
              new _OverscaledTileID(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
            ];
          }
          const z = this.canonical.z + 1;
          const x = this.canonical.x * 2;
          const y = this.canonical.y * 2;
          return [
            new _OverscaledTileID(z, this.wrap, z, x, y),
            new _OverscaledTileID(z, this.wrap, z, x + 1, y),
            new _OverscaledTileID(z, this.wrap, z, x, y + 1),
            new _OverscaledTileID(z, this.wrap, z, x + 1, y + 1)
          ];
        }
        isLessThan(rhs) {
          if (this.wrap < rhs.wrap) return true;
          if (this.wrap > rhs.wrap) return false;
          if (this.overscaledZ < rhs.overscaledZ) return true;
          if (this.overscaledZ > rhs.overscaledZ) return false;
          if (this.canonical.x < rhs.canonical.x) return true;
          if (this.canonical.x > rhs.canonical.x) return false;
          if (this.canonical.y < rhs.canonical.y) return true;
          return false;
        }
        get cacheKey() {
          return calculateKey(this.wrap, this.overscaledZ, this.canonical.x, this.canonical.y);
        }
        wrapped() {
          return new _OverscaledTileID(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(wrap) {
          return new _OverscaledTileID(this.overscaledZ, wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return 2 ** (this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new UnwrappedTileID(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        toCoordinate() {
          return new Coordinate(this.canonical.x + 2 ** this.wrap, this.canonical.y, this.canonical.z);
        }
      };
      function calculateKey(wrap, z, x, y) {
        wrap *= 2;
        if (wrap < 0) wrap = wrap * -1 - 1;
        const dim = 1 << z;
        return (dim * dim * wrap + dim * y + x) * 32 + z;
      }
      register("CanonicalTileID", CanonicalTileID);
      register("OverscaledTileID", OverscaledTileID, { omit: ["posMatrix"] });
      module.exports = {
        CanonicalTileID,
        UnwrappedTileID,
        OverscaledTileID
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/dem_data.js
  var require_dem_data = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/dem_data.js"(exports, module) {
      var { RGBAImage } = require_image2();
      var warn = require_warn();
      var { register } = require_transfer_registry();
      var DEMData = class {
        constructor(uid, data, encoding) {
          this.uid = uid;
          if (data.height !== data.width) throw new RangeError("DEM tiles must be square");
          if (encoding && encoding !== "mapbox" && encoding !== "terrarium") {
            warn.once(`"${encoding}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
            return;
          }
          const dim = this.dim = data.height;
          this.stride = this.dim + 2;
          this.data = new Int32Array(this.stride * this.stride);
          const pixels = data.data;
          const unpack = encoding === "terrarium" ? this._unpackTerrarium : this._unpackMapbox;
          for (let y = 0; y < dim; y++) {
            for (let x = 0; x < dim; x++) {
              const i = y * dim + x;
              const j = i * 4;
              this.set(x, y, unpack(pixels[j], pixels[j + 1], pixels[j + 2]));
            }
          }
          for (let x = 0; x < dim; x++) {
            this.set(-1, x, this.get(0, x));
            this.set(dim, x, this.get(dim - 1, x));
            this.set(x, -1, this.get(x, 0));
            this.set(x, dim, this.get(x, dim - 1));
          }
          this.set(-1, -1, this.get(0, 0));
          this.set(dim, -1, this.get(dim - 1, 0));
          this.set(-1, dim, this.get(0, dim - 1));
          this.set(dim, dim, this.get(dim - 1, dim - 1));
        }
        set(x, y, value) {
          this.data[this._idx(x, y)] = value + 65536;
        }
        get(x, y) {
          return this.data[this._idx(x, y)] - 65536;
        }
        _idx(x, y) {
          if (x < -1 || x >= this.dim + 1 || y < -1 || y >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (y + 1) * this.stride + (x + 1);
        }
        _unpackMapbox(r, g, b) {
          return (r * 256 * 256 + g * 256 + b) / 10 - 1e4;
        }
        _unpackTerrarium(r, g, b) {
          return r * 256 + g + b / 256 - 32768;
        }
        getPixels() {
          return new RGBAImage({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(borderTile, dx, dy) {
          if (this.dim !== borderTile.dim) throw new Error("dem dimension mismatch");
          let xMin = dx * this.dim;
          let xMax = dx * this.dim + this.dim;
          let yMin = dy * this.dim;
          let yMax = dy * this.dim + this.dim;
          switch (dx) {
            case -1:
              xMin = xMax - 1;
              break;
            case 1:
              xMax = xMin + 1;
              break;
          }
          switch (dy) {
            case -1:
              yMin = yMax - 1;
              break;
            case 1:
              yMax = yMin + 1;
              break;
          }
          const ox = -dx * this.dim;
          const oy = -dy * this.dim;
          for (let y = yMin; y < yMax; y++) {
            for (let x = xMin; x < xMax; x++) {
              this.set(x, y, borderTile.get(x + ox, y + oy));
            }
          }
        }
      };
      register("DEMData", DEMData);
      module.exports = DEMData;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/raster_dem_tile_source.js
  var require_raster_dem_tile_source = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/raster_dem_tile_source.js"(exports, module) {
      var browser = require_browser();
      var loadImage = require_image();
      var { OverscaledTileID } = require_tile_id();
      var RasterTileSource = require_raster_tile_source();
      require_dem_data();
      var RasterDEMTileSource = class extends RasterTileSource {
        constructor(id, options, dispatcher, eventedParent) {
          super(id, options, dispatcher, eventedParent);
          this.type = "raster-dem";
          this.maxzoom = 22;
          this._options = Object.assign({}, options);
          this.encoding = options.encoding || "mapbox";
        }
        serialize() {
          return {
            type: "raster-dem",
            url: this.url,
            tileSize: this.tileSize,
            tiles: this.tiles,
            bounds: this.bounds,
            encoding: this.encoding
          };
        }
        async loadTile(tile) {
          try {
            tile.abortController = new window.AbortController();
            const data = await this.tiles(tile.tileID.canonical, tile.abortController).catch(() => {
            });
            tile.neighboringTiles = this._getNeighboringTiles(tile.tileID);
            if (!data) {
              const err = new Error("Tile could not be loaded");
              err.status = 404;
              throw err;
            }
            const img = await loadImage(data);
            if (!img) {
              return;
            }
            if (!tile.dem) {
              const rawImageData = browser.getImageData(img);
              const params = {
                uid: tile.uid,
                coord: tile.tileID,
                source: this.id,
                rawImageData,
                encoding: this.encoding
              };
              const dem = await this.dispatcher.send("loadDEMTile", params);
              if (dem) {
                tile.dem = dem;
                tile.needsHillshadePrepare = true;
                tile.state = "loaded";
              }
            }
          } catch (err) {
            if (tile.aborted) {
              tile.state = "unloaded";
              return;
            }
            tile.state = "errored";
            throw err;
          }
        }
        _getNeighboringTiles(tileID) {
          const canonical = tileID.canonical;
          const dim = 2 ** canonical.z;
          const px = (canonical.x - 1 + dim) % dim;
          const pxw = canonical.x === 0 ? tileID.wrap - 1 : tileID.wrap;
          const nx = (canonical.x + 1 + dim) % dim;
          const nxw = canonical.x + 1 === dim ? tileID.wrap + 1 : tileID.wrap;
          const neighboringTiles = {};
          neighboringTiles[new OverscaledTileID(tileID.overscaledZ, pxw, canonical.z, px, canonical.y).key] = {
            backfilled: false
          };
          neighboringTiles[new OverscaledTileID(tileID.overscaledZ, nxw, canonical.z, nx, canonical.y).key] = {
            backfilled: false
          };
          if (canonical.y > 0) {
            neighboringTiles[new OverscaledTileID(tileID.overscaledZ, pxw, canonical.z, px, canonical.y - 1).key] = {
              backfilled: false
            };
            neighboringTiles[new OverscaledTileID(tileID.overscaledZ, tileID.wrap, canonical.z, canonical.x, canonical.y - 1).key] = { backfilled: false };
            neighboringTiles[new OverscaledTileID(tileID.overscaledZ, nxw, canonical.z, nx, canonical.y - 1).key] = {
              backfilled: false
            };
          }
          if (canonical.y + 1 < dim) {
            neighboringTiles[new OverscaledTileID(tileID.overscaledZ, pxw, canonical.z, px, canonical.y + 1).key] = {
              backfilled: false
            };
            neighboringTiles[new OverscaledTileID(tileID.overscaledZ, tileID.wrap, canonical.z, canonical.x, canonical.y + 1).key] = { backfilled: false };
            neighboringTiles[new OverscaledTileID(tileID.overscaledZ, nxw, canonical.z, nx, canonical.y + 1).key] = {
              backfilled: false
            };
          }
          return neighboringTiles;
        }
        unloadTile(tile) {
          if (tile.demTexture) this.map.painter.saveTileTexture(tile.demTexture);
          if (tile.fbo) {
            tile.fbo.destroy();
            delete tile.fbo;
          }
          if (tile.dem) delete tile.dem;
          delete tile.neighboringTiles;
          tile.state = "unloaded";
        }
      };
      module.exports = RasterDEMTileSource;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/geojson_source.js
  var require_geojson_source = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/geojson_source.js"(exports, module) {
      var { Event: Event3, ErrorEvent: ErrorEvent3, Evented: Evented3 } = (init_events(), __toCommonJS(events_exports));
      var EXTENT = require_extent();
      var browser = require_browser();
      var GeoJSONSource = class extends Evented3 {
        #pendingDataEvents = /* @__PURE__ */ new Set();
        #newData = false;
        #updateInProgress = false;
        constructor(id, options, dispatcher, eventedParent) {
          super();
          this.id = id;
          this.type = "geojson";
          this.minzoom = 0;
          this.maxzoom = 18;
          this.tileSize = 512;
          this.isTileClipped = true;
          this.reparseOverscaled = true;
          this._removed = false;
          this.dispatcher = dispatcher;
          this.setEventedParent(eventedParent);
          this._data = options.data;
          this._options = Object.assign({}, options);
          if (options.maxzoom !== void 0) this.maxzoom = options.maxzoom;
          if (options.type) this.type = options.type;
          const scale = EXTENT / this.tileSize;
          this.workerOptions = Object.assign(
            {
              source: this.id,
              cluster: options.cluster || false,
              geojsonVtOptions: {
                buffer: (options.buffer !== void 0 ? options.buffer : 128) * scale,
                tolerance: (options.tolerance !== void 0 ? options.tolerance : 0.375) * scale,
                extent: EXTENT,
                maxZoom: this.maxzoom,
                lineMetrics: options.lineMetrics || false
              },
              superclusterOptions: {
                maxZoom: options.clusterMaxZoom !== void 0 ? Math.min(options.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1,
                extent: EXTENT,
                radius: (options.clusterRadius || 50) * scale,
                log: false
              }
            },
            options.workerOptions
          );
        }
        load() {
          this.#updateData("metadata");
        }
        onAdd(map) {
          this.map = map;
          this.load();
        }
        /**
         * Sets the GeoJSON data and re-renders the map.
         *
         * @param {Object|string} data A GeoJSON data object or a URL to one. The latter is preferable in the case of large GeoJSON files.
         * @returns {GeoJSONSource} this
         */
        setData(data) {
          this._data = data;
          this.#updateData();
          return this;
        }
        async #updateData(sourceDataType = "content") {
          this.#newData = true;
          this.#pendingDataEvents.add(sourceDataType);
          if (this.#updateInProgress) {
            return;
          }
          try {
            this.#updateInProgress = true;
            this.fire(new Event3("dataloading", { dataType: "source" }));
            while (this.#newData) {
              this.#newData = false;
              await this._updateWorkerData(this._data);
            }
            this.#pendingDataEvents.forEach(
              (sourceDataType2) => this.fire(new Event3("data", { dataType: "source", sourceDataType: sourceDataType2 }))
            );
            this.#pendingDataEvents.clear();
          } catch (err) {
            this.fire(new ErrorEvent3(err));
          } finally {
            this.#updateInProgress = false;
          }
        }
        /*
         * Responsible for invoking WorkerSource's geojson.loadData target, which
         * handles loading the geojson data and preparing to serve it up as tiles,
         * using geojson-vt or supercluster as appropriate.
         */
        async _updateWorkerData(data) {
          const json = typeof data === "function" ? await data().catch(() => {
          }) : data;
          if (!json) {
            throw new Error("no GeoJSON data");
          }
          const options = { ...this.workerOptions, data: JSON.stringify(json) };
          this.workerID ??= this.dispatcher.nextWorkerId();
          await this.dispatcher.send(`${this.type}.loadData`, options, this.workerID);
        }
        async loadTile(tile) {
          const params = {
            type: this.type,
            uid: tile.uid,
            tileID: tile.tileID,
            zoom: tile.tileID.overscaledZ,
            maxZoom: this.maxzoom,
            tileSize: this.tileSize,
            source: this.id,
            pixelRatio: browser.devicePixelRatio,
            showCollisionBoxes: this.map.showCollisionBoxes
          };
          const justReloaded = tile.workerID != null;
          tile.workerID ??= this.dispatcher.nextWorkerId(this.workerID);
          const data = await this.dispatcher.send("loadTile", params, tile.workerID).finally(() => tile.unloadVectorData());
          if (!tile.aborted) {
            tile.loadVectorData(data, this.map.painter, justReloaded);
          }
        }
        abortTile(tile) {
          tile.aborted = true;
        }
        unloadTile(tile) {
          tile.unloadVectorData();
        }
        onRemove() {
          this._removed = true;
          return this.dispatcher.send("removeSource", { type: this.type, source: this.id }, this.workerID);
        }
        serialize() {
          return Object.assign({}, this._options, {
            type: this.type,
            data: this._data
          });
        }
        hasTransition() {
          return false;
        }
      };
      module.exports = GeoJSONSource;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/raster_bounds_attributes.js
  var require_raster_bounds_attributes = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/raster_bounds_attributes.js"(exports, module) {
      var { createLayout } = require_struct_array();
      module.exports = createLayout([
        { name: "a_pos", type: "Int16", components: 2 },
        { name: "a_texture_pos", type: "Int16", components: 2 }
      ]);
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/image_source.js
  var require_image_source = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/image_source.js"(exports, module) {
      var { getCoordinatesCenter } = require_util();
      var { CanonicalTileID } = require_tile_id();
      var LngLat = require_lng_lat();
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      var { Event: Event3, ErrorEvent: ErrorEvent3, Evented: Evented3 } = (init_events(), __toCommonJS(events_exports));
      var loadImage = require_image();
      var EXTENT = require_extent();
      var { RasterBoundsArray } = require_array_types();
      var rasterBoundsAttributes = require_raster_bounds_attributes();
      var SegmentVector = require_segment();
      var Texture = require_texture();
      var ImageSource = class extends Evented3 {
        /**
         * @private
         */
        constructor(id, options, dispatcher, eventedParent) {
          super();
          this.id = id;
          this.dispatcher = dispatcher;
          this.coordinates = options.coordinates;
          this.type = "image";
          this.minzoom = 0;
          this.maxzoom = 22;
          this.tileSize = 512;
          this.tiles = {};
          this.setEventedParent(eventedParent);
          this.options = options;
        }
        async load() {
          this.fire(new Event3("dataloading", { dataType: "source" }));
          this.url = this.options.url;
          try {
            this.image = await loadImage(this.url);
            this._finishLoading();
          } catch (err) {
            this.fire(new ErrorEvent3(err));
          }
        }
        _finishLoading() {
          if (this.map) {
            this.setCoordinates(this.coordinates);
            this.fire(new Event3("data", { dataType: "source", sourceDataType: "metadata" }));
          }
        }
        onAdd(map) {
          this.map = map;
          this.load();
        }
        /**
         * Sets the image's coordinates and re-renders the map.
         *
         * @param {Array<Array<number>>} coordinates Four geographical coordinates,
         *   represented as arrays of longitude and latitude numbers, which define the corners of the image.
         *   The coordinates start at the top left corner of the image and proceed in clockwise order.
         *   They do not have to represent a rectangle.
         * @returns {ImageSource} this
         */
        setCoordinates(coordinates) {
          this.coordinates = coordinates;
          const map = this.map;
          const cornerZ0Coords = coordinates.map((coord) => {
            return map.transform.locationCoordinate(LngLat.convert(coord)).zoomTo(0);
          });
          const centerCoord = this.centerCoord = getCoordinatesCenter(cornerZ0Coords);
          centerCoord.column = Math.floor(centerCoord.column);
          centerCoord.row = Math.floor(centerCoord.row);
          this.tileID = new CanonicalTileID(centerCoord.zoom, centerCoord.column, centerCoord.row);
          this.minzoom = this.maxzoom = centerCoord.zoom;
          const tileCoords = cornerZ0Coords.map((coord) => {
            const zoomedCoord = coord.zoomTo(centerCoord.zoom);
            return new Point3(
              Math.round((zoomedCoord.column - centerCoord.column) * EXTENT),
              Math.round((zoomedCoord.row - centerCoord.row) * EXTENT)
            );
          });
          this._boundsArray = new RasterBoundsArray();
          this._boundsArray.emplaceBack(tileCoords[0].x, tileCoords[0].y, 0, 0);
          this._boundsArray.emplaceBack(tileCoords[1].x, tileCoords[1].y, EXTENT, 0);
          this._boundsArray.emplaceBack(tileCoords[3].x, tileCoords[3].y, 0, EXTENT);
          this._boundsArray.emplaceBack(tileCoords[2].x, tileCoords[2].y, EXTENT, EXTENT);
          if (this.boundsBuffer) {
            this.boundsBuffer.destroy();
            delete this.boundsBuffer;
          }
          this.fire(new Event3("data", { dataType: "source", sourceDataType: "content" }));
          return this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image) {
            return;
          }
          const context = this.map.painter.context;
          const gl = context.gl;
          if (!this.boundsBuffer) {
            this.boundsBuffer = context.createVertexBuffer(this._boundsArray, rasterBoundsAttributes.members);
          }
          if (!this.boundsSegments) {
            this.boundsSegments = SegmentVector.simpleSegment(0, 0, 4, 2);
          }
          if (!this.texture) {
            this.texture = new Texture(context, this.image, gl.RGBA);
            this.texture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
          }
          for (const w in this.tiles) {
            const tile = this.tiles[w];
            if (tile.state !== "loaded") {
              tile.state = "loaded";
              tile.texture = this.texture;
            }
          }
        }
        loadTile(tile) {
          if (this.tileID?.equals(tile.tileID.canonical)) {
            this.tiles[String(tile.tileID.wrap)] = tile;
            tile.buckets = {};
          } else {
            tile.state = "errored";
          }
          return Promise.resolve();
        }
        serialize() {
          return {
            type: "image",
            url: this.options.url,
            coordinates: this.coordinates
          };
        }
        hasTransition() {
          return false;
        }
      };
      module.exports = ImageSource;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/source.js
  var require_source = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/source.js"(exports, module) {
      var { bindAll } = require_object();
      var vector = require_vector_tile_source();
      var raster = require_raster_tile_source();
      var rasterDem = require_raster_dem_tile_source();
      var geojson = require_geojson_source();
      var image = require_image_source();
      var sourceTypes = {
        vector,
        raster,
        "raster-dem": rasterDem,
        geojson,
        image
      };
      function create(id, specification, dispatcher, eventedParent) {
        const source = new sourceTypes[specification.type](id, specification, dispatcher, eventedParent);
        if (source.id !== id) {
          throw new Error(`Expected Source id to be ${id} instead of ${source.id}`);
        }
        bindAll(["load", "abort", "unload", "serialize", "prepare"], source);
        return source;
      }
      function getType(name) {
        return sourceTypes[name];
      }
      function setType(name, type) {
        sourceTypes[name] = type;
      }
      module.exports = {
        create,
        getType,
        setType
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/query_features.js
  var require_query_features = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/query_features.js"(exports, module) {
      var assert = require_nanoassert();
      var { mat4 } = require_gl_matrix();
      module.exports = {
        queryRenderedFeatures,
        queryRenderedSymbols,
        querySourceFeatures
      };
      function getPixelPosMatrix(transform, tileID) {
        const t = mat4.identity([]);
        mat4.translate(t, t, [1, 1, 0]);
        mat4.scale(t, t, [transform.width * 0.5, transform.height * 0.5, 1]);
        return mat4.multiply(t, t, transform.calculatePosMatrix(tileID.toUnwrapped()));
      }
      function queryIncludes3DLayer(layers, styleLayers, sourceID) {
        if (layers) {
          for (const layerID of layers) {
            const layer = styleLayers[layerID];
            if (layer && layer.source === sourceID && layer.type === "fill-extrusion") {
              return true;
            }
          }
        } else {
          for (const key in styleLayers) {
            const layer = styleLayers[key];
            if (layer.source === sourceID && layer.type === "fill-extrusion") {
              return true;
            }
          }
        }
        return false;
      }
      function queryRenderedFeatures(sourceCache, styleLayers, queryGeometry, params, transform) {
        const has3DLayer = queryIncludes3DLayer(params?.layers, styleLayers, sourceCache.id);
        const maxPitchScaleFactor = transform.maxPitchScaleFactor();
        const tilesIn = sourceCache.tilesIn(queryGeometry, maxPitchScaleFactor, has3DLayer);
        tilesIn.sort(sortTilesIn);
        const renderedFeatureLayers = [];
        for (const tileIn of tilesIn) {
          renderedFeatureLayers.push({
            wrappedTileID: tileIn.tileID.wrapped().key,
            queryResults: tileIn.tile.queryRenderedFeatures(
              styleLayers,
              sourceCache._state,
              tileIn.queryGeometry,
              tileIn.cameraQueryGeometry,
              tileIn.scale,
              params,
              transform,
              maxPitchScaleFactor,
              getPixelPosMatrix(sourceCache.transform, tileIn.tileID)
            )
          });
        }
        const result = mergeRenderedFeatureLayers(renderedFeatureLayers);
        for (const layerID in result) {
          result[layerID].forEach((featureWrapper) => {
            const feature = featureWrapper.feature;
            const state = sourceCache.getFeatureState(feature.layer["source-layer"], feature.id);
            feature.source = feature.layer.source;
            if (feature.layer["source-layer"]) {
              feature.sourceLayer = feature.layer["source-layer"];
            }
            feature.state = state;
          });
        }
        return result;
      }
      function queryRenderedSymbols(styleLayers, sourceCaches, queryGeometry, params, collisionIndex, retainedQueryData) {
        const result = {};
        const renderedSymbols = collisionIndex.queryRenderedSymbols(queryGeometry);
        const bucketQueryData = [];
        for (const bucketInstanceId of Object.keys(renderedSymbols).map(Number)) {
          bucketQueryData.push(retainedQueryData[bucketInstanceId]);
        }
        bucketQueryData.sort(sortTilesIn);
        for (const queryData of bucketQueryData) {
          const bucketSymbols = queryData.featureIndex.lookupSymbolFeatures(
            renderedSymbols[queryData.bucketInstanceId],
            queryData.bucketIndex,
            queryData.sourceLayerIndex,
            params.filter,
            params.layers,
            styleLayers
          );
          for (const layerID in bucketSymbols) {
            const resultFeatures = result[layerID] = result[layerID] || [];
            const layerSymbols = bucketSymbols[layerID];
            layerSymbols.sort((a, b) => {
              const featureSortOrder = queryData.featureSortOrder;
              if (featureSortOrder) {
                const sortedA = featureSortOrder.indexOf(a.featureIndex);
                const sortedB = featureSortOrder.indexOf(b.featureIndex);
                assert(sortedA >= 0);
                assert(sortedB >= 0);
                return sortedB - sortedA;
              }
              return b.featureIndex - a.featureIndex;
            });
            for (const symbolFeature of layerSymbols) {
              resultFeatures.push(symbolFeature);
            }
          }
        }
        for (const layerName in result) {
          result[layerName].forEach((featureWrapper) => {
            const feature = featureWrapper.feature;
            const layer = styleLayers[layerName];
            const sourceCache = sourceCaches[layer.source];
            const state = sourceCache.getFeatureState(feature.layer["source-layer"], feature.id);
            feature.source = feature.layer.source;
            if (feature.layer["source-layer"]) {
              feature.sourceLayer = feature.layer["source-layer"];
            }
            feature.state = state;
          });
        }
        return result;
      }
      function querySourceFeatures(sourceCache, params) {
        const tiles = sourceCache.getRenderableIds().map((id) => {
          return sourceCache.getTileByID(id);
        });
        const result = [];
        const dataTiles = {};
        for (let i = 0; i < tiles.length; i++) {
          const tile = tiles[i];
          const dataID = tile.tileID.canonical.key;
          if (!dataTiles[dataID]) {
            dataTiles[dataID] = true;
            tile.querySourceFeatures(result, params);
          }
        }
        return result;
      }
      function sortTilesIn(a, b) {
        const idA = a.tileID;
        const idB = b.tileID;
        return idA.overscaledZ - idB.overscaledZ || idA.canonical.y - idB.canonical.y || idA.wrap - idB.wrap || idA.canonical.x - idB.canonical.x;
      }
      function mergeRenderedFeatureLayers(tiles) {
        const result = {};
        const wrappedIDLayerMap = {};
        for (const tile of tiles) {
          const queryResults = tile.queryResults;
          const wrappedID = tile.wrappedTileID;
          const wrappedIDLayers = wrappedIDLayerMap[wrappedID] = wrappedIDLayerMap[wrappedID] || {};
          for (const layerID in queryResults) {
            const tileFeatures = queryResults[layerID];
            const wrappedIDFeatures = wrappedIDLayers[layerID] = wrappedIDLayers[layerID] || {};
            const resultFeatures = result[layerID] = result[layerID] || [];
            for (const tileFeature of tileFeatures) {
              if (!wrappedIDFeatures[tileFeature.featureIndex]) {
                wrappedIDFeatures[tileFeature.featureIndex] = true;
                resultFeatures.push(tileFeature);
              }
            }
          }
        }
        return result;
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/bucket.js
  var require_bucket = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/bucket.js"(exports, module) {
      function deserialize(input, style) {
        const output = {};
        if (!style) return output;
        for (const bucket of input) {
          const layers = bucket.layerIds.map((id) => style.getLayer(id)).filter(Boolean);
          if (layers.length === 0) {
            continue;
          }
          bucket.layers = layers;
          bucket.stateDependentLayers = layers.filter((l) => l.isStateDependent());
          for (const layer of layers) {
            output[layer.id] = bucket;
          }
        }
        return output;
      }
      module.exports = {
        deserialize
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/tile.js
  var require_tile = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/tile.js"(exports, module) {
      var { deepEqual } = require_object();
      var uniqueId = require_unique_id();
      var { deserialize: deserializeBucket } = require_bucket();
      var GeoJSONFeature = require_vectortile_to_geojson();
      var featureFilter = require_feature_filter();
      var SymbolBucket = require_symbol_bucket();
      var { RasterBoundsArray, CollisionBoxArray } = require_array_types();
      var rasterBoundsAttributes = require_raster_bounds_attributes();
      var EXTENT = require_extent();
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      var Texture = require_texture();
      var SegmentVector = require_segment();
      var { TriangleIndexArray } = require_index_array_type();
      var browser = require_browser();
      var EvaluationParameters = require_evaluation_parameters();
      var Tile = class {
        /**
         * @param {OverscaledTileID} tileID
         * @param size
         */
        constructor(tileID, size) {
          this.tileID = tileID;
          this.uid = uniqueId();
          this.uses = 0;
          this.tileSize = size;
          this.buckets = {};
          this.queryPadding = 0;
          this.hasSymbolBuckets = false;
          this.state = "loading";
        }
        registerFadeDuration(duration) {
          const fadeEndTime = duration + this.timeAdded;
          if (fadeEndTime < browser.now()) return;
          if (this.fadeEndTime && fadeEndTime < this.fadeEndTime) return;
          this.fadeEndTime = fadeEndTime;
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        /**
         * Given a data object with a 'buffers' property, load it into
         * this tile's elementGroups and buffers properties and set loaded
         * to true. If the data is null, like in the case of an empty
         * GeoJSON tile, no-op but still set loaded to true.
         * @param {Object} data
         * @param painter
         * @returns {undefined}
         */
        loadVectorData(data, painter, justReloaded) {
          if (this.hasData()) {
            this.unloadVectorData();
          }
          this.state = "loaded";
          if (!data) {
            this.collisionBoxArray = new CollisionBoxArray();
            return;
          }
          if (data.featureIndex) {
            this.latestFeatureIndex = data.featureIndex;
            if (data.rawTileData) {
              this.latestRawTileData = data.rawTileData;
              this.latestFeatureIndex.rawTileData = data.rawTileData;
            } else if (this.latestRawTileData) {
              this.latestFeatureIndex.rawTileData = this.latestRawTileData;
            }
          }
          this.collisionBoxArray = data.collisionBoxArray;
          this.buckets = deserializeBucket(data.buckets, painter.style);
          this.hasSymbolBuckets = false;
          const buckets = Object.values(this.buckets);
          for (const bucket of buckets) {
            if (bucket instanceof SymbolBucket) {
              this.hasSymbolBuckets = true;
              if (justReloaded) {
                bucket.justReloaded = true;
              } else {
                break;
              }
            }
          }
          this.queryPadding = 0;
          for (const id in this.buckets) {
            const bucket = this.buckets[id];
            this.queryPadding = Math.max(this.queryPadding, painter.style.getLayer(id).queryRadius(bucket));
          }
          if (data.imageAtlas) {
            this.imageAtlas = data.imageAtlas;
          }
          if (data.glyphAtlasImage) {
            this.glyphAtlasImage = data.glyphAtlasImage;
          }
        }
        /**
         * Release any data or WebGL resources referenced by this tile.
         * @returns {undefined}
         * @private
         */
        unloadVectorData() {
          for (const bucket of Object.values(this.buckets)) {
            bucket.destroy();
          }
          this.buckets = {};
          this.imageAtlasTexture?.destroy();
          if (this.imageAtlas) {
            this.imageAtlas = null;
          }
          this.glyphAtlasTexture?.destroy();
          this.latestFeatureIndex = null;
          this.state = "unloaded";
        }
        unloadDEMData() {
          this.dem = null;
          this.neighboringTiles = null;
          this.state = "unloaded";
        }
        getBucket(layer) {
          return this.buckets[layer.id];
        }
        upload(context) {
          for (const id in this.buckets) {
            const bucket = this.buckets[id];
            if (bucket.uploadPending()) {
              bucket.upload(context);
            }
          }
          const gl = context.gl;
          if (this.imageAtlas && !this.imageAtlas.uploaded) {
            this.imageAtlasTexture = new Texture(context, this.imageAtlas.image, gl.RGBA);
            this.imageAtlas.uploaded = true;
          }
          if (this.glyphAtlasImage) {
            this.glyphAtlasTexture = new Texture(context, this.glyphAtlasImage, gl.ALPHA);
            this.glyphAtlasImage = null;
          }
        }
        // Queries non-symbol features rendered for this tile.
        // Symbol features are queried globally
        queryRenderedFeatures(layers, sourceFeatureState, queryGeometry, cameraQueryGeometry, scale, params, transform, maxPitchScaleFactor, pixelPosMatrix) {
          if (!this.latestFeatureIndex?.rawTileData) return {};
          return this.latestFeatureIndex.query(
            {
              queryGeometry,
              cameraQueryGeometry,
              scale,
              tileSize: this.tileSize,
              pixelPosMatrix,
              transform,
              params,
              queryPadding: this.queryPadding * maxPitchScaleFactor
            },
            layers,
            sourceFeatureState
          );
        }
        querySourceFeatures(result, params) {
          if (!this.latestFeatureIndex?.rawTileData) return;
          const vtLayers = this.latestFeatureIndex.loadVTLayers();
          const sourceLayer = params ? params.sourceLayer : "";
          const layer = vtLayers._geojsonTileLayer || vtLayers[sourceLayer];
          if (!layer) return;
          const filter = featureFilter(params?.filter);
          const { z, x, y } = this.tileID.canonical;
          const coord = { z, x, y };
          for (let i = 0; i < layer.length; i++) {
            const feature = layer.feature(i);
            if (filter(new EvaluationParameters(this.tileID.overscaledZ), feature)) {
              const geojsonFeature = new GeoJSONFeature(feature, z, x, y);
              geojsonFeature.tile = coord;
              result.push(geojsonFeature);
            }
          }
        }
        clearMask() {
          if (this.segments) {
            this.segments.destroy();
            delete this.segments;
          }
          if (this.maskedBoundsBuffer) {
            this.maskedBoundsBuffer.destroy();
            delete this.maskedBoundsBuffer;
          }
          if (this.maskedIndexBuffer) {
            this.maskedIndexBuffer.destroy();
            delete this.maskedIndexBuffer;
          }
        }
        setMask(mask, context) {
          if (deepEqual(this.mask, mask)) return;
          this.mask = mask;
          this.clearMask();
          if (deepEqual(mask, { 0: true })) return;
          const maskedBoundsArray = new RasterBoundsArray();
          const indexArray = new TriangleIndexArray();
          this.segments = new SegmentVector();
          this.segments.prepareSegment(0, maskedBoundsArray, indexArray);
          const maskArray = Object.keys(mask);
          for (let i = 0; i < maskArray.length; i++) {
            const maskCoord = mask[maskArray[i]];
            const vertexExtent = EXTENT >> maskCoord.z;
            const tlVertex = new Point3(maskCoord.x * vertexExtent, maskCoord.y * vertexExtent);
            const brVertex = new Point3(tlVertex.x + vertexExtent, tlVertex.y + vertexExtent);
            const segment = this.segments.prepareSegment(4, maskedBoundsArray, indexArray);
            maskedBoundsArray.emplaceBack(tlVertex.x, tlVertex.y, tlVertex.x, tlVertex.y);
            maskedBoundsArray.emplaceBack(brVertex.x, tlVertex.y, brVertex.x, tlVertex.y);
            maskedBoundsArray.emplaceBack(tlVertex.x, brVertex.y, tlVertex.x, brVertex.y);
            maskedBoundsArray.emplaceBack(brVertex.x, brVertex.y, brVertex.x, brVertex.y);
            const offset = segment.vertexLength;
            indexArray.emplaceBack(offset, offset + 1, offset + 2);
            indexArray.emplaceBack(offset + 1, offset + 2, offset + 3);
            segment.vertexLength += 4;
            segment.primitiveLength += 2;
          }
          this.maskedBoundsBuffer = context.createVertexBuffer(maskedBoundsArray, rasterBoundsAttributes.members);
          this.maskedIndexBuffer = context.createIndexBuffer(indexArray);
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading";
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setFeatureState(states, painter) {
          if (!this.latestFeatureIndex?.rawTileData || Object.keys(states).length === 0) {
            return;
          }
          const vtLayers = this.latestFeatureIndex.loadVTLayers();
          for (const id in this.buckets) {
            const bucket = this.buckets[id];
            const sourceLayerId = bucket.layers[0]["sourceLayer"] || "_geojsonTileLayer";
            const sourceLayer = vtLayers[sourceLayerId];
            const sourceLayerStates = states[sourceLayerId];
            if (!sourceLayer || !sourceLayerStates || Object.keys(sourceLayerStates).length === 0) continue;
            bucket.update(sourceLayerStates, sourceLayer, this.imageAtlas?.patternPositions || {});
            if (painter?.style) {
              this.queryPadding = Math.max(this.queryPadding, painter.style.getLayer(id).queryRadius(bucket));
            }
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < browser.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(duration) {
          this.symbolFadeHoldUntil = browser.now() + duration;
        }
      };
      module.exports = Tile;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/tile_cache.js
  var require_tile_cache = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/tile_cache.js"(exports, module) {
      var assert = require_nanoassert();
      var TileCache = class {
        #data = /* @__PURE__ */ new Map();
        /**
         * @param {number} max number of permitted values
         * @param {Function} onRemove callback called with items when they expire
         */
        constructor(max, onRemove) {
          this.max = max;
          this.onRemove = onRemove;
        }
        /**
         * Clear the cache
         *
         * @returns {TileCache} this cache
         */
        reset() {
          for (const data of this.#data.values()) {
            this.onRemove(data);
          }
          this.#data.clear();
          return this;
        }
        /**
         * Add a key, value combination to the cache, trimming its size if this pushes
         * it over max length.
         *
         * @param {OverscaledTileID} tileID lookup key for the item
         * @param {*} data any value
         *
         * @returns {TileCache} this cache
         */
        add(data) {
          const key = data.tileID.cacheKey;
          assert(!this.#data.has(key));
          this.#data.set(key, data);
          if (this.#data.size > this.max) {
            const [[key2, tile]] = this.#data;
            this.onRemove(tile);
            this.#data.delete(key2);
          }
          return this;
        }
        /**
         * Determine whether the value attached to `key` is present
         *
         * @param {OverscaledTileID} tileID the key to be looked-up
         * @returns {boolean} whether the cache has this value
         */
        has(tileID) {
          return this.#data.has(tileID.cacheKey);
        }
        /**
         * Get the value attached to a specific key and remove data from cache.
         * If the key is not found, returns `null`
         *
         * @param {OverscaledTileID} tileID the key to look up
         * @returns {*} the data, or null if it isn't found
         */
        getAndRemove(tileID) {
          return this.#getAndRemoveByKey(tileID.cacheKey);
        }
        /*
         * Get and remove the value with the specified key.
         */
        #getAndRemoveByKey(key) {
          const tile = this.#data.get(key);
          if (tile) {
            this.#data.delete(key);
            return tile;
          }
        }
        /**
         * Get the value attached to a specific key without removing data
         * from the cache. If the key is not found, returns `null`
         *
         * @param {OverscaledTileID} tileID the key to look up
         * @returns {*} the data, or null if it isn't found
         */
        get(tileID) {
          return this.#data.get(tileID.cacheKey);
        }
        /**
         * Change the max size of the cache.
         *
         * @param {number} max the max size of the cache
         * @returns {TileCache} this cache
         */
        setMaxSize(max) {
          for (let overflow = this.#data.size - max; overflow > 0; overflow--) {
            const [[key, data]] = this.#data;
            this.onRemove(data);
            this.#data.delete(key);
          }
          this.max = max;
          return this;
        }
        get keys() {
          return Array.from(this.#data.keys());
        }
        get size() {
          return this.#data.size;
        }
      };
      module.exports = TileCache;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/source_state.js
  var require_source_state = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/source_state.js"(exports, module) {
      var SourceFeatureState = class {
        #state = {};
        #stateChanges = {};
        updateState(sourceLayer, feature, state) {
          const changes = this.#stateChanges[sourceLayer] ??= {};
          const featureState = changes[feature] ??= {};
          Object.assign(featureState, state);
        }
        getState(sourceLayer, feature) {
          const base = this.#state[sourceLayer];
          const changes = this.#stateChanges[sourceLayer];
          return Object.assign({}, base?.[feature], changes?.[feature]);
        }
        initializeTileState(tile, painter) {
          tile.setFeatureState(this.#state, painter);
        }
        coalesceChanges(tiles, painter) {
          const changes = {};
          for (const sourceLayer in this.#stateChanges) {
            this.#state[sourceLayer] ??= {};
            const layerStates = {};
            for (const id in this.#stateChanges[sourceLayer]) {
              this.#state[sourceLayer][id] ??= {};
              Object.assign(this.#state[sourceLayer][id], this.#stateChanges[sourceLayer][id]);
              layerStates[id] = this.#state[sourceLayer][id];
            }
            changes[sourceLayer] = layerStates;
          }
          this.#stateChanges = {};
          if (Object.keys(changes).length === 0) return;
          Object.values(tiles).forEach((tile) => tile.setFeatureState(changes, painter));
        }
      };
      module.exports = SourceFeatureState;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/source_cache.js
  var require_source_cache = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/source_cache.js"(exports, module) {
      var { create: createSource } = require_source();
      var Tile = require_tile();
      var { Event: Event3, ErrorEvent: ErrorEvent3, Evented: Evented3 } = (init_events(), __toCommonJS(events_exports));
      var TileCache = require_tile_cache();
      var Coordinate = require_coordinate();
      var { keysDifference } = require_object();
      var EXTENT = require_extent();
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      var browser = require_browser();
      var { OverscaledTileID } = require_tile_id();
      var assert = require_nanoassert();
      var SourceFeatureState = require_source_state();
      var SourceCache = class _SourceCache extends Evented3 {
        constructor(id, options, dispatcher) {
          super();
          this.id = id;
          this.dispatcher = dispatcher;
          this.on("data", (e) => {
            if (e.dataType === "source" && e.sourceDataType === "metadata") this._sourceLoaded = true;
            if (this._sourceLoaded && !this._paused && e.dataType === "source" && e.sourceDataType === "content") {
              this.reload();
              if (this.transform) {
                this.update(this.transform);
              }
            }
          });
          this.on("error", () => {
            this._sourceErrored = true;
          });
          this._source = createSource(id, options, dispatcher, this);
          this._tiles = {};
          this._cache = new TileCache(0, this._unloadTile.bind(this));
          this._maxTileCacheSize = null;
          this._isIdRenderable = this._isIdRenderable.bind(this);
          this._isIdRenderableForSymbols = this._isIdRenderableForSymbols.bind(this);
          this._coveredTiles = {};
          this._state = new SourceFeatureState();
        }
        onAdd(map) {
          this.map = map;
          this._maxTileCacheSize = map ? map._maxTileCacheSize : null;
          if (this._source?.onAdd) {
            this._source.onAdd(map);
          }
        }
        onRemove(map) {
          if (this._source?.onRemove) {
            this._source.onRemove(map);
          }
        }
        /**
         * Return true if no tile data is pending, tiles will not change unless
         * an additional API call is received.
         */
        loaded() {
          if (this._sourceErrored) {
            return true;
          }
          if (!this._sourceLoaded) {
            return false;
          }
          for (const t in this._tiles) {
            const tile = this._tiles[t];
            if (tile.state !== "loaded" && tile.state !== "errored") return false;
          }
          return true;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = true;
        }
        resume() {
          if (!this._paused) return;
          const shouldReload = this._shouldReloadOnResume;
          this._paused = false;
          this._shouldReloadOnResume = false;
          if (shouldReload) this.reload();
          if (this.transform) this.update(this.transform);
        }
        _loadTile(tile) {
          return this._source.loadTile(tile);
        }
        _unloadTile(tile) {
          return this._source.unloadTile?.(tile);
        }
        _abortTile(tile) {
          return this._source.abortTile?.(tile);
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(context) {
          this._source.prepare?.();
          this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const i in this._tiles) {
            this._tiles[i].upload(context);
          }
        }
        /**
         * Return all tile ids ordered with z-order, and cast to numbers
         */
        getIds() {
          const compareKeyZoom = (a_, b_) => {
            const a = this._tiles[a_].tileID;
            const b = this._tiles[b_].tileID;
            const rotatedA = new Point3(a.canonical.x, a.canonical.y).rotate(this.transform.angle);
            const rotatedB = new Point3(b.canonical.x, b.canonical.y).rotate(this.transform.angle);
            return a.overscaledZ - b.overscaledZ || rotatedB.y - rotatedA.y || rotatedB.x - rotatedA.x;
          };
          return Object.keys(this._tiles).map(Number).sort(compareKeyZoom);
        }
        getRenderableIds(symbolLayer) {
          return symbolLayer ? this.getIds().filter(this._isIdRenderableForSymbols) : this.getIds().filter(this._isIdRenderable);
        }
        hasRenderableParent(tileID) {
          const parentTile = this.findLoadedParent(tileID, 0);
          if (parentTile) {
            return this._isIdRenderable(parentTile.tileID.key);
          }
          return false;
        }
        _isIdRenderable(id) {
          return this._tiles[id]?.hasData() && !this._coveredTiles[id] && !this._tiles[id].holdingForFade();
        }
        _isIdRenderableForSymbols(id) {
          return this._tiles[id]?.hasData() && !this._coveredTiles[id];
        }
        reload() {
          if (this._paused) {
            this._shouldReloadOnResume = true;
            return;
          }
          this._cache.reset();
          for (const i in this._tiles) {
            if (this._tiles[i].state !== "errored") this._reloadTile(i, "reloading");
          }
        }
        _reloadTile(id, state) {
          const tile = this._tiles[id];
          if (!tile) return;
          if (tile.state !== "loading") {
            tile.state = state;
          }
          this._loadTile(tile).then(
            () => this._tileLoaded(tile),
            (err) => this._tileLoadError(tile, err)
          );
        }
        _tileLoadError(tile, err) {
          tile.state = "errored";
          if (err.doNothing) return;
          if (err.status !== 404) this._source.fire(new ErrorEvent3(err, { tile }));
          else this.update(this.transform);
        }
        _tileLoaded(tile, err) {
          tile.timeAdded = browser.now();
          if (this.getSource().type === "raster-dem" && tile.dem) this._backfillDEM(tile);
          this._state.initializeTileState(tile, this.map ? this.map.painter : null);
          this._source.fire(new Event3("data", { dataType: "source", tile, coord: tile.tileID }));
        }
        /**
         * For raster terrain source, backfill DEM to eliminate visible tile boundaries
         * @private
         */
        _backfillDEM(tile) {
          const renderables = this.getRenderableIds();
          for (let i = 0; i < renderables.length; i++) {
            const borderId = renderables[i];
            if (tile.neighboringTiles?.[borderId]) {
              const borderTile = this.getTileByID(borderId);
              fillBorder(tile, borderTile);
              fillBorder(borderTile, tile);
            }
          }
          function fillBorder(tile2, borderTile) {
            tile2.needsHillshadePrepare = true;
            let dx = borderTile.tileID.canonical.x - tile2.tileID.canonical.x;
            const dy = borderTile.tileID.canonical.y - tile2.tileID.canonical.y;
            const dim = 2 ** tile2.tileID.canonical.z;
            const borderId = borderTile.tileID.key;
            if (dx === 0 && dy === 0) return;
            if (Math.abs(dy) > 1) {
              return;
            }
            if (Math.abs(dx) > 1) {
              if (Math.abs(dx + dim) === 1) {
                dx += dim;
              } else if (Math.abs(dx - dim) === 1) {
                dx -= dim;
              }
            }
            if (!borderTile.dem || !tile2.dem) return;
            tile2.dem.backfillBorder(borderTile.dem, dx, dy);
            if (tile2.neighboringTiles?.[borderId]) tile2.neighboringTiles[borderId].backfilled = true;
          }
        }
        /**
         * Get a specific tile by TileID
         */
        getTile(tileID) {
          return this.getTileByID(tileID.key);
        }
        /**
         * Get a specific tile by id
         */
        getTileByID(id) {
          return this._tiles[id];
        }
        /**
         * get the zoom level adjusted for the difference in map and source tilesizes
         */
        getZoom(transform) {
          return transform.zoom + transform.scaleZoom(transform.tileSize / this._source.tileSize);
        }
        /**
         * For a given set of tiles, retain children that are loaded and have a zoom
         * between `zoom` (exclusive) and `maxCoveringZoom` (inclusive)
         */
        _retainLoadedChildren(idealTiles, zoom, maxCoveringZoom, retain) {
          for (const id in this._tiles) {
            let tile = this._tiles[id];
            if (retain[id] || !tile.hasData() || tile.tileID.overscaledZ <= zoom || tile.tileID.overscaledZ > maxCoveringZoom)
              continue;
            let topmostLoadedID = tile.tileID;
            while (tile && tile.tileID.overscaledZ > zoom + 1) {
              const parentID = tile.tileID.scaledTo(tile.tileID.overscaledZ - 1);
              tile = this._tiles[parentID.key];
              if (tile?.hasData()) {
                topmostLoadedID = parentID;
              }
            }
            let tileID = topmostLoadedID;
            while (tileID.overscaledZ > zoom) {
              tileID = tileID.scaledTo(tileID.overscaledZ - 1);
              if (idealTiles[tileID.key]) {
                retain[topmostLoadedID.key] = topmostLoadedID;
                break;
              }
            }
          }
        }
        /**
         * Find a loaded parent of the given tile (up to minCoveringZoom)
         */
        findLoadedParent(tileID, minCoveringZoom) {
          for (let z = tileID.overscaledZ - 1; z >= minCoveringZoom; z--) {
            const parent = tileID.scaledTo(z);
            if (!parent) return;
            const id = String(parent.key);
            const tile = this._tiles[id];
            if (tile?.hasData()) {
              return tile;
            }
            const pp = this._cache.get(parent);
            if (pp) {
              return pp;
            }
          }
        }
        /**
         * Resizes the tile cache based on the current viewport's size
         * or the maxTileCacheSize option passed during map creation
         *
         * Larger viewports use more tiles and need larger caches. Larger viewports
         * are more likely to be found on devices with more memory and on pages where
         * the map is more important.
         */
        updateCacheSize(transform) {
          const widthInTiles = Math.ceil(transform.width / this._source.tileSize) + 1;
          const heightInTiles = Math.ceil(transform.height / this._source.tileSize) + 1;
          const approxTilesInView = widthInTiles * heightInTiles;
          const commonZoomRange = 5;
          const viewDependentMaxSize = Math.floor(approxTilesInView * commonZoomRange);
          const maxSize = typeof this._maxTileCacheSize === "number" ? Math.min(this._maxTileCacheSize, viewDependentMaxSize) : viewDependentMaxSize;
          this._cache.setMaxSize(maxSize);
        }
        handleWrapJump(lng) {
          const prevLng = this._prevLng === void 0 ? lng : this._prevLng;
          const lngDifference = lng - prevLng;
          const worldDifference = lngDifference / 360;
          const wrapDelta = Math.round(worldDifference);
          this._prevLng = lng;
          if (wrapDelta) {
            const tiles = {};
            for (const key in this._tiles) {
              const tile = this._tiles[key];
              tile.tileID = tile.tileID.unwrapTo(tile.tileID.wrap + wrapDelta);
              tiles[tile.tileID.key] = tile;
            }
            this._tiles = tiles;
          }
        }
        /**
         * Removes tiles that are outside the viewport and adds new tiles that
         * are inside the viewport.
         */
        update(transform) {
          this.transform = transform;
          if (!this._sourceLoaded || this._paused) {
            return;
          }
          this.updateCacheSize(transform);
          this.handleWrapJump(this.transform.center.lng);
          this._coveredTiles = {};
          let idealTileIDs;
          if (!this.used) {
            idealTileIDs = [];
          } else if (this._source.tileID) {
            idealTileIDs = transform.getVisibleUnwrappedCoordinates(this._source.tileID).map(
              (unwrapped) => new OverscaledTileID(
                unwrapped.canonical.z,
                unwrapped.wrap,
                unwrapped.canonical.z,
                unwrapped.canonical.x,
                unwrapped.canonical.y
              )
            );
          } else {
            idealTileIDs = transform.coveringTiles({
              tileSize: this._source.tileSize,
              minzoom: this._source.minzoom,
              maxzoom: this._source.maxzoom,
              roundZoom: this._source.roundZoom,
              reparseOverscaled: this._source.reparseOverscaled
            });
            if (this._source.hasTile) {
              idealTileIDs = idealTileIDs.filter((coord) => this._source.hasTile(coord));
            }
          }
          const zoom = (this._source.roundZoom ? Math.round : Math.floor)(this.getZoom(transform));
          const minCoveringZoom = Math.max(zoom - _SourceCache.maxOverzooming, this._source.minzoom);
          const maxCoveringZoom = Math.max(zoom + _SourceCache.maxUnderzooming, this._source.minzoom);
          const retain = this._updateRetainedTiles(idealTileIDs, zoom);
          if (isRasterType(this._source.type)) {
            const parentsForFading = {};
            const fadingTiles = {};
            const ids = Object.keys(retain);
            for (const id of ids) {
              const tileID = retain[id];
              assert(tileID.key === +id);
              const tile = this._tiles[id];
              if (!tile || tile.fadeEndTime && tile.fadeEndTime <= browser.now()) continue;
              const parentTile = this.findLoadedParent(tileID, minCoveringZoom);
              if (parentTile) {
                this._addTile(parentTile.tileID);
                parentsForFading[parentTile.tileID.key] = parentTile.tileID;
              }
              fadingTiles[id] = tileID;
            }
            this._retainLoadedChildren(fadingTiles, zoom, maxCoveringZoom, retain);
            for (const id in parentsForFading) {
              if (!retain[id]) {
                this._coveredTiles[id] = true;
                retain[id] = parentsForFading[id];
              }
            }
          }
          for (const retainedId in retain) {
            this._tiles[retainedId].clearFadeHold();
          }
          const remove = keysDifference(this._tiles, retain);
          for (const tileID of remove) {
            const tile = this._tiles[tileID];
            if (tile.hasSymbolBuckets && !tile.holdingForFade()) {
              tile.setHoldDuration(this.map._fadeDuration);
            } else if (!tile.hasSymbolBuckets || tile.symbolFadeFinished()) {
              this._removeTile(tileID);
            }
          }
        }
        releaseSymbolFadeTiles() {
          for (const id in this._tiles) {
            if (this._tiles[id].holdingForFade()) {
              this._removeTile(id);
            }
          }
        }
        _updateRetainedTiles(idealTileIDs, zoom) {
          const retain = {};
          const checked = {};
          const minCoveringZoom = Math.max(zoom - _SourceCache.maxOverzooming, this._source.minzoom);
          const maxCoveringZoom = Math.max(zoom + _SourceCache.maxUnderzooming, this._source.minzoom);
          const missingTiles = {};
          for (const tileID of idealTileIDs) {
            const tile = this._addTile(tileID);
            retain[tileID.key] = tileID;
            if (tile.hasData()) continue;
            if (zoom < this._source.maxzoom) {
              missingTiles[tileID.key] = tileID;
            }
          }
          this._retainLoadedChildren(missingTiles, zoom, maxCoveringZoom, retain);
          for (const tileID of idealTileIDs) {
            let tile = this._tiles[tileID.key];
            if (tile.hasData()) continue;
            if (zoom + 1 > this._source.maxzoom) {
              const childCoord = tileID.children(this._source.maxzoom)[0];
              const childTile = this.getTile(childCoord);
              if (!!childTile && childTile.hasData()) {
                retain[childCoord.key] = childCoord;
                continue;
              }
            } else {
              const children = tileID.children(this._source.maxzoom);
              if (retain[children[0].key] && retain[children[1].key] && retain[children[2].key] && retain[children[3].key])
                continue;
            }
            let parentWasRequested = tile.wasRequested();
            for (let overscaledZ = tileID.overscaledZ - 1; overscaledZ >= minCoveringZoom; --overscaledZ) {
              const parentId = tileID.scaledTo(overscaledZ);
              if (checked[parentId.key]) break;
              checked[parentId.key] = true;
              tile = this.getTile(parentId);
              if (!tile && parentWasRequested) {
                tile = this._addTile(parentId);
              }
              if (tile) {
                retain[parentId.key] = parentId;
                parentWasRequested = tile.wasRequested();
                if (tile.hasData()) break;
              }
            }
          }
          return retain;
        }
        /**
         * Add a tile, given its coordinate, to the pyramid.
         * @private
         */
        _addTile(tileID) {
          let tile = this._tiles[tileID.key];
          if (tile) return tile;
          tile = this._cache.getAndRemove(tileID);
          if (tile) {
            tile.tileID = tileID;
            this._state.initializeTileState(tile, this.map ? this.map.painter : null);
          }
          const cached = Boolean(tile);
          if (!cached) {
            tile = new Tile(tileID, this._source.tileSize * tileID.overscaleFactor());
            this._loadTile(tile).then(
              () => this._tileLoaded(tile),
              (err) => this._tileLoadError(tile, err)
            );
          }
          if (!tile) return null;
          tile.uses++;
          this._tiles[tileID.key] = tile;
          if (!cached) this._source.fire(new Event3("dataloading", { tile, coord: tile.tileID, dataType: "source" }));
          return tile;
        }
        /**
         * Remove a tile, given its id, from the pyramid
         * @private
         */
        _removeTile(id) {
          const tile = this._tiles[id];
          if (!tile) return;
          tile.uses--;
          delete this._tiles[id];
          if (tile.uses > 0) return;
          if (tile.hasData()) {
            this._cache.add(tile);
          } else {
            tile.aborted = true;
            this._abortTile(tile);
            this._unloadTile(tile);
          }
        }
        /**
         * Remove all tiles from this pyramid
         */
        clearTiles() {
          this._shouldReloadOnResume = false;
          this._paused = false;
          for (const id in this._tiles) this._removeTile(id);
          this._cache.reset();
        }
        /**
         * Search through our current tiles and attempt to find the tiles that
         * cover the given bounds.
         * @param pointQueryGeometry coordinates of the corners of bounding rectangle
         * @returns {Array<Object>} result items have {tile, minX, maxX, minY, maxY}, where min/max bounding values are the given bounds transformed in into the coordinate space of this tile.
         */
        tilesIn(pointQueryGeometry, maxPitchScaleFactor, has3DLayer) {
          const tileResults = [];
          const transform = this.transform;
          if (!transform) return tileResults;
          const cameraPointQueryGeometry = has3DLayer ? transform.getCameraQueryGeometry(pointQueryGeometry) : pointQueryGeometry;
          const queryGeometry = pointQueryGeometry.map((p) => transform.pointCoordinate(p));
          const cameraQueryGeometry = cameraPointQueryGeometry.map((p) => transform.pointCoordinate(p));
          const ids = this.getIds();
          let minX = Number.POSITIVE_INFINITY;
          let minY = Number.POSITIVE_INFINITY;
          let maxX = Number.NEGATIVE_INFINITY;
          let maxY = Number.NEGATIVE_INFINITY;
          const z = queryGeometry[0].zoom;
          for (const p of cameraQueryGeometry) {
            minX = Math.min(minX, p.column);
            minY = Math.min(minY, p.row);
            maxX = Math.max(maxX, p.column);
            maxY = Math.max(maxY, p.row);
          }
          for (let i = 0; i < ids.length; i++) {
            const tile = this._tiles[ids[i]];
            if (tile.holdingForFade()) {
              continue;
            }
            const tileID = tile.tileID;
            const scale = 2 ** (transform.zoom - tile.tileID.overscaledZ);
            const queryPadding = maxPitchScaleFactor * tile.queryPadding * EXTENT / tile.tileSize / scale;
            const tileSpaceBounds = [
              coordinateToTilePoint(tileID, new Coordinate(minX, minY, z)),
              coordinateToTilePoint(tileID, new Coordinate(maxX, maxY, z))
            ];
            if (tileSpaceBounds[0].x - queryPadding < EXTENT && tileSpaceBounds[0].y - queryPadding < EXTENT && tileSpaceBounds[1].x + queryPadding >= 0 && tileSpaceBounds[1].y + queryPadding >= 0) {
              const tileSpaceQueryGeometry = queryGeometry.map((c) => coordinateToTilePoint(tileID, c));
              const tileSpaceCameraQueryGeometry = cameraQueryGeometry.map((c) => coordinateToTilePoint(tileID, c));
              tileResults.push({
                tile,
                tileID,
                queryGeometry: tileSpaceQueryGeometry,
                cameraQueryGeometry: tileSpaceCameraQueryGeometry,
                scale
              });
            }
          }
          return tileResults;
        }
        getVisibleCoordinates(symbolLayer) {
          const coords = this.getRenderableIds(symbolLayer).map((id) => this._tiles[id].tileID);
          for (const coord of coords) {
            coord.posMatrix = this.transform.calculatePosMatrix(coord.toUnwrapped());
          }
          return coords;
        }
        hasTransition() {
          if (this._source.hasTransition()) {
            return true;
          }
          if (isRasterType(this._source.type)) {
            for (const id in this._tiles) {
              const tile = this._tiles[id];
              if (tile.fadeEndTime !== void 0 && tile.fadeEndTime >= browser.now()) {
                return true;
              }
            }
          }
          return false;
        }
        /**
         * Set the value of a particular state for a feature
         * @private
         */
        setFeatureState(sourceLayer, feature, state) {
          sourceLayer = sourceLayer || "_geojsonTileLayer";
          this._state.updateState(sourceLayer, feature, state);
        }
        /**
         * Get the entire state object for a feature
         * @private
         */
        getFeatureState(sourceLayer, feature) {
          sourceLayer = sourceLayer || "_geojsonTileLayer";
          return this._state.getState(sourceLayer, feature);
        }
      };
      SourceCache.maxOverzooming = 10;
      SourceCache.maxUnderzooming = 3;
      function coordinateToTilePoint(tileID, coord) {
        const zoomedCoord = coord.zoomTo(tileID.canonical.z);
        return new Point3(
          (zoomedCoord.column - (tileID.canonical.x + tileID.wrap * 2 ** tileID.canonical.z)) * EXTENT,
          (zoomedCoord.row - tileID.canonical.y) * EXTENT
        );
      }
      function isRasterType(type) {
        return type === "raster" || type === "image";
      }
      module.exports = SourceCache;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/config.js
  var require_config = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/config.js"(exports, module) {
      var { Evented: Evented3 } = (init_events(), __toCommonJS(events_exports));
      function getDefaultWorkerCount() {
        const browser = require_browser();
        return Math.max(Math.floor(browser.hardwareConcurrency / 2), 1);
      }
      var config = new Evented3();
      config.set = function set(c) {
        Object.assign(config, c);
        config.notify();
      };
      config.notify = function() {
        config.fire("change", config);
      };
      config.set({
        WORKER_COUNT: getDefaultWorkerCount(),
        WORKER_URL: ""
      });
      module.exports = config;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/web_worker.js
  var require_web_worker = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/web_worker.js"(exports, module) {
      var config = require_config();
      module.exports = function() {
        return new window.Worker(config.WORKER_URL);
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/worker_pool.js
  var require_worker_pool = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/worker_pool.js"(exports, module) {
      var assert = require_nanoassert();
      var WebWorker = require_web_worker();
      var config = require_config();
      module.exports = workerPool;
      function workerPool(workerCount = config.WORKER_COUNT) {
        const active = {};
        let workers;
        function acquire(mapId) {
          if (!workers) {
            assert(typeof workerCount === "number" && workerCount < Number.POSITIVE_INFINITY);
            workers = new Array(workerCount);
            for (let i = 0; i < workerCount; i++) {
              workers[i] = new WebWorker();
            }
          }
          active[mapId] = true;
          return workers.slice();
        }
        function release(mapId) {
          delete active[mapId];
          if (Object.keys(active).length === 0) {
            workers.forEach((w) => w.terminate());
            workers = void 0;
          }
        }
        return {
          acquire,
          release
        };
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/global_worker_pool.js
  var require_global_worker_pool = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/global_worker_pool.js"(exports, module) {
      var workerPool = require_worker_pool();
      var globalWorkerPool;
      module.exports = function getGlobalWorkerPool() {
        if (!globalWorkerPool) {
          globalWorkerPool = workerPool();
        }
        return globalWorkerPool;
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style-spec/util/ref_properties.js
  var require_ref_properties = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style-spec/util/ref_properties.js"(exports, module) {
      module.exports = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style-spec/deref.js
  var require_deref = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style-spec/deref.js"(exports, module) {
      var refProperties = require_ref_properties();
      function deref(layer, parent) {
        const result = {};
        for (const k in layer) {
          if (k !== "ref") {
            result[k] = layer[k];
          }
        }
        refProperties.forEach((k) => {
          if (k in parent) {
            result[k] = parent[k];
          }
        });
        return result;
      }
      module.exports = derefLayers;
      function derefLayers(layers) {
        layers = layers.slice();
        const map = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < layers.length; i++) {
          map[layers[i].id] = layers[i];
        }
        for (let i = 0; i < layers.length; i++) {
          if ("ref" in layers[i]) {
            layers[i] = deref(layers[i], map[layers[i].ref]);
          }
        }
        return layers;
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/symbol/grid_index.js
  var require_grid_index2 = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/symbol/grid_index.js"(exports, module) {
      var { clamp } = require_util();
      var GridIndex = class {
        #boxUid = 0;
        #circleUid = 0;
        constructor(width, height, cellSize) {
          this.xCellCount = Math.ceil(width / cellSize);
          this.yCellCount = Math.ceil(height / cellSize);
          const size = this.xCellCount * this.yCellCount;
          this.boxCells = new Array(size);
          this.circleCells = new Array(size);
          this.circleKeys = [];
          this.boxKeys = [];
          this.bboxes = [];
          this.circles = [];
          this.width = width;
          this.height = height;
          this.xScale = this.xCellCount / width;
          this.yScale = this.yCellCount / height;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(key, x1, y1, x2, y2) {
          const { boxCells } = this;
          this.#forEachCell(x1, y1, x2, y2, insertBoxCell, this.#boxUid++);
          this.boxKeys.push(key);
          this.bboxes.push(x1, y1, x2, y2);
          function insertBoxCell(x12, y12, x22, y22, cellIndex, uid) {
            (boxCells[cellIndex] ??= []).push(uid);
          }
        }
        insertCircle(key, x, y, radius) {
          const { circleCells } = this;
          this.#forEachCell(x - radius, y - radius, x + radius, y + radius, insertCircleCell, this.#circleUid++);
          this.circleKeys.push(key);
          this.circles.push(x, y, radius);
          function insertCircleCell(x1, y1, x2, y2, cellIndex, uid) {
            (circleCells[cellIndex] ??= []).push(uid);
          }
        }
        #query(x1, y1, x2, y2, hitTest, predicate) {
          if (x2 < 0 || x1 > this.width || y2 < 0 || y1 > this.height) {
            return hitTest ? false : [];
          }
          const result = [];
          if (x1 <= 0 && y1 <= 0 && this.width <= x2 && this.height <= y2) {
            if (hitTest) {
              return true;
            }
            for (let boxUid = 0; boxUid < this.boxKeys.length; boxUid++) {
              result.push({
                key: this.boxKeys[boxUid],
                x1: this.bboxes[boxUid * 4],
                y1: this.bboxes[boxUid * 4 + 1],
                x2: this.bboxes[boxUid * 4 + 2],
                y2: this.bboxes[boxUid * 4 + 3]
              });
            }
            for (let circleUid = 0; circleUid < this.circleKeys.length; circleUid++) {
              const x = this.circles[circleUid * 3];
              const y = this.circles[circleUid * 3 + 1];
              const radius = this.circles[circleUid * 3 + 2];
              result.push({
                key: this.circleKeys[circleUid],
                x1: x - radius,
                y1: y - radius,
                x2: x + radius,
                y2: y + radius
              });
            }
            return predicate ? result.filter(predicate) : result;
          }
          const queryArgs = {
            hitTest,
            seenUids: { box: {}, circle: {} }
          };
          this.#forEachCell(x1, y1, x2, y2, queryCell, result, queryArgs, predicate);
          return hitTest ? result.length > 0 : result;
          function queryCell(x12, y12, x22, y22, cellIndex, result2, queryArgs2, predicate2) {
            const { seenUids } = queryArgs2;
            const boxCell = this.boxCells[cellIndex];
            if (boxCell != null) {
              const { bboxes } = this;
              for (const boxUid of boxCell) {
                if (!seenUids.box[boxUid]) {
                  seenUids.box[boxUid] = true;
                  const offset = boxUid * 4;
                  if (x12 <= bboxes[offset + 2] && y12 <= bboxes[offset + 3] && x22 >= bboxes[offset + 0] && y22 >= bboxes[offset + 1] && (!predicate2 || predicate2(this.boxKeys[boxUid]))) {
                    if (queryArgs2.hitTest) {
                      result2.push(true);
                      return true;
                    }
                    result2.push({
                      key: this.boxKeys[boxUid],
                      x1: bboxes[offset],
                      y1: bboxes[offset + 1],
                      x2: bboxes[offset + 2],
                      y2: bboxes[offset + 3]
                    });
                  }
                }
              }
            }
            const circleCell = this.circleCells[cellIndex];
            if (circleCell != null) {
              const { circles } = this;
              for (const circleUid of circleCell) {
                if (!seenUids.circle[circleUid]) {
                  seenUids.circle[circleUid] = true;
                  const offset = circleUid * 3;
                  if (circleAndRectCollide(circles[offset], circles[offset + 1], circles[offset + 2], x12, y12, x22, y22) && (!predicate2 || predicate2(this.circleKeys[circleUid]))) {
                    if (queryArgs2.hitTest) {
                      result2.push(true);
                      return true;
                    }
                    const x = circles[offset];
                    const y = circles[offset + 1];
                    const radius = circles[offset + 2];
                    result2.push({
                      key: this.circleKeys[circleUid],
                      x1: x - radius,
                      y1: y - radius,
                      x2: x + radius,
                      y2: y + radius
                    });
                  }
                }
              }
            }
          }
        }
        #queryCircle(x, y, radius, hitTest, predicate) {
          const x1 = x - radius;
          const x2 = x + radius;
          const y1 = y - radius;
          const y2 = y + radius;
          if (x2 < 0 || x1 > this.width || y2 < 0 || y1 > this.height) {
            return hitTest ? false : [];
          }
          const result = [];
          const queryArgs = {
            hitTest,
            circle: { x, y, radius },
            seenUids: { box: {}, circle: {} }
          };
          this.#forEachCell(x1, y1, x2, y2, queryCellCircle, result, queryArgs, predicate);
          return hitTest ? result.length > 0 : result;
          function queryCellCircle(x12, y12, x22, y22, cellIndex, result2, queryArgs2, predicate2) {
            const { circle, seenUids } = queryArgs2;
            const boxCell = this.boxCells[cellIndex];
            if (boxCell != null) {
              const { bboxes } = this;
              for (const boxUid of boxCell) {
                if (!seenUids.box[boxUid]) {
                  seenUids.box[boxUid] = true;
                  const offset = boxUid * 4;
                  if (circleAndRectCollide(
                    circle.x,
                    circle.y,
                    circle.radius,
                    bboxes[offset + 0],
                    bboxes[offset + 1],
                    bboxes[offset + 2],
                    bboxes[offset + 3]
                  ) && (!predicate2 || predicate2(this.boxKeys[boxUid]))) {
                    result2.push(true);
                    return true;
                  }
                }
              }
            }
            const circleCell = this.circleCells[cellIndex];
            if (circleCell != null) {
              const { circles } = this;
              for (const circleUid of circleCell) {
                if (!seenUids.circle[circleUid]) {
                  seenUids.circle[circleUid] = true;
                  const offset = circleUid * 3;
                  if (circlesCollide(
                    circles[offset],
                    circles[offset + 1],
                    circles[offset + 2],
                    circle.x,
                    circle.y,
                    circle.radius
                  ) && (!predicate2 || predicate2(this.circleKeys[circleUid]))) {
                    result2.push(true);
                    return true;
                  }
                }
              }
            }
          }
        }
        query(x1, y1, x2, y2, predicate) {
          return this.#query(x1, y1, x2, y2, false, predicate);
        }
        hitTest(x1, y1, x2, y2, predicate) {
          return this.#query(x1, y1, x2, y2, true, predicate);
        }
        hitTestCircle(x, y, radius, predicate) {
          return this.#queryCircle(x, y, radius, true, predicate);
        }
        #forEachCell(x1, y1, x2, y2, fn, ...args) {
          const { xCellCount, yCellCount, xScale, yScale } = this;
          const cx1 = cellX(x1);
          const cy1 = cellY(y1);
          const cx2 = cellX(x2);
          const cy2 = cellY(y2);
          for (let x = cx1; x <= cx2; x++) {
            for (let y = cy1; y <= cy2; y++) {
              const cellIndex = xCellCount * y + x;
              if (fn.call(this, x1, y1, x2, y2, cellIndex, ...args)) return;
            }
          }
          function cellX(x) {
            return clamp(Math.floor(x * xScale), 0, xCellCount - 1);
          }
          function cellY(y) {
            return clamp(Math.floor(y * yScale), 0, yCellCount - 1);
          }
        }
      };
      module.exports = GridIndex;
      function circlesCollide(x1, y1, r1, x2, y2, r2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const bothRadii = r1 + r2;
        return bothRadii * bothRadii > dx * dx + dy * dy;
      }
      function circleAndRectCollide(circleX, circleY, radius, x1, y1, x2, y2) {
        const halfRectWidth = (x2 - x1) / 2;
        const distX = Math.abs(circleX - (x1 + halfRectWidth));
        if (distX > halfRectWidth + radius) {
          return false;
        }
        const halfRectHeight = (y2 - y1) / 2;
        const distY = Math.abs(circleY - (y1 + halfRectHeight));
        if (distY > halfRectHeight + radius) {
          return false;
        }
        if (distX <= halfRectWidth || distY <= halfRectHeight) {
          return true;
        }
        const dx = distX - halfRectWidth;
        const dy = distY - halfRectHeight;
        return dx * dx + dy * dy <= radius * radius;
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/symbol/shaping.js
  var require_shaping = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/symbol/shaping.js"(exports, module) {
      var { charHasUprightVerticalOrientation, charAllowsIdeographicBreaking } = require_script_detection();
      var verticalizePunctuation = require_verticalize_punctuation();
      var { plugin: rtlTextPlugin } = require_rtl_text_plugin();
      var WritingMode = {
        horizontal: 1,
        vertical: 2,
        horizontalOnly: 3
      };
      module.exports = {
        shapeText,
        shapeIcon,
        WritingMode
      };
      var TaggedString = class _TaggedString {
        constructor() {
          this.text = "";
          this.sectionIndex = [];
          this.sections = [];
        }
        static fromFeature(text, defaultFontStack) {
          const result = new _TaggedString();
          for (let i = 0; i < text.sections.length; i++) {
            const section = text.sections[i];
            result.sections.push({
              scale: section.scale || 1,
              fontStack: section.fontStack || defaultFontStack
            });
            result.text += section.text;
            for (let j = 0; j < section.text.length; j++) {
              result.sectionIndex.push(i);
            }
          }
          return result;
        }
        length() {
          return this.text.length;
        }
        getSection(index) {
          return this.sections[this.sectionIndex[index]];
        }
        getCharCode(index) {
          return this.text.charCodeAt(index);
        }
        verticalizePunctuation() {
          this.text = verticalizePunctuation(this.text);
        }
        trim() {
          let beginningWhitespace = 0;
          for (let i = 0; i < this.text.length && whitespace[this.text.charCodeAt(i)]; i++) {
            beginningWhitespace++;
          }
          let trailingWhitespace = this.text.length;
          for (let i = this.text.length - 1; i >= 0 && i >= beginningWhitespace && whitespace[this.text.charCodeAt(i)]; i--) {
            trailingWhitespace--;
          }
          this.text = this.text.substring(beginningWhitespace, trailingWhitespace);
          this.sectionIndex = this.sectionIndex.slice(beginningWhitespace, trailingWhitespace);
        }
        substring(start, end) {
          const substring = new _TaggedString();
          substring.text = this.text.substring(start, end);
          substring.sectionIndex = this.sectionIndex.slice(start, end);
          substring.sections = this.sections;
          return substring;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((max, index) => Math.max(max, this.sections[index].scale), 0);
        }
      };
      function breakLines(input, lineBreakPoints) {
        const lines = [];
        const text = input.text;
        let start = 0;
        for (const lineBreak of lineBreakPoints) {
          lines.push(input.substring(start, lineBreak));
          start = lineBreak;
        }
        if (start < text.length) {
          lines.push(input.substring(start, text.length));
        }
        return lines;
      }
      function shapeText(text, glyphs, defaultFontStack, maxWidth, lineHeight, textAnchor, textJustify, spacing, translate, verticalHeight, writingMode) {
        const logicalInput = TaggedString.fromFeature(text, defaultFontStack);
        if (writingMode === WritingMode.vertical) {
          logicalInput.verticalizePunctuation();
        }
        const positionedGlyphs = [];
        const shaping = {
          positionedGlyphs,
          text: logicalInput,
          top: translate[1],
          bottom: translate[1],
          left: translate[0],
          right: translate[0],
          writingMode
        };
        let lines;
        const { processBidirectionalText, processStyledBidirectionalText } = rtlTextPlugin;
        if (processBidirectionalText && logicalInput.sections.length === 1) {
          lines = [];
          const untaggedLines = processBidirectionalText(
            logicalInput.toString(),
            determineLineBreaks(logicalInput, spacing, maxWidth, glyphs)
          );
          for (const line of untaggedLines) {
            const taggedLine = new TaggedString();
            taggedLine.text = line;
            taggedLine.sections = logicalInput.sections;
            for (let i = 0; i < line.length; i++) {
              taggedLine.sectionIndex.push(0);
            }
            lines.push(taggedLine);
          }
        } else if (processStyledBidirectionalText) {
          lines = [];
          const processedLines = processStyledBidirectionalText(
            logicalInput.text,
            logicalInput.sectionIndex,
            determineLineBreaks(logicalInput, spacing, maxWidth, glyphs)
          );
          for (const line of processedLines) {
            const taggedLine = new TaggedString();
            taggedLine.text = line[0];
            taggedLine.sectionIndex = line[1];
            taggedLine.sections = logicalInput.sections;
            lines.push(taggedLine);
          }
        } else {
          lines = breakLines(logicalInput, determineLineBreaks(logicalInput, spacing, maxWidth, glyphs));
        }
        shapeLines(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, writingMode, spacing, verticalHeight);
        if (!positionedGlyphs.length) return false;
        shaping.text = shaping.text.toString();
        return shaping;
      }
      var whitespace = {
        [9]: true,
        // tab
        [10]: true,
        // newline
        [11]: true,
        // vertical tab
        [12]: true,
        // form feed
        [13]: true,
        // carriage return
        [32]: true
        // space
      };
      var breakable = {
        [10]: true,
        // newline
        [32]: true,
        // space
        [38]: true,
        // ampersand
        [40]: true,
        // left parenthesis
        [41]: true,
        // right parenthesis
        [43]: true,
        // plus sign
        [45]: true,
        // hyphen-minus
        [47]: true,
        // solidus
        [173]: true,
        // soft hyphen
        [183]: true,
        // middle dot
        [8203]: true,
        // zero-width space
        [8208]: true,
        // hyphen
        [8211]: true,
        // en dash
        [8231]: true
        // interpunct
        // Many other characters may be reasonable breakpoints
        // Consider "neutral orientation" characters at scriptDetection.charHasNeutralVerticalOrientation
        // See https://github.com/mapbox/mapbox-gl-js/issues/3658
      };
      function determineAverageLineWidth(logicalInput, spacing, maxWidth, glyphMap) {
        let totalWidth = 0;
        for (let index = 0; index < logicalInput.length(); index++) {
          const section = logicalInput.getSection(index);
          const positions = glyphMap[section.fontStack];
          const glyph = positions?.[logicalInput.getCharCode(index)];
          if (!glyph) continue;
          totalWidth += glyph.metrics.advance * section.scale + spacing;
        }
        const lineCount = Math.max(1, Math.ceil(totalWidth / maxWidth));
        return totalWidth / lineCount;
      }
      function calculateBadness(lineWidth, targetWidth, penalty, isLastBreak) {
        const raggedness = (lineWidth - targetWidth) ** 2;
        if (isLastBreak) {
          if (lineWidth < targetWidth) {
            return raggedness / 2;
          }
          return raggedness * 2;
        }
        return raggedness + Math.abs(penalty) * penalty;
      }
      function calculatePenalty(codePoint, nextCodePoint) {
        let penalty = 0;
        if (codePoint === 10) {
          penalty -= 1e4;
        }
        if (codePoint === 40 || codePoint === 65288) {
          penalty += 50;
        }
        if (nextCodePoint === 41 || nextCodePoint === 65289) {
          penalty += 50;
        }
        return penalty;
      }
      function evaluateBreak(breakIndex, breakX, targetWidth, potentialBreaks, penalty, isLastBreak) {
        let bestPriorBreak = null;
        let bestBreakBadness = calculateBadness(breakX, targetWidth, penalty, isLastBreak);
        for (const potentialBreak of potentialBreaks) {
          const lineWidth = breakX - potentialBreak.x;
          const breakBadness = calculateBadness(lineWidth, targetWidth, penalty, isLastBreak) + potentialBreak.badness;
          if (breakBadness <= bestBreakBadness) {
            bestPriorBreak = potentialBreak;
            bestBreakBadness = breakBadness;
          }
        }
        return {
          index: breakIndex,
          x: breakX,
          priorBreak: bestPriorBreak,
          badness: bestBreakBadness
        };
      }
      function leastBadBreaks(lastLineBreak) {
        if (!lastLineBreak) {
          return [];
        }
        return leastBadBreaks(lastLineBreak.priorBreak).concat(lastLineBreak.index);
      }
      function determineLineBreaks(logicalInput, spacing, maxWidth, glyphMap) {
        if (!maxWidth) return [];
        if (!logicalInput) return [];
        const potentialLineBreaks = [];
        const targetWidth = determineAverageLineWidth(logicalInput, spacing, maxWidth, glyphMap);
        let currentX = 0;
        for (let i = 0; i < logicalInput.length(); i++) {
          const section = logicalInput.getSection(i);
          const codePoint = logicalInput.getCharCode(i);
          const positions = glyphMap[section.fontStack];
          const glyph = positions?.[codePoint];
          if (glyph && !whitespace[codePoint]) currentX += glyph.metrics.advance * section.scale + spacing;
          if (i < logicalInput.length() - 1 && (breakable[codePoint] || charAllowsIdeographicBreaking(codePoint))) {
            potentialLineBreaks.push(
              evaluateBreak(
                i + 1,
                currentX,
                targetWidth,
                potentialLineBreaks,
                calculatePenalty(codePoint, logicalInput.getCharCode(i + 1)),
                false
              )
            );
          }
        }
        return leastBadBreaks(evaluateBreak(logicalInput.length(), currentX, targetWidth, potentialLineBreaks, 0, true));
      }
      function getAnchorAlignment(anchor) {
        let horizontalAlign = 0.5;
        let verticalAlign = 0.5;
        switch (anchor) {
          case "right":
          case "top-right":
          case "bottom-right":
            horizontalAlign = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            horizontalAlign = 0;
            break;
        }
        switch (anchor) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            verticalAlign = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            verticalAlign = 0;
            break;
        }
        return { horizontalAlign, verticalAlign };
      }
      function shapeLines(shaping, glyphMap, lines, lineHeight, textAnchor, textJustify, writingMode, spacing, verticalHeight) {
        const yOffset = -17;
        let x = 0;
        let y = yOffset;
        let maxLineLength = 0;
        const positionedGlyphs = shaping.positionedGlyphs;
        const justify = textJustify === "right" ? 1 : textJustify === "left" ? 0 : 0.5;
        for (const line of lines) {
          line.trim();
          const lineMaxScale = line.getMaxScale();
          if (!line.length()) {
            y += lineHeight;
            continue;
          }
          const lineStartIndex = positionedGlyphs.length;
          for (let i = 0; i < line.length(); i++) {
            const section = line.getSection(i);
            const codePoint = line.getCharCode(i);
            const baselineOffset = (lineMaxScale - section.scale) * 24;
            const positions = glyphMap[section.fontStack];
            const glyph = positions?.[codePoint];
            if (!glyph) continue;
            if (!charHasUprightVerticalOrientation(codePoint) || writingMode === WritingMode.horizontal) {
              positionedGlyphs.push({
                glyph: codePoint,
                x,
                y: y + baselineOffset,
                vertical: false,
                scale: section.scale,
                fontStack: section.fontStack
              });
              x += glyph.metrics.advance * section.scale + spacing;
            } else {
              positionedGlyphs.push({
                glyph: codePoint,
                x,
                y: baselineOffset,
                vertical: true,
                scale: section.scale,
                fontStack: section.fontStack
              });
              x += verticalHeight * section.scale + spacing;
            }
          }
          if (positionedGlyphs.length !== lineStartIndex) {
            const lineLength = x - spacing;
            maxLineLength = Math.max(lineLength, maxLineLength);
            justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);
          }
          x = 0;
          y += lineHeight * lineMaxScale;
        }
        const { horizontalAlign, verticalAlign } = getAnchorAlignment(textAnchor);
        align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lines.length);
        const height = y - yOffset;
        shaping.top += -verticalAlign * height;
        shaping.bottom = shaping.top + height;
        shaping.left += -horizontalAlign * maxLineLength;
        shaping.right = shaping.left + maxLineLength;
      }
      function justifyLine(positionedGlyphs, glyphMap, start, end, justify) {
        if (!justify) return;
        const lastPositionedGlyph = positionedGlyphs[end];
        const positions = glyphMap[lastPositionedGlyph.fontStack];
        const glyph = positions?.[lastPositionedGlyph.glyph];
        if (glyph) {
          const lastAdvance = glyph.metrics.advance * lastPositionedGlyph.scale;
          const lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;
          for (let j = start; j <= end; j++) {
            positionedGlyphs[j].x -= lineIndent;
          }
        }
      }
      function align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lineCount) {
        const shiftX = (justify - horizontalAlign) * maxLineLength;
        const shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;
        for (let j = 0; j < positionedGlyphs.length; j++) {
          positionedGlyphs[j].x += shiftX;
          positionedGlyphs[j].y += shiftY;
        }
      }
      function shapeIcon(image, iconOffset, iconAnchor) {
        const { horizontalAlign, verticalAlign } = getAnchorAlignment(iconAnchor);
        const dx = iconOffset[0];
        const dy = iconOffset[1];
        const x1 = dx - image.displaySize[0] * horizontalAlign;
        const x2 = x1 + image.displaySize[0];
        const y1 = dy - image.displaySize[1] * verticalAlign;
        const y2 = y1 + image.displaySize[1];
        return { image, top: y1, bottom: y2, left: x1, right: x2 };
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/symbol/projection.js
  var require_projection = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/symbol/projection.js"(exports, module) {
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      var { mat4, vec4 } = require_gl_matrix();
      var symbolSize = require_symbol_size();
      var { addDynamicAttributes } = require_symbol_bucket();
      var properties = require_symbol_style_layer_properties();
      var symbolLayoutProperties = properties.layout;
      var { WritingMode } = require_shaping();
      module.exports = {
        updateLineLabels,
        getLabelPlaneMatrix,
        getGlCoordMatrix,
        project,
        placeFirstAndLastGlyph,
        xyTransformMat4
      };
      function getLabelPlaneMatrix(posMatrix, pitchWithMap, rotateWithMap, transform, pixelsToTileUnits) {
        const m = mat4.identity(new Float32Array(16));
        if (pitchWithMap) {
          mat4.identity(m);
          mat4.scale(m, m, [1 / pixelsToTileUnits, 1 / pixelsToTileUnits, 1]);
          if (!rotateWithMap) {
            mat4.rotateZ(m, m, transform.angle);
          }
        } else {
          mat4.scale(m, m, [transform.width / 2, -transform.height / 2, 1]);
          mat4.translate(m, m, [1, -1, 0]);
          mat4.multiply(m, m, posMatrix);
        }
        return m;
      }
      function getGlCoordMatrix(posMatrix, pitchWithMap, rotateWithMap, transform, pixelsToTileUnits) {
        const m = mat4.identity(new Float32Array(16));
        if (pitchWithMap) {
          mat4.multiply(m, m, posMatrix);
          mat4.scale(m, m, [pixelsToTileUnits, pixelsToTileUnits, 1]);
          if (!rotateWithMap) {
            mat4.rotateZ(m, m, -transform.angle);
          }
        } else {
          mat4.scale(m, m, [1, -1, 1]);
          mat4.translate(m, m, [-1, -1, 0]);
          mat4.scale(m, m, [2 / transform.width, 2 / transform.height, 1]);
        }
        return m;
      }
      function project(point, matrix) {
        const pos = [point.x, point.y, 0, 1];
        xyTransformMat4(pos, pos, matrix);
        const w = pos[3];
        return {
          point: new Point3(pos[0] / w, pos[1] / w),
          signedDistanceFromCamera: w
        };
      }
      function isVisible(anchorPos, clippingBuffer) {
        const x = anchorPos[0] / anchorPos[3];
        const y = anchorPos[1] / anchorPos[3];
        const inPaddedViewport = x >= -clippingBuffer[0] && x <= clippingBuffer[0] && y >= -clippingBuffer[1] && y <= clippingBuffer[1];
        return inPaddedViewport;
      }
      function updateLineLabels(bucket, posMatrix, painter, isText, labelPlaneMatrix, glCoordMatrix, pitchWithMap, keepUpright) {
        const sizeData = isText ? bucket.textSizeData : bucket.iconSizeData;
        const partiallyEvaluatedSize = symbolSize.evaluateSizeForZoom(
          sizeData,
          painter.transform.zoom,
          symbolLayoutProperties.properties[isText ? "text-size" : "icon-size"]
        );
        const clippingBuffer = [256 / painter.width * 2 + 1, 256 / painter.height * 2 + 1];
        const dynamicLayoutVertexArray = isText ? bucket.text.dynamicLayoutVertexArray : bucket.icon.dynamicLayoutVertexArray;
        dynamicLayoutVertexArray.clear();
        const lineVertexArray = bucket.lineVertexArray;
        const placedSymbols = isText ? bucket.text.placedSymbolArray : bucket.icon.placedSymbolArray;
        const aspectRatio = painter.transform.width / painter.transform.height;
        let useVertical = false;
        for (let s = 0; s < placedSymbols.length; s++) {
          const symbol = placedSymbols.get(s);
          if (symbol.hidden || symbol.writingMode === WritingMode.vertical && !useVertical) {
            hideGlyphs(symbol.numGlyphs, dynamicLayoutVertexArray);
            continue;
          }
          useVertical = false;
          const anchorPos = [symbol.anchorX, symbol.anchorY, 0, 1];
          vec4.transformMat4(anchorPos, anchorPos, posMatrix);
          if (!isVisible(anchorPos, clippingBuffer)) {
            hideGlyphs(symbol.numGlyphs, dynamicLayoutVertexArray);
            continue;
          }
          const cameraToAnchorDistance = anchorPos[3];
          const perspectiveRatio = 0.5 + 0.5 * (cameraToAnchorDistance / painter.transform.cameraToCenterDistance);
          const fontSize = symbolSize.evaluateSizeForFeature(sizeData, partiallyEvaluatedSize, symbol);
          const pitchScaledFontSize = pitchWithMap ? fontSize * perspectiveRatio : fontSize / perspectiveRatio;
          const tileAnchorPoint = new Point3(symbol.anchorX, symbol.anchorY);
          const anchorPoint = project(tileAnchorPoint, labelPlaneMatrix).point;
          const projectionCache = {};
          const placeUnflipped = placeGlyphsAlongLine(
            symbol,
            pitchScaledFontSize,
            false,
            keepUpright,
            posMatrix,
            labelPlaneMatrix,
            glCoordMatrix,
            bucket.glyphOffsetArray,
            lineVertexArray,
            dynamicLayoutVertexArray,
            anchorPoint,
            tileAnchorPoint,
            projectionCache,
            aspectRatio
          );
          useVertical = placeUnflipped.useVertical;
          if (placeUnflipped.notEnoughRoom || useVertical || placeUnflipped.needsFlipping && placeGlyphsAlongLine(
            symbol,
            pitchScaledFontSize,
            true,
            keepUpright,
            posMatrix,
            labelPlaneMatrix,
            glCoordMatrix,
            bucket.glyphOffsetArray,
            lineVertexArray,
            dynamicLayoutVertexArray,
            anchorPoint,
            tileAnchorPoint,
            projectionCache,
            aspectRatio
          ).notEnoughRoom) {
            hideGlyphs(symbol.numGlyphs, dynamicLayoutVertexArray);
          }
        }
        if (isText) {
          bucket.text.dynamicLayoutVertexBuffer.updateData(dynamicLayoutVertexArray);
        } else {
          bucket.icon.dynamicLayoutVertexBuffer.updateData(dynamicLayoutVertexArray);
        }
      }
      function placeFirstAndLastGlyph(fontScale, glyphOffsetArray, lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol, lineVertexArray, labelPlaneMatrix, projectionCache, returnTileDistance) {
        const glyphEndIndex = symbol.glyphStartIndex + symbol.numGlyphs;
        const lineStartIndex = symbol.lineStartIndex;
        const lineEndIndex = symbol.lineStartIndex + symbol.lineLength;
        const firstGlyphOffset = glyphOffsetArray.getoffsetX(symbol.glyphStartIndex);
        const lastGlyphOffset = glyphOffsetArray.getoffsetX(glyphEndIndex - 1);
        const firstPlacedGlyph = placeGlyphAlongLine(
          fontScale * firstGlyphOffset,
          lineOffsetX,
          lineOffsetY,
          flip,
          anchorPoint,
          tileAnchorPoint,
          symbol.segment,
          lineStartIndex,
          lineEndIndex,
          lineVertexArray,
          labelPlaneMatrix,
          projectionCache,
          returnTileDistance
        );
        if (!firstPlacedGlyph) return null;
        const lastPlacedGlyph = placeGlyphAlongLine(
          fontScale * lastGlyphOffset,
          lineOffsetX,
          lineOffsetY,
          flip,
          anchorPoint,
          tileAnchorPoint,
          symbol.segment,
          lineStartIndex,
          lineEndIndex,
          lineVertexArray,
          labelPlaneMatrix,
          projectionCache,
          returnTileDistance
        );
        if (!lastPlacedGlyph) return null;
        return { first: firstPlacedGlyph, last: lastPlacedGlyph };
      }
      function requiresOrientationChange(writingMode, firstPoint, lastPoint, aspectRatio) {
        if (writingMode === WritingMode.horizontal) {
          const rise = Math.abs(lastPoint.y - firstPoint.y);
          const run = Math.abs(lastPoint.x - firstPoint.x) * aspectRatio;
          if (rise > run) {
            return { useVertical: true };
          }
        }
        if (writingMode === WritingMode.vertical ? firstPoint.y < lastPoint.y : firstPoint.x > lastPoint.x) {
          return { needsFlipping: true };
        }
        return null;
      }
      function placeGlyphsAlongLine(symbol, fontSize, flip, keepUpright, posMatrix, labelPlaneMatrix, glCoordMatrix, glyphOffsetArray, lineVertexArray, dynamicLayoutVertexArray, anchorPoint, tileAnchorPoint, projectionCache, aspectRatio) {
        const fontScale = fontSize / 24;
        const lineOffsetX = symbol.lineOffsetX * fontSize;
        const lineOffsetY = symbol.lineOffsetY * fontSize;
        let placedGlyphs;
        if (symbol.numGlyphs > 1) {
          const glyphEndIndex = symbol.glyphStartIndex + symbol.numGlyphs;
          const lineStartIndex = symbol.lineStartIndex;
          const lineEndIndex = symbol.lineStartIndex + symbol.lineLength;
          const firstAndLastGlyph = placeFirstAndLastGlyph(
            fontScale,
            glyphOffsetArray,
            lineOffsetX,
            lineOffsetY,
            flip,
            anchorPoint,
            tileAnchorPoint,
            symbol,
            lineVertexArray,
            labelPlaneMatrix,
            projectionCache,
            false
          );
          if (!firstAndLastGlyph) {
            return { notEnoughRoom: true };
          }
          const firstPoint = project(firstAndLastGlyph.first.point, glCoordMatrix).point;
          const lastPoint = project(firstAndLastGlyph.last.point, glCoordMatrix).point;
          if (keepUpright && !flip) {
            const orientationChange = requiresOrientationChange(symbol.writingMode, firstPoint, lastPoint, aspectRatio);
            if (orientationChange) {
              return orientationChange;
            }
          }
          placedGlyphs = [firstAndLastGlyph.first];
          for (let glyphIndex = symbol.glyphStartIndex + 1; glyphIndex < glyphEndIndex - 1; glyphIndex++) {
            placedGlyphs.push(
              placeGlyphAlongLine(
                fontScale * glyphOffsetArray.getoffsetX(glyphIndex),
                lineOffsetX,
                lineOffsetY,
                flip,
                anchorPoint,
                tileAnchorPoint,
                symbol.segment,
                lineStartIndex,
                lineEndIndex,
                lineVertexArray,
                labelPlaneMatrix,
                projectionCache,
                false
              )
            );
          }
          placedGlyphs.push(firstAndLastGlyph.last);
        } else {
          if (keepUpright && !flip) {
            const a = project(tileAnchorPoint, posMatrix).point;
            const tileVertexIndex = symbol.lineStartIndex + symbol.segment + 1;
            const tileSegmentEnd = new Point3(lineVertexArray.getx(tileVertexIndex), lineVertexArray.gety(tileVertexIndex));
            const projectedVertex = project(tileSegmentEnd, posMatrix);
            const b = projectedVertex.signedDistanceFromCamera > 0 ? projectedVertex.point : projectTruncatedLineSegment(tileAnchorPoint, tileSegmentEnd, a, 1, posMatrix);
            const orientationChange = requiresOrientationChange(symbol.writingMode, a, b, aspectRatio);
            if (orientationChange) {
              return orientationChange;
            }
          }
          const singleGlyph = placeGlyphAlongLine(
            fontScale * glyphOffsetArray.getoffsetX(symbol.glyphStartIndex),
            lineOffsetX,
            lineOffsetY,
            flip,
            anchorPoint,
            tileAnchorPoint,
            symbol.segment,
            symbol.lineStartIndex,
            symbol.lineStartIndex + symbol.lineLength,
            lineVertexArray,
            labelPlaneMatrix,
            projectionCache,
            false
          );
          if (!singleGlyph) return { notEnoughRoom: true };
          placedGlyphs = [singleGlyph];
        }
        for (const glyph of placedGlyphs) {
          addDynamicAttributes(dynamicLayoutVertexArray, glyph.point, glyph.angle);
        }
        return {};
      }
      function projectTruncatedLineSegment(previousTilePoint, currentTilePoint, previousProjectedPoint, minimumLength, projectionMatrix) {
        const projectedUnitVertex = project(
          previousTilePoint.add(previousTilePoint.sub(currentTilePoint)._unit()),
          projectionMatrix
        ).point;
        const projectedUnitSegment = previousProjectedPoint.sub(projectedUnitVertex);
        return previousProjectedPoint.add(projectedUnitSegment._mult(minimumLength / projectedUnitSegment.mag()));
      }
      function placeGlyphAlongLine(offsetX, lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, anchorSegment, lineStartIndex, lineEndIndex, lineVertexArray, labelPlaneMatrix, projectionCache, returnTileDistance) {
        const combinedOffsetX = flip ? offsetX - lineOffsetX : offsetX + lineOffsetX;
        let dir = combinedOffsetX > 0 ? 1 : -1;
        let angle = 0;
        if (flip) {
          dir *= -1;
          angle = Math.PI;
        }
        if (dir < 0) angle += Math.PI;
        let currentIndex = dir > 0 ? lineStartIndex + anchorSegment : lineStartIndex + anchorSegment + 1;
        const initialIndex = currentIndex;
        let current = anchorPoint;
        let prev = anchorPoint;
        let distanceToPrev = 0;
        let currentSegmentDistance = 0;
        const absOffsetX = Math.abs(combinedOffsetX);
        while (distanceToPrev + currentSegmentDistance <= absOffsetX) {
          currentIndex += dir;
          if (currentIndex < lineStartIndex || currentIndex >= lineEndIndex) return null;
          prev = current;
          current = projectionCache[currentIndex];
          if (current === void 0) {
            const currentVertex = new Point3(lineVertexArray.getx(currentIndex), lineVertexArray.gety(currentIndex));
            const projection = project(currentVertex, labelPlaneMatrix);
            if (projection.signedDistanceFromCamera > 0) {
              current = projectionCache[currentIndex] = projection.point;
            } else {
              const previousLineVertexIndex = currentIndex - dir;
              const previousTilePoint = distanceToPrev === 0 ? tileAnchorPoint : new Point3(lineVertexArray.getx(previousLineVertexIndex), lineVertexArray.gety(previousLineVertexIndex));
              current = projectTruncatedLineSegment(
                previousTilePoint,
                currentVertex,
                prev,
                absOffsetX - distanceToPrev + 1,
                labelPlaneMatrix
              );
            }
          }
          distanceToPrev += currentSegmentDistance;
          currentSegmentDistance = prev.dist(current);
        }
        const segmentInterpolationT = (absOffsetX - distanceToPrev) / currentSegmentDistance;
        const prevToCurrent = current.sub(prev);
        const p = prevToCurrent.mult(segmentInterpolationT)._add(prev);
        p._add(
          prevToCurrent._unit()._perp()._mult(lineOffsetY * dir)
        );
        const segmentAngle = angle + Math.atan2(current.y - prev.y, current.x - prev.x);
        return {
          point: p,
          angle: segmentAngle,
          tileDistance: returnTileDistance ? {
            prevTileDistance: currentIndex - dir === initialIndex ? 0 : lineVertexArray.gettileUnitDistanceFromAnchor(currentIndex - dir),
            lastSegmentViewportDistance: absOffsetX - distanceToPrev
          } : null
        };
      }
      var hiddenGlyphAttributes = new Float32Array([
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        0,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        0,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        0,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        0
      ]);
      function hideGlyphs(num, dynamicLayoutVertexArray) {
        for (let i = 0; i < num; i++) {
          const offset = dynamicLayoutVertexArray.length;
          dynamicLayoutVertexArray.resize(offset + 4);
          dynamicLayoutVertexArray.float32.set(hiddenGlyphAttributes, offset * 3);
        }
      }
      function xyTransformMat4(out, a, m) {
        const x = a[0];
        const y = a[1];
        out[0] = m[0] * x + m[4] * y + m[12];
        out[1] = m[1] * x + m[5] * y + m[13];
        out[3] = m[3] * x + m[7] * y + m[15];
        return out;
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/symbol/collision_index.js
  var require_collision_index = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/symbol/collision_index.js"(exports, module) {
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      var intersectionTests = require_intersection_tests();
      var Grid = require_grid_index2();
      var projection = require_projection();
      var viewportPadding = 100;
      var CollisionIndex = class {
        constructor(transform, grid = new Grid(transform.width + 2 * viewportPadding, transform.height + 2 * viewportPadding, 25), ignoredGrid = new Grid(transform.width + 2 * viewportPadding, transform.height + 2 * viewportPadding, 25)) {
          this.transform = transform;
          this.grid = grid;
          this.ignoredGrid = ignoredGrid;
          this.pitchfactor = Math.cos(transform._pitch) * transform.cameraToCenterDistance;
          this.screenRightBoundary = transform.width + viewportPadding;
          this.screenBottomBoundary = transform.height + viewportPadding;
          this.gridRightBoundary = transform.width + 2 * viewportPadding;
          this.gridBottomBoundary = transform.height + 2 * viewportPadding;
        }
        placeCollisionBox(collisionBox, allowOverlap, textPixelRatio, posMatrix, collisionGroupPredicate) {
          const projectedPoint = this.projectAndGetPerspectiveRatio(
            posMatrix,
            collisionBox.anchorPointX,
            collisionBox.anchorPointY
          );
          const tileToViewport = textPixelRatio * projectedPoint.perspectiveRatio;
          const tlX = collisionBox.x1 * tileToViewport + projectedPoint.point.x;
          const tlY = collisionBox.y1 * tileToViewport + projectedPoint.point.y;
          const brX = collisionBox.x2 * tileToViewport + projectedPoint.point.x;
          const brY = collisionBox.y2 * tileToViewport + projectedPoint.point.y;
          if (!this.isInsideGrid(tlX, tlY, brX, brY) || !allowOverlap && this.grid.hitTest(tlX, tlY, brX, brY, collisionGroupPredicate)) {
            return {
              box: [],
              offscreen: false
            };
          }
          return {
            box: [tlX, tlY, brX, brY],
            offscreen: this.isOffscreen(tlX, tlY, brX, brY)
          };
        }
        approximateTileDistance(tileDistance, lastSegmentAngle, pixelsToTileUnits, cameraToAnchorDistance, pitchWithMap) {
          const incidenceStretch = pitchWithMap ? 1 : cameraToAnchorDistance / this.pitchfactor;
          const lastSegmentTile = tileDistance.lastSegmentViewportDistance * pixelsToTileUnits;
          return tileDistance.prevTileDistance + lastSegmentTile + (incidenceStretch - 1) * lastSegmentTile * Math.abs(Math.sin(lastSegmentAngle));
        }
        placeCollisionCircles(collisionCircles, allowOverlap, scale, textPixelRatio, symbol, lineVertexArray, glyphOffsetArray, fontSize, posMatrix, labelPlaneMatrix, showCollisionCircles, pitchWithMap, collisionGroupPredicate) {
          const placedCollisionCircles = [];
          const projectedAnchor = this.projectAnchor(posMatrix, symbol.anchorX, symbol.anchorY);
          const projectionCache = {};
          const fontScale = fontSize / 24;
          const lineOffsetX = symbol.lineOffsetX * fontSize;
          const lineOffsetY = symbol.lineOffsetY * fontSize;
          const tileUnitAnchorPoint = new Point3(symbol.anchorX, symbol.anchorY);
          const labelPlaneAnchorPoint = projection.project(tileUnitAnchorPoint, labelPlaneMatrix).point;
          const firstAndLastGlyph = projection.placeFirstAndLastGlyph(
            fontScale,
            glyphOffsetArray,
            lineOffsetX,
            lineOffsetY,
            /*flip*/
            false,
            labelPlaneAnchorPoint,
            tileUnitAnchorPoint,
            symbol,
            lineVertexArray,
            labelPlaneMatrix,
            projectionCache,
            /*return tile distance*/
            true
          );
          let collisionDetected = false;
          let inGrid = false;
          let entirelyOffscreen = true;
          const tileToViewport = projectedAnchor.perspectiveRatio * textPixelRatio;
          const pixelsToTileUnits = 1 / (textPixelRatio * scale);
          let firstTileDistance = 0;
          let lastTileDistance = 0;
          if (firstAndLastGlyph) {
            firstTileDistance = this.approximateTileDistance(
              firstAndLastGlyph.first.tileDistance,
              firstAndLastGlyph.first.angle,
              pixelsToTileUnits,
              projectedAnchor.cameraDistance,
              pitchWithMap
            );
            lastTileDistance = this.approximateTileDistance(
              firstAndLastGlyph.last.tileDistance,
              firstAndLastGlyph.last.angle,
              pixelsToTileUnits,
              projectedAnchor.cameraDistance,
              pitchWithMap
            );
          }
          for (let k = 0; k < collisionCircles.length; k += 5) {
            const anchorPointX = collisionCircles[k];
            const anchorPointY = collisionCircles[k + 1];
            const tileUnitRadius = collisionCircles[k + 2];
            const boxSignedDistanceFromAnchor = collisionCircles[k + 3];
            if (!firstAndLastGlyph || boxSignedDistanceFromAnchor < -firstTileDistance || boxSignedDistanceFromAnchor > lastTileDistance) {
              markCollisionCircleUsed(collisionCircles, k, false);
              continue;
            }
            const projectedPoint = this.projectPoint(posMatrix, anchorPointX, anchorPointY);
            const radius = tileUnitRadius * tileToViewport;
            const atLeastOneCirclePlaced = placedCollisionCircles.length > 0;
            if (atLeastOneCirclePlaced) {
              const dx = projectedPoint.x - placedCollisionCircles[placedCollisionCircles.length - 4];
              const dy = projectedPoint.y - placedCollisionCircles[placedCollisionCircles.length - 3];
              const placedTooDensely = radius * radius * 2 > dx * dx + dy * dy;
              if (placedTooDensely) {
                const atLeastOneMoreCircle = k + 8 < collisionCircles.length;
                if (atLeastOneMoreCircle) {
                  const nextBoxDistanceToAnchor = collisionCircles[k + 8];
                  if (nextBoxDistanceToAnchor > -firstTileDistance && nextBoxDistanceToAnchor < lastTileDistance) {
                    markCollisionCircleUsed(collisionCircles, k, false);
                    continue;
                  }
                }
              }
            }
            const collisionBoxArrayIndex = k / 5;
            placedCollisionCircles.push(projectedPoint.x, projectedPoint.y, radius, collisionBoxArrayIndex);
            markCollisionCircleUsed(collisionCircles, k, true);
            const x1 = projectedPoint.x - radius;
            const y1 = projectedPoint.y - radius;
            const x2 = projectedPoint.x + radius;
            const y2 = projectedPoint.y + radius;
            entirelyOffscreen = entirelyOffscreen && this.isOffscreen(x1, y1, x2, y2);
            inGrid = inGrid || this.isInsideGrid(x1, y1, x2, y2);
            if (!allowOverlap) {
              if (this.grid.hitTestCircle(projectedPoint.x, projectedPoint.y, radius, collisionGroupPredicate)) {
                if (!showCollisionCircles) {
                  return {
                    circles: [],
                    offscreen: false
                  };
                }
                collisionDetected = true;
              }
            }
          }
          return {
            circles: collisionDetected || !inGrid ? [] : placedCollisionCircles,
            offscreen: entirelyOffscreen
          };
        }
        /**
         * Because the geometries in the CollisionIndex are an approximation of the shape of
         * symbols on the map, we use the CollisionIndex to look up the symbol part of
         * `queryRenderedFeatures`.
         *
         * @private
         */
        queryRenderedSymbols(viewportQueryGeometry) {
          if (viewportQueryGeometry.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) {
            return {};
          }
          const query = [];
          let minX = Number.POSITIVE_INFINITY;
          let minY = Number.POSITIVE_INFINITY;
          let maxX = Number.NEGATIVE_INFINITY;
          let maxY = Number.NEGATIVE_INFINITY;
          for (const point of viewportQueryGeometry) {
            const gridPoint = new Point3(point.x + viewportPadding, point.y + viewportPadding);
            minX = Math.min(minX, gridPoint.x);
            minY = Math.min(minY, gridPoint.y);
            maxX = Math.max(maxX, gridPoint.x);
            maxY = Math.max(maxY, gridPoint.y);
            query.push(gridPoint);
          }
          const features = this.grid.query(minX, minY, maxX, maxY).concat(this.ignoredGrid.query(minX, minY, maxX, maxY));
          const seenFeatures = {};
          const result = {};
          for (const feature of features) {
            const featureKey = feature.key;
            if (seenFeatures[featureKey.bucketInstanceId] === void 0) {
              seenFeatures[featureKey.bucketInstanceId] = {};
            }
            if (seenFeatures[featureKey.bucketInstanceId][featureKey.featureIndex]) {
              continue;
            }
            const bbox = [
              new Point3(feature.x1, feature.y1),
              new Point3(feature.x2, feature.y1),
              new Point3(feature.x2, feature.y2),
              new Point3(feature.x1, feature.y2)
            ];
            if (!intersectionTests.polygonIntersectsPolygon(query, bbox)) {
              continue;
            }
            seenFeatures[featureKey.bucketInstanceId][featureKey.featureIndex] = true;
            if (result[featureKey.bucketInstanceId] === void 0) {
              result[featureKey.bucketInstanceId] = [];
            }
            result[featureKey.bucketInstanceId].push(featureKey.featureIndex);
          }
          return result;
        }
        insertCollisionBox(collisionBox, ignorePlacement, bucketInstanceId, featureIndex, collisionGroupID) {
          const grid = ignorePlacement ? this.ignoredGrid : this.grid;
          const key = {
            bucketInstanceId,
            featureIndex,
            collisionGroupID
          };
          grid.insert(key, collisionBox[0], collisionBox[1], collisionBox[2], collisionBox[3]);
        }
        insertCollisionCircles(collisionCircles, ignorePlacement, bucketInstanceId, featureIndex, collisionGroupID) {
          const grid = ignorePlacement ? this.ignoredGrid : this.grid;
          const key = {
            bucketInstanceId,
            featureIndex,
            collisionGroupID
          };
          for (let k = 0; k < collisionCircles.length; k += 4) {
            grid.insertCircle(key, collisionCircles[k], collisionCircles[k + 1], collisionCircles[k + 2]);
          }
        }
        projectAnchor(posMatrix, x, y) {
          const p = [x, y, 0, 1];
          projection.xyTransformMat4(p, p, posMatrix);
          return {
            perspectiveRatio: 0.5 + 0.5 * (this.transform.cameraToCenterDistance / p[3]),
            cameraDistance: p[3]
          };
        }
        projectPoint(posMatrix, x, y) {
          const p = [x, y, 0, 1];
          projection.xyTransformMat4(p, p, posMatrix);
          return new Point3(
            (p[0] / p[3] + 1) / 2 * this.transform.width + viewportPadding,
            (-p[1] / p[3] + 1) / 2 * this.transform.height + viewportPadding
          );
        }
        projectAndGetPerspectiveRatio(posMatrix, x, y) {
          const p = [x, y, 0, 1];
          projection.xyTransformMat4(p, p, posMatrix);
          const a = new Point3(
            (p[0] / p[3] + 1) / 2 * this.transform.width + viewportPadding,
            (-p[1] / p[3] + 1) / 2 * this.transform.height + viewportPadding
          );
          return {
            point: a,
            // See perspective ratio comment in symbol_sdf.vertex
            // We're doing collision detection in viewport space so we need
            // to scale down boxes in the distance
            perspectiveRatio: 0.5 + 0.5 * (this.transform.cameraToCenterDistance / p[3])
          };
        }
        isOffscreen(x1, y1, x2, y2) {
          return x2 < viewportPadding || x1 >= this.screenRightBoundary || y2 < viewportPadding || y1 > this.screenBottomBoundary;
        }
        isInsideGrid(x1, y1, x2, y2) {
          return x2 >= 0 && x1 < this.gridRightBoundary && y2 >= 0 && y1 < this.gridBottomBoundary;
        }
      };
      function markCollisionCircleUsed(collisionCircles, index, used) {
        collisionCircles[index + 4] = used ? 1 : 0;
      }
      module.exports = CollisionIndex;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/source/pixels_to_tile_units.js
  var require_pixels_to_tile_units = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/source/pixels_to_tile_units.js"(exports, module) {
      var EXTENT = require_extent();
      module.exports = function(tile, pixelValue, z) {
        return pixelValue * (EXTENT / (tile.tileSize * 2 ** (z - tile.tileID.overscaledZ)));
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/symbol/placement.js
  var require_placement = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/symbol/placement.js"(exports, module) {
      var CollisionIndex = require_collision_index();
      var EXTENT = require_extent();
      var symbolSize = require_symbol_size();
      var projection = require_projection();
      var properties = require_symbol_style_layer_properties();
      var symbolLayoutProperties = properties.layout;
      var assert = require_nanoassert();
      var pixelsToTileUnits = require_pixels_to_tile_units();
      var OpacityState = class {
        constructor(prevState, increment, placed, skipFade) {
          if (prevState) {
            this.opacity = Math.max(0, Math.min(1, prevState.opacity + (prevState.placed ? increment : -increment)));
          } else {
            this.opacity = skipFade && placed ? 1 : 0;
          }
          this.placed = placed;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      };
      var JointOpacityState = class {
        constructor(prevState, increment, placedText, placedIcon, skipFade) {
          this.text = new OpacityState(prevState ? prevState.text : null, increment, placedText, skipFade);
          this.icon = new OpacityState(prevState ? prevState.icon : null, increment, placedIcon, skipFade);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      };
      var JointPlacement = class {
        // skipFade = outside viewport, but within CollisionIndex::viewportPadding px of the edge
        // Because these symbols aren't onscreen yet, we can skip the "fade in" animation,
        // and if a subsequent viewport change brings them into view, they'll be fully
        // visible right away.
        constructor(text, icon, skipFade) {
          this.text = text;
          this.icon = icon;
          this.skipFade = skipFade;
        }
      };
      var RetainedQueryData = class {
        constructor(bucketInstanceId, featureIndex, sourceLayerIndex, bucketIndex, tileID) {
          this.bucketInstanceId = bucketInstanceId;
          this.featureIndex = featureIndex;
          this.sourceLayerIndex = sourceLayerIndex;
          this.bucketIndex = bucketIndex;
          this.tileID = tileID;
        }
      };
      var CollisionGroups = class {
        constructor(crossSourceCollisions) {
          this.crossSourceCollisions = crossSourceCollisions;
          this.maxGroupID = 0;
          this.collisionGroups = {};
        }
        get(sourceID) {
          if (!this.crossSourceCollisions) {
            if (!this.collisionGroups[sourceID]) {
              const nextGroupID = ++this.maxGroupID;
              this.collisionGroups[sourceID] = {
                ID: nextGroupID,
                predicate: (key) => {
                  return key.collisionGroupID === nextGroupID;
                }
              };
            }
            return this.collisionGroups[sourceID];
          }
          return { ID: 0, predicate: null };
        }
      };
      var Placement = class {
        constructor(transform, fadeDuration, crossSourceCollisions) {
          this.transform = transform.clone();
          this.collisionIndex = new CollisionIndex(this.transform);
          this.placements = {};
          this.opacities = {};
          this.stale = false;
          this.fadeDuration = fadeDuration;
          this.retainedQueryData = {};
          this.collisionGroups = new CollisionGroups(crossSourceCollisions);
        }
        placeLayerTile(styleLayer, tile, showCollisionBoxes, seenCrossTileIDs) {
          const symbolBucket = tile.getBucket(styleLayer);
          const bucketFeatureIndex = tile.latestFeatureIndex;
          if (!symbolBucket || !bucketFeatureIndex || styleLayer.id !== symbolBucket.layerIds[0]) return;
          const collisionBoxArray = tile.collisionBoxArray;
          const layout = symbolBucket.layers[0].layout;
          const scale = 2 ** (this.transform.zoom - tile.tileID.overscaledZ);
          const textPixelRatio = tile.tileSize / EXTENT;
          const posMatrix = this.transform.calculatePosMatrix(tile.tileID.toUnwrapped());
          const textLabelPlaneMatrix = projection.getLabelPlaneMatrix(
            posMatrix,
            layout.get("text-pitch-alignment") === "map",
            layout.get("text-rotation-alignment") === "map",
            this.transform,
            pixelsToTileUnits(tile, 1, this.transform.zoom)
          );
          const iconLabelPlaneMatrix = projection.getLabelPlaneMatrix(
            posMatrix,
            layout.get("icon-pitch-alignment") === "map",
            layout.get("icon-rotation-alignment") === "map",
            this.transform,
            pixelsToTileUnits(tile, 1, this.transform.zoom)
          );
          this.retainedQueryData[symbolBucket.bucketInstanceId] = new RetainedQueryData(
            symbolBucket.bucketInstanceId,
            bucketFeatureIndex,
            symbolBucket.sourceLayerIndex,
            symbolBucket.index,
            tile.tileID
          );
          this.placeLayerBucket(
            symbolBucket,
            posMatrix,
            textLabelPlaneMatrix,
            iconLabelPlaneMatrix,
            scale,
            textPixelRatio,
            showCollisionBoxes,
            tile.holdingForFade(),
            seenCrossTileIDs,
            collisionBoxArray
          );
        }
        placeLayerBucket(bucket, posMatrix, textLabelPlaneMatrix, iconLabelPlaneMatrix, scale, textPixelRatio, showCollisionBoxes, holdingForFade, seenCrossTileIDs, collisionBoxArray) {
          const layout = bucket.layers[0].layout;
          const partiallyEvaluatedTextSize = symbolSize.evaluateSizeForZoom(
            bucket.textSizeData,
            this.transform.zoom,
            symbolLayoutProperties.properties["text-size"]
          );
          const textOptional = layout.get("text-optional");
          const iconOptional = layout.get("icon-optional");
          const textAllowOverlap = layout.get("text-allow-overlap");
          const iconAllowOverlap = layout.get("icon-allow-overlap");
          const alwaysShowText = textAllowOverlap && (iconAllowOverlap || !bucket.hasIconData() || iconOptional);
          const alwaysShowIcon = iconAllowOverlap && (textAllowOverlap || !bucket.hasTextData() || textOptional);
          const collisionGroup = this.collisionGroups.get(bucket.sourceID);
          if (!bucket.collisionArrays && collisionBoxArray) {
            bucket.deserializeCollisionBoxes(collisionBoxArray);
          }
          for (let i = 0; i < bucket.symbolInstances.length; i++) {
            const symbolInstance = bucket.symbolInstances.get(i);
            if (!seenCrossTileIDs[symbolInstance.crossTileID]) {
              if (holdingForFade) {
                this.placements[symbolInstance.crossTileID] = new JointPlacement(false, false, false);
                continue;
              }
              let placeText = false;
              let placeIcon = false;
              let offscreen = true;
              let placedGlyphBoxes = null;
              let placedGlyphCircles = null;
              let placedIconBoxes = null;
              let textFeatureIndex = 0;
              let iconFeatureIndex = 0;
              const collisionArrays = bucket.collisionArrays[i];
              if (collisionArrays.textFeatureIndex) {
                textFeatureIndex = collisionArrays.textFeatureIndex;
              }
              if (collisionArrays.textBox) {
                placedGlyphBoxes = this.collisionIndex.placeCollisionBox(
                  collisionArrays.textBox,
                  layout.get("text-allow-overlap"),
                  textPixelRatio,
                  posMatrix,
                  collisionGroup.predicate
                );
                placeText = placedGlyphBoxes.box.length > 0;
                offscreen = offscreen && placedGlyphBoxes.offscreen;
              }
              const textCircles = collisionArrays.textCircles;
              if (textCircles) {
                const placedSymbol = bucket.text.placedSymbolArray.get(symbolInstance.horizontalPlacedTextSymbolIndex);
                const fontSize = symbolSize.evaluateSizeForFeature(
                  bucket.textSizeData,
                  partiallyEvaluatedTextSize,
                  placedSymbol
                );
                placedGlyphCircles = this.collisionIndex.placeCollisionCircles(
                  textCircles,
                  layout.get("text-allow-overlap"),
                  scale,
                  textPixelRatio,
                  placedSymbol,
                  bucket.lineVertexArray,
                  bucket.glyphOffsetArray,
                  fontSize,
                  posMatrix,
                  textLabelPlaneMatrix,
                  showCollisionBoxes,
                  layout.get("text-pitch-alignment") === "map",
                  collisionGroup.predicate
                );
                placeText = layout.get("text-allow-overlap") || placedGlyphCircles.circles.length > 0;
                offscreen = offscreen && placedGlyphCircles.offscreen;
              }
              if (collisionArrays.iconFeatureIndex) {
                iconFeatureIndex = collisionArrays.iconFeatureIndex;
              }
              if (collisionArrays.iconBox) {
                placedIconBoxes = this.collisionIndex.placeCollisionBox(
                  collisionArrays.iconBox,
                  layout.get("icon-allow-overlap"),
                  textPixelRatio,
                  posMatrix,
                  collisionGroup.predicate
                );
                placeIcon = placedIconBoxes.box.length > 0;
                offscreen = offscreen && placedIconBoxes.offscreen;
              }
              const iconWithoutText = textOptional || symbolInstance.numGlyphVertices === 0 && symbolInstance.numVerticalGlyphVertices === 0;
              const textWithoutIcon = iconOptional || symbolInstance.numIconVertices === 0;
              if (!iconWithoutText && !textWithoutIcon) {
                placeIcon = placeText = placeIcon && placeText;
              } else if (!textWithoutIcon) {
                placeText = placeIcon && placeText;
              } else if (!iconWithoutText) {
                placeIcon = placeIcon && placeText;
              }
              if (placeText && placedGlyphBoxes) {
                this.collisionIndex.insertCollisionBox(
                  placedGlyphBoxes.box,
                  layout.get("text-ignore-placement"),
                  bucket.bucketInstanceId,
                  textFeatureIndex,
                  collisionGroup.ID
                );
              }
              if (placeIcon && placedIconBoxes) {
                this.collisionIndex.insertCollisionBox(
                  placedIconBoxes.box,
                  layout.get("icon-ignore-placement"),
                  bucket.bucketInstanceId,
                  iconFeatureIndex,
                  collisionGroup.ID
                );
              }
              if (placeText && placedGlyphCircles) {
                this.collisionIndex.insertCollisionCircles(
                  placedGlyphCircles.circles,
                  layout.get("text-ignore-placement"),
                  bucket.bucketInstanceId,
                  textFeatureIndex,
                  collisionGroup.ID
                );
              }
              assert(symbolInstance.crossTileID !== 0);
              assert(bucket.bucketInstanceId !== 0);
              this.placements[symbolInstance.crossTileID] = new JointPlacement(
                placeText || alwaysShowText && placedGlyphBoxes,
                placeIcon || alwaysShowIcon,
                offscreen || bucket.justReloaded
              );
              seenCrossTileIDs[symbolInstance.crossTileID] = true;
            }
          }
          bucket.justReloaded = false;
        }
        commit(prevPlacement, now) {
          this.commitTime = now;
          let placementChanged = false;
          const increment = prevPlacement && this.fadeDuration !== 0 ? (this.commitTime - prevPlacement.commitTime) / this.fadeDuration : 1;
          const prevOpacities = prevPlacement ? prevPlacement.opacities : {};
          for (const crossTileID in this.placements) {
            const jointPlacement = this.placements[crossTileID];
            const prevOpacity = prevOpacities[crossTileID];
            if (prevOpacity) {
              this.opacities[crossTileID] = new JointOpacityState(
                prevOpacity,
                increment,
                jointPlacement.text,
                jointPlacement.icon
              );
              placementChanged = placementChanged || jointPlacement.text !== prevOpacity.text.placed || jointPlacement.icon !== prevOpacity.icon.placed;
            } else {
              this.opacities[crossTileID] = new JointOpacityState(
                null,
                increment,
                jointPlacement.text,
                jointPlacement.icon,
                jointPlacement.skipFade
              );
              placementChanged = placementChanged || jointPlacement.text || jointPlacement.icon;
            }
          }
          for (const crossTileID in prevOpacities) {
            const prevOpacity = prevOpacities[crossTileID];
            if (!this.opacities[crossTileID]) {
              const jointOpacity = new JointOpacityState(prevOpacity, increment, false, false);
              if (!jointOpacity.isHidden()) {
                this.opacities[crossTileID] = jointOpacity;
                placementChanged = placementChanged || prevOpacity.text.placed || prevOpacity.icon.placed;
              }
            }
          }
          assert(!prevPlacement || prevPlacement.lastPlacementChangeTime !== void 0);
          if (placementChanged) {
            this.lastPlacementChangeTime = now;
          } else if (typeof this.lastPlacementChangeTime !== "number") {
            this.lastPlacementChangeTime = prevPlacement ? prevPlacement.lastPlacementChangeTime : now;
          }
        }
        updateLayerOpacities(styleLayer, tiles) {
          const seenCrossTileIDs = {};
          for (const tile of tiles) {
            const symbolBucket = tile.getBucket(styleLayer);
            if (symbolBucket && tile.latestFeatureIndex && styleLayer.id === symbolBucket.layerIds[0]) {
              this.updateBucketOpacities(symbolBucket, seenCrossTileIDs, tile.collisionBoxArray);
            }
          }
        }
        updateBucketOpacities(bucket, seenCrossTileIDs, collisionBoxArray) {
          if (bucket.hasTextData()) bucket.text.opacityVertexArray.clear();
          if (bucket.hasIconData()) bucket.icon.opacityVertexArray.clear();
          if (bucket.hasCollisionBoxData()) bucket.collisionBox.collisionVertexArray.clear();
          if (bucket.hasCollisionCircleData()) bucket.collisionCircle.collisionVertexArray.clear();
          const layout = bucket.layers[0].layout;
          const duplicateOpacityState = new JointOpacityState(null, 0, false, false, true);
          const textAllowOverlap = layout.get("text-allow-overlap");
          const iconAllowOverlap = layout.get("icon-allow-overlap");
          const defaultOpacityState = new JointOpacityState(
            null,
            0,
            textAllowOverlap && (iconAllowOverlap || !bucket.hasIconData() || layout.get("icon-optional")),
            iconAllowOverlap && (textAllowOverlap || !bucket.hasTextData() || layout.get("text-optional")),
            true
          );
          if (!bucket.collisionArrays && collisionBoxArray && (bucket.hasCollisionBoxData() || bucket.hasCollisionCircleData())) {
            bucket.deserializeCollisionBoxes(collisionBoxArray);
          }
          for (let s = 0; s < bucket.symbolInstances.length; s++) {
            const symbolInstance = bucket.symbolInstances.get(s);
            const isDuplicate = seenCrossTileIDs[symbolInstance.crossTileID];
            let opacityState = this.opacities[symbolInstance.crossTileID];
            if (isDuplicate) {
              opacityState = duplicateOpacityState;
            } else if (!opacityState) {
              opacityState = defaultOpacityState;
              this.opacities[symbolInstance.crossTileID] = opacityState;
            }
            seenCrossTileIDs[symbolInstance.crossTileID] = true;
            const hasText = symbolInstance.numGlyphVertices > 0 || symbolInstance.numVerticalGlyphVertices > 0;
            const hasIcon = symbolInstance.numIconVertices > 0;
            if (hasText) {
              const packedOpacity = packOpacity(opacityState.text);
              const opacityEntryCount = (symbolInstance.numGlyphVertices + symbolInstance.numVerticalGlyphVertices) / 4;
              for (let i = 0; i < opacityEntryCount; i++) {
                bucket.text.opacityVertexArray.emplaceBack(packedOpacity);
              }
              bucket.text.placedSymbolArray.get(symbolInstance.horizontalPlacedTextSymbolIndex).hidden = opacityState.text.isHidden();
              if (symbolInstance.verticalPlacedTextSymbolIndex >= 0) {
                bucket.text.placedSymbolArray.get(symbolInstance.verticalPlacedTextSymbolIndex).hidden = opacityState.text.isHidden();
              }
            }
            if (hasIcon) {
              const packedOpacity = packOpacity(opacityState.icon);
              for (let i = 0; i < symbolInstance.numIconVertices / 4; i++) {
                bucket.icon.opacityVertexArray.emplaceBack(packedOpacity);
              }
              bucket.icon.placedSymbolArray.get(s).hidden = opacityState.icon.isHidden();
            }
            if (bucket.hasCollisionBoxData() || bucket.hasCollisionCircleData()) {
              const collisionArrays = bucket.collisionArrays[s];
              if (collisionArrays) {
                if (collisionArrays.textBox) {
                  updateCollisionVertices(bucket.collisionBox.collisionVertexArray, opacityState.text.placed, false);
                }
                if (collisionArrays.iconBox) {
                  updateCollisionVertices(bucket.collisionBox.collisionVertexArray, opacityState.icon.placed, false);
                }
                const textCircles = collisionArrays.textCircles;
                if (textCircles && bucket.hasCollisionCircleData()) {
                  for (let k = 0; k < textCircles.length; k += 5) {
                    const notUsed = isDuplicate || textCircles[k + 4] === 0;
                    updateCollisionVertices(bucket.collisionCircle.collisionVertexArray, opacityState.text.placed, notUsed);
                  }
                }
              }
            }
          }
          bucket.sortFeatures(this.transform.angle);
          if (this.retainedQueryData[bucket.bucketInstanceId]) {
            this.retainedQueryData[bucket.bucketInstanceId].featureSortOrder = bucket.featureSortOrder;
          }
          if (bucket.hasTextData() && bucket.text.opacityVertexBuffer) {
            bucket.text.opacityVertexBuffer.updateData(bucket.text.opacityVertexArray);
          }
          if (bucket.hasIconData() && bucket.icon.opacityVertexBuffer) {
            bucket.icon.opacityVertexBuffer.updateData(bucket.icon.opacityVertexArray);
          }
          if (bucket.hasCollisionBoxData() && bucket.collisionBox.collisionVertexBuffer) {
            bucket.collisionBox.collisionVertexBuffer.updateData(bucket.collisionBox.collisionVertexArray);
          }
          if (bucket.hasCollisionCircleData() && bucket.collisionCircle.collisionVertexBuffer) {
            bucket.collisionCircle.collisionVertexBuffer.updateData(bucket.collisionCircle.collisionVertexArray);
          }
          assert(bucket.text.opacityVertexArray.length === bucket.text.layoutVertexArray.length / 4);
          assert(bucket.icon.opacityVertexArray.length === bucket.icon.layoutVertexArray.length / 4);
        }
        symbolFadeChange(now) {
          return this.fadeDuration === 0 ? 1 : (now - this.commitTime) / this.fadeDuration;
        }
        hasTransitions(now) {
          return this.stale || now - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(now) {
          return this.commitTime !== "undefined" && this.commitTime + this.fadeDuration > now;
        }
        setStale() {
          this.stale = true;
        }
      };
      function updateCollisionVertices(collisionVertexArray, placed, notUsed) {
        collisionVertexArray.emplaceBack(placed ? 1 : 0, notUsed ? 1 : 0);
        collisionVertexArray.emplaceBack(placed ? 1 : 0, notUsed ? 1 : 0);
        collisionVertexArray.emplaceBack(placed ? 1 : 0, notUsed ? 1 : 0);
        collisionVertexArray.emplaceBack(placed ? 1 : 0, notUsed ? 1 : 0);
      }
      var shift25 = 2 ** 25;
      var shift24 = 2 ** 24;
      var shift17 = 2 ** 17;
      var shift16 = 2 ** 16;
      var shift9 = 2 ** 9;
      var shift8 = 2 ** 8;
      var shift1 = 2 ** 1;
      function packOpacity(opacityState) {
        if (opacityState.opacity === 0 && !opacityState.placed) {
          return 0;
        }
        if (opacityState.opacity === 1 && opacityState.placed) {
          return 4294967295;
        }
        const targetBit = opacityState.placed ? 1 : 0;
        const opacityBits = Math.floor(opacityState.opacity * 127);
        return opacityBits * shift25 + targetBit * shift24 + opacityBits * shift17 + targetBit * shift16 + opacityBits * shift9 + targetBit * shift8 + opacityBits * shift1 + targetBit;
      }
      module.exports = {
        RetainedQueryData,
        Placement
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/pauseable_placement.js
  var require_pauseable_placement = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/pauseable_placement.js"(exports, module) {
      var browser = require_browser();
      var { Placement } = require_placement();
      var LayerPlacement = class {
        constructor() {
          this._currentTileIndex = 0;
          this._seenCrossTileIDs = {};
        }
        continuePlacement(tiles, placement, showCollisionBoxes, styleLayer, shouldPausePlacement) {
          while (this._currentTileIndex < tiles.length) {
            const tile = tiles[this._currentTileIndex];
            placement.placeLayerTile(styleLayer, tile, showCollisionBoxes, this._seenCrossTileIDs);
            this._currentTileIndex++;
            if (shouldPausePlacement()) {
              return true;
            }
          }
        }
      };
      var PauseablePlacement = class {
        constructor(transform, order, forceFullPlacement, showCollisionBoxes, fadeDuration, crossSourceCollisions) {
          this.placement = new Placement(transform, fadeDuration, crossSourceCollisions);
          this._currentPlacementIndex = order.length - 1;
          this._forceFullPlacement = forceFullPlacement;
          this._showCollisionBoxes = showCollisionBoxes;
          this._done = false;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(order, layers, layerTiles) {
          const startTime = browser.now();
          const shouldPausePlacement = () => {
            const elapsedTime = browser.now() - startTime;
            return this._forceFullPlacement ? false : elapsedTime > 2;
          };
          while (this._currentPlacementIndex >= 0) {
            const layerId = order[this._currentPlacementIndex];
            const layer = layers[layerId];
            const placementZoom = this.placement.collisionIndex.transform.zoom;
            if (layer.type === "symbol" && (!layer.minzoom || layer.minzoom <= placementZoom) && (!layer.maxzoom || layer.maxzoom > placementZoom)) {
              if (!this._inProgressLayer) {
                this._inProgressLayer = new LayerPlacement();
              }
              const pausePlacement = this._inProgressLayer.continuePlacement(
                layerTiles[layer.source],
                this.placement,
                this._showCollisionBoxes,
                layer,
                shouldPausePlacement
              );
              if (pausePlacement) {
                return;
              }
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }
        commit(previousPlacement, now) {
          this.placement.commit(previousPlacement, now);
          return this.placement;
        }
      };
      module.exports = PauseablePlacement;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/symbol/cross_tile_symbol_index.js
  var require_cross_tile_symbol_index = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/symbol/cross_tile_symbol_index.js"(exports, module) {
      var EXTENT = require_extent();
      var { SymbolInstanceArray } = require_array_types();
      var roundingFactor = 512 / EXTENT / 2;
      var TileLayerIndex = class {
        constructor(tileID, symbolInstances, bucketInstanceId) {
          this.tileID = tileID;
          this.indexedSymbolInstances = {};
          this.bucketInstanceId = bucketInstanceId;
          for (let i = 0; i < symbolInstances.length; i++) {
            const symbolInstance = symbolInstances.get(i);
            const key = symbolInstance.key;
            if (!this.indexedSymbolInstances[key]) {
              this.indexedSymbolInstances[key] = [];
            }
            this.indexedSymbolInstances[key].push({
              crossTileID: symbolInstance.crossTileID,
              coord: this.getScaledCoordinates(symbolInstance, tileID)
            });
          }
        }
        // Converts the coordinates of the input symbol instance into coordinates that be can compared
        // against other symbols in this index. Coordinates are:
        // (1) world-based (so after conversion the source tile is irrelevant)
        // (2) converted to the z-scale of this TileLayerIndex
        // (3) down-sampled by "roundingFactor" from tile coordinate precision in order to be
        //     more tolerant of small differences between tiles.
        getScaledCoordinates(symbolInstance, childTileID) {
          const zDifference = childTileID.canonical.z - this.tileID.canonical.z;
          const scale = roundingFactor / 2 ** zDifference;
          return {
            x: Math.floor((childTileID.canonical.x * EXTENT + symbolInstance.anchorX) * scale),
            y: Math.floor((childTileID.canonical.y * EXTENT + symbolInstance.anchorY) * scale)
          };
        }
        findMatches(symbolInstances, newTileID, zoomCrossTileIDs) {
          const tolerance = this.tileID.canonical.z < newTileID.canonical.z ? 1 : 2 ** (this.tileID.canonical.z - newTileID.canonical.z);
          for (let i = 0; i < symbolInstances.length; i++) {
            const symbolInstance = symbolInstances.get(i);
            if (symbolInstance.crossTileID) {
              continue;
            }
            const indexedInstances = this.indexedSymbolInstances[symbolInstance.key];
            if (!indexedInstances) {
              continue;
            }
            const scaledSymbolCoord = this.getScaledCoordinates(symbolInstance, newTileID);
            for (const thisTileSymbol of indexedInstances) {
              if (Math.abs(thisTileSymbol.coord.x - scaledSymbolCoord.x) <= tolerance && Math.abs(thisTileSymbol.coord.y - scaledSymbolCoord.y) <= tolerance && !zoomCrossTileIDs[thisTileSymbol.crossTileID]) {
                zoomCrossTileIDs[thisTileSymbol.crossTileID] = true;
                symbolInstance.crossTileID = thisTileSymbol.crossTileID;
                break;
              }
            }
          }
        }
      };
      var CrossTileIDs = class {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      };
      var CrossTileSymbolLayerIndex = class {
        constructor() {
          this.indexes = {};
          this.usedCrossTileIDs = {};
          this.lng = 0;
        }
        /*
         * Sometimes when a user pans across the antimeridian the longitude value gets wrapped.
         * To prevent labels from flashing out and in we adjust the tileID values in the indexes
         * so that they match the new wrapped version of the map.
         */
        handleWrapJump(lng) {
          const wrapDelta = Math.round((lng - this.lng) / 360);
          if (wrapDelta !== 0) {
            for (const zoom in this.indexes) {
              const zoomIndexes = this.indexes[zoom];
              const newZoomIndex = {};
              for (const key in zoomIndexes) {
                const index = zoomIndexes[key];
                index.tileID = index.tileID.unwrapTo(index.tileID.wrap + wrapDelta);
                newZoomIndex[index.tileID.key] = index;
              }
              this.indexes[zoom] = newZoomIndex;
            }
          }
          this.lng = lng;
        }
        addBucket(tileID, bucket, crossTileIDs) {
          if (this.indexes[tileID.overscaledZ] && this.indexes[tileID.overscaledZ][tileID.key]) {
            if (this.indexes[tileID.overscaledZ][tileID.key].bucketInstanceId === bucket.bucketInstanceId) {
              return false;
            }
            this.removeBucketCrossTileIDs(tileID.overscaledZ, this.indexes[tileID.overscaledZ][tileID.key]);
          }
          for (let i = 0; i < bucket.symbolInstances.length; i++) {
            const symbolInstance = bucket.symbolInstances.get(i);
            symbolInstance.crossTileID = 0;
          }
          if (!this.usedCrossTileIDs[tileID.overscaledZ]) {
            this.usedCrossTileIDs[tileID.overscaledZ] = {};
          }
          const zoomCrossTileIDs = this.usedCrossTileIDs[tileID.overscaledZ];
          for (const zoom in this.indexes) {
            const zoomIndexes = this.indexes[zoom];
            if (Number(zoom) > tileID.overscaledZ) {
              for (const id in zoomIndexes) {
                const childIndex = zoomIndexes[id];
                if (childIndex.tileID.isChildOf(tileID)) {
                  childIndex.findMatches(bucket.symbolInstances, tileID, zoomCrossTileIDs);
                }
              }
            } else {
              const parentCoord = tileID.scaledTo(Number(zoom));
              const parentIndex = zoomIndexes[parentCoord.key];
              if (parentIndex) {
                parentIndex.findMatches(bucket.symbolInstances, tileID, zoomCrossTileIDs);
              }
            }
          }
          for (let i = 0; i < bucket.symbolInstances.length; i++) {
            const symbolInstance = bucket.symbolInstances.get(i);
            if (!symbolInstance.crossTileID) {
              symbolInstance.crossTileID = crossTileIDs.generate();
              zoomCrossTileIDs[symbolInstance.crossTileID] = true;
            }
          }
          if (this.indexes[tileID.overscaledZ] === void 0) {
            this.indexes[tileID.overscaledZ] = {};
          }
          this.indexes[tileID.overscaledZ][tileID.key] = new TileLayerIndex(
            tileID,
            bucket.symbolInstances,
            bucket.bucketInstanceId
          );
          return true;
        }
        removeBucketCrossTileIDs(zoom, removedBucket) {
          for (const key in removedBucket.indexedSymbolInstances) {
            for (const symbolInstance of removedBucket.indexedSymbolInstances[key]) {
              delete this.usedCrossTileIDs[zoom][symbolInstance.crossTileID];
            }
          }
        }
        removeStaleBuckets(currentIDs) {
          let tilesChanged = false;
          for (const z in this.indexes) {
            const zoomIndexes = this.indexes[z];
            for (const tileKey in zoomIndexes) {
              if (!currentIDs[zoomIndexes[tileKey].bucketInstanceId]) {
                this.removeBucketCrossTileIDs(z, zoomIndexes[tileKey]);
                delete zoomIndexes[tileKey];
                tilesChanged = true;
              }
            }
          }
          return tilesChanged;
        }
      };
      var CrossTileSymbolIndex = class {
        constructor() {
          this.layerIndexes = {};
          this.crossTileIDs = new CrossTileIDs();
          this.maxBucketInstanceId = 0;
          this.bucketsInCurrentPlacement = {};
        }
        addLayer(styleLayer, tiles, lng) {
          let layerIndex = this.layerIndexes[styleLayer.id];
          if (layerIndex === void 0) {
            layerIndex = this.layerIndexes[styleLayer.id] = new CrossTileSymbolLayerIndex();
          }
          let symbolBucketsChanged = false;
          const currentBucketIDs = {};
          layerIndex.handleWrapJump(lng);
          for (const tile of tiles) {
            const symbolBucket = tile.getBucket(styleLayer);
            if (!symbolBucket || styleLayer.id !== symbolBucket.layerIds[0]) continue;
            if (!symbolBucket.bucketInstanceId) {
              symbolBucket.bucketInstanceId = ++this.maxBucketInstanceId;
            }
            if (layerIndex.addBucket(tile.tileID, symbolBucket, this.crossTileIDs)) {
              symbolBucketsChanged = true;
            }
            currentBucketIDs[symbolBucket.bucketInstanceId] = true;
          }
          if (layerIndex.removeStaleBuckets(currentBucketIDs)) {
            symbolBucketsChanged = true;
          }
          return symbolBucketsChanged;
        }
        pruneUnusedLayers(usedLayers) {
          const usedLayerMap = {};
          usedLayers.forEach((usedLayer) => {
            usedLayerMap[usedLayer] = true;
          });
          for (const layerId in this.layerIndexes) {
            if (!usedLayerMap[layerId]) {
              delete this.layerIndexes[layerId];
            }
          }
        }
      };
      module.exports = CrossTileSymbolIndex;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/style/style.js
  var require_style = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/style/style.js"(exports, module) {
      var assert = require_nanoassert();
      var { Event: Event3, ErrorEvent: ErrorEvent3, Evented: Evented3 } = (init_events(), __toCommonJS(events_exports));
      var createStyleLayer = require_create_style_layer();
      var loadSprite = require_load_sprite();
      var ImageManager = require_image_manager();
      var GlyphManager = require_glyph_manager();
      var Light = require_light();
      var LineAtlas = require_line_atlas();
      var { clone, deepEqual, filterObject, mapObject } = require_object();
      var browser = require_browser();
      var dispatcher = require_dispatcher();
      var { getType: getSourceType, setType: setSourceType } = require_source();
      var { queryRenderedFeatures, queryRenderedSymbols, querySourceFeatures } = require_query_features();
      var SourceCache = require_source_cache();
      var getWorkerPool = require_global_worker_pool();
      var deref = require_deref();
      var { registerForPluginAvailability, evented: rtlTextPluginEvented } = require_rtl_text_plugin();
      var PauseablePlacement = require_pauseable_placement();
      var ZoomHistory = require_zoom_history();
      var CrossTileSymbolIndex = require_cross_tile_symbol_index();
      var Style = class _Style extends Evented3 {
        // exposed to allow stubbing by unit tests
        constructor(map, options = {}) {
          super();
          this.map = map;
          this.dispatcher = dispatcher(getWorkerPool(), this);
          this.imageManager = new ImageManager();
          this.glyphManager = new GlyphManager();
          this.lineAtlas = new LineAtlas(256, 512);
          this.crossTileSymbolIndex = new CrossTileSymbolIndex();
          this._layers = {};
          this._order = [];
          this.sourceCaches = {};
          this.zoomHistory = new ZoomHistory();
          this._loaded = false;
          this._resetUpdates();
          const self2 = this;
          this._rtlTextPluginCallback = _Style.registerForPluginAvailability((args) => {
            self2.dispatcher.broadcast("loadRTLTextPlugin", args.pluginURL).then((_) => args.completionCallback(), args.completionCallback);
            for (const id in self2.sourceCaches) {
              self2.sourceCaches[id].reload();
            }
          });
          this.on("data", (event) => {
            if (event.dataType !== "source" || event.sourceDataType !== "metadata") {
              return;
            }
            const sourceCache = this.sourceCaches[event.sourceId];
            if (!sourceCache) {
              return;
            }
            const source = sourceCache.getSource();
            if (!source || !source.vectorLayerIds) {
              return;
            }
            for (const layerId in this._layers) {
              const layer = this._layers[layerId];
              if (layer.source === source.id) {
                this._validateLayer(layer);
              }
            }
          });
        }
        loadJSON(json) {
          this.fire(new Event3("dataloading", { dataType: "style" }));
          browser.frame(() => {
            this._load(json);
          });
        }
        _load(json) {
          this._loaded = true;
          this.stylesheet = json;
          for (const id in json.sources) {
            this.addSource(id, json.sources[id]);
          }
          if (json.sprite) {
            loadSprite(json.sprite).then((images) => {
              if (images) {
                for (const id in images) {
                  this.imageManager.addImage(id, images[id]);
                }
              }
              this.imageManager.setLoaded();
              this.fire(new Event3("data", { dataType: "style" }));
            }).catch((err) => this.fire(new ErrorEvent3(err)));
          } else {
            this.imageManager.setLoaded();
          }
          this.glyphManager.setGlyphsLoader(json.glyphs);
          const layers = deref(this.stylesheet.layers);
          this._order = layers.map((layer) => layer.id);
          this._layers = {};
          for (let layer of layers) {
            layer = createStyleLayer(layer);
            layer.setEventedParent(this, { layer: { id: layer.id } });
            this._layers[layer.id] = layer;
          }
          this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order));
          this.light = new Light(this.stylesheet.light);
          this.fire(new Event3("data", { dataType: "style" }));
          this.fire(new Event3("style.load"));
        }
        _validateLayer(layer) {
          const sourceCache = this.sourceCaches[layer.source];
          if (!sourceCache) {
            return;
          }
          const sourceLayer = layer.sourceLayer;
          if (!sourceLayer) {
            return;
          }
          const source = sourceCache.getSource();
          if (source.type === "geojson" || source.vectorLayerIds && source.vectorLayerIds.indexOf(sourceLayer) === -1) {
            this.fire(
              new ErrorEvent3(
                new Error(
                  `Source layer "${sourceLayer}" does not exist on source "${source.id}" as specified by style layer "${layer.id}"`
                )
              )
            );
          }
        }
        loaded() {
          if (!this._loaded) return false;
          if (Object.keys(this._updatedSources).length) return false;
          for (const id in this.sourceCaches) if (!this.sourceCaches[id].loaded()) return false;
          if (!this.imageManager.isLoaded()) return false;
          return true;
        }
        _serializeLayers(ids) {
          return ids.map((id) => this._layers[id].serialize());
        }
        hasTransitions() {
          if (this.light?.hasTransition()) {
            return true;
          }
          for (const id in this.sourceCaches) {
            if (this.sourceCaches[id].hasTransition()) {
              return true;
            }
          }
          for (const id in this._layers) {
            if (this._layers[id].hasTransition()) {
              return true;
            }
          }
          return false;
        }
        _checkLoaded() {
          if (!this._loaded) {
            throw new Error("Style is not done loading");
          }
        }
        /**
         * Apply queued style updates in a batch and recalculate zoom-dependent paint properties.
         */
        update(parameters) {
          if (!this._loaded) {
            return;
          }
          if (this._changed) {
            const updatedIds = Object.keys(this._updatedLayers);
            const removedIds = Object.keys(this._removedLayers);
            if (updatedIds.length || removedIds.length) {
              this._updateWorkerLayers(updatedIds, removedIds);
            }
            for (const id in this._updatedSources) {
              const action = this._updatedSources[id];
              assert(action === "reload" || action === "clear");
              if (action === "reload") {
                this._reloadSource(id);
              } else if (action === "clear") {
                this._clearSource(id);
              }
            }
            for (const id in this._updatedPaintProps) {
              this._layers[id].updateTransitions(parameters);
            }
            this.light.updateTransitions(parameters);
            this._resetUpdates();
            this.fire(new Event3("data", { dataType: "style" }));
          }
          for (const sourceId in this.sourceCaches) {
            this.sourceCaches[sourceId].used = false;
          }
          for (const layerId of this._order) {
            const layer = this._layers[layerId];
            layer.recalculate(parameters);
            if (!layer.isHidden(parameters.zoom) && layer.source) {
              this.sourceCaches[layer.source].used = true;
            }
          }
          this.light.recalculate(parameters);
          this.z = parameters.zoom;
        }
        _updateWorkerLayers(updatedIds, removedIds) {
          this.dispatcher.broadcast("updateLayers", {
            layers: this._serializeLayers(updatedIds),
            removedIds
          });
        }
        _resetUpdates() {
          this._changed = false;
          this._updatedLayers = {};
          this._removedLayers = {};
          this._updatedSources = {};
          this._updatedPaintProps = {};
        }
        addImage(id, image) {
          if (this.getImage(id)) {
            return this.fire(new ErrorEvent3(new Error("An image with this name already exists.")));
          }
          this.imageManager.addImage(id, image);
          this.fire(new Event3("data", { dataType: "style" }));
        }
        getImage(id) {
          return this.imageManager.getImage(id);
        }
        removeImage(id) {
          if (!this.getImage(id)) {
            return this.fire(new ErrorEvent3(new Error("No image with this name exists.")));
          }
          this.imageManager.removeImage(id);
          this.fire(new Event3("data", { dataType: "style" }));
        }
        listImages() {
          this._checkLoaded();
          return this.imageManager.listImages();
        }
        addSource(id, source) {
          this._checkLoaded();
          if (this.sourceCaches[id] !== void 0) {
            throw new Error("There is already a source with this ID");
          }
          if (!source.type) {
            throw new Error(
              `The type property must be defined, but the only the following properties were given: ${Object.keys(source).join(", ")}.`
            );
          }
          const sourceCache = this.sourceCaches[id] = new SourceCache(id, source, this.dispatcher);
          sourceCache.style = this;
          sourceCache.setEventedParent(this, () => ({
            isSourceLoaded: this.loaded(),
            source: sourceCache.serialize(),
            sourceId: id
          }));
          sourceCache.onAdd(this.map);
          this._changed = true;
        }
        /**
         * Remove a source from this stylesheet, given its id.
         * @param {string} id id of the source to remove
         * @throws {Error} if no source is found with the given ID
         */
        removeSource(id) {
          this._checkLoaded();
          if (this.sourceCaches[id] === void 0) {
            throw new Error("There is no source with this ID");
          }
          for (const layerId in this._layers) {
            if (this._layers[layerId].source === id) {
              return this.fire(
                new ErrorEvent3(new Error(`Source "${id}" cannot be removed while layer "${layerId}" is using it.`))
              );
            }
          }
          const sourceCache = this.sourceCaches[id];
          delete this.sourceCaches[id];
          delete this._updatedSources[id];
          sourceCache.fire(new Event3("data", { sourceDataType: "metadata", dataType: "source", sourceId: id }));
          sourceCache.setEventedParent(null);
          sourceCache.clearTiles();
          if (sourceCache.onRemove) sourceCache.onRemove(this.map);
          this._changed = true;
        }
        /**
         * Set the data of a GeoJSON source, given its id.
         * @param {string} id id of the source
         * @param {GeoJSON|string} data GeoJSON source
         */
        setGeoJSONSourceData(id, data) {
          this._checkLoaded();
          assert(this.sourceCaches[id] !== void 0, "There is no source with this ID");
          const geojsonSource = this.sourceCaches[id].getSource();
          assert(geojsonSource.type === "geojson");
          geojsonSource.setData(data);
          this._changed = true;
        }
        /**
         * Get a source by id.
         * @param {string} id id of the desired source
         * @returns {Object} source
         */
        getSource(id) {
          return this.sourceCaches[id]?.getSource();
        }
        /**
         * Add a layer to the map style. The layer will be inserted before the layer with
         * ID `before`, or appended if `before` is omitted.
         * @param {string} [before] ID of an existing layer to insert before
         */
        addLayer(layerObject, before) {
          this._checkLoaded();
          const id = layerObject.id;
          if (this.getLayer(id)) {
            this.fire(new ErrorEvent3(new Error(`Layer with id "${id}" already exists on this map`)));
            return;
          }
          if (typeof layerObject.source === "object") {
            this.addSource(id, layerObject.source);
            layerObject = clone(layerObject);
            layerObject = Object.assign(layerObject, { source: id });
          }
          const layer = createStyleLayer(layerObject);
          this._validateLayer(layer);
          layer.setEventedParent(this, { layer: { id } });
          const index = before ? this._order.indexOf(before) : this._order.length;
          if (before && index === -1) {
            this.fire(new ErrorEvent3(new Error(`Layer with id "${before}" does not exist on this map.`)));
            return;
          }
          this._order.splice(index, 0, id);
          this._layerOrderChanged = true;
          this._layers[id] = layer;
          if (this._removedLayers[id] && layer.source) {
            const removed = this._removedLayers[id];
            delete this._removedLayers[id];
            if (removed.type !== layer.type) {
              this._updatedSources[layer.source] = "clear";
            } else {
              this._updatedSources[layer.source] = "reload";
              this.sourceCaches[layer.source].pause();
            }
          }
          this._updateLayer(layer);
        }
        /**
         * Moves a layer to a different z-position. The layer will be inserted before the layer with
         * ID `before`, or appended if `before` is omitted.
         * @param {string} id  ID of the layer to move
         * @param {string} [before] ID of an existing layer to insert before
         */
        moveLayer(id, before) {
          this._checkLoaded();
          this._changed = true;
          const layer = this._layers[id];
          if (!layer) {
            this.fire(new ErrorEvent3(new Error(`The layer '${id}' does not exist in the map's style and cannot be moved.`)));
            return;
          }
          if (id === before) {
            return;
          }
          const index = this._order.indexOf(id);
          this._order.splice(index, 1);
          const newIndex = before ? this._order.indexOf(before) : this._order.length;
          if (before && newIndex === -1) {
            this.fire(new ErrorEvent3(new Error(`Layer with id "${before}" does not exist on this map.`)));
            return;
          }
          this._order.splice(newIndex, 0, id);
          this._layerOrderChanged = true;
        }
        /**
         * Remove the layer with the given id from the style.
         *
         * If no such layer exists, an `error` event is fired.
         *
         * @param {string} id id of the layer to remove
         * @fires error
         */
        removeLayer(id) {
          this._checkLoaded();
          const layer = this._layers[id];
          if (!layer) {
            this.fire(
              new ErrorEvent3(new Error(`The layer '${id}' does not exist in the map's style and cannot be removed.`))
            );
            return;
          }
          layer.setEventedParent(null);
          const index = this._order.indexOf(id);
          this._order.splice(index, 1);
          this._layerOrderChanged = true;
          this._changed = true;
          this._removedLayers[id] = layer;
          delete this._layers[id];
          delete this._updatedLayers[id];
          delete this._updatedPaintProps[id];
        }
        /**
         * Return the style layer object with the given `id`.
         *
         * @param {string} id - id of the desired layer
         * @returns {?Object} a layer, if one with the given `id` exists
         */
        getLayer(id) {
          return this._layers[id];
        }
        setLayerZoomRange(layerId, minzoom, maxzoom) {
          this._checkLoaded();
          const layer = this.getLayer(layerId);
          if (!layer) {
            this.fire(
              new ErrorEvent3(
                new Error(`The layer '${layerId}' does not exist in the map's style and cannot have zoom extent.`)
              )
            );
            return;
          }
          if (layer.minzoom === minzoom && layer.maxzoom === maxzoom) return;
          if (minzoom != null) {
            layer.minzoom = minzoom;
          }
          if (maxzoom != null) {
            layer.maxzoom = maxzoom;
          }
          this._updateLayer(layer);
        }
        setFilter(layerId, filter) {
          this._checkLoaded();
          const layer = this.getLayer(layerId);
          if (!layer) {
            this.fire(
              new ErrorEvent3(new Error(`The layer '${layerId}' does not exist in the map's style and cannot be filtered.`))
            );
            return;
          }
          if (deepEqual(layer.filter, filter)) {
            return;
          }
          if (filter === null || filter === void 0) {
            layer.filter = void 0;
            this._updateLayer(layer);
            return;
          }
          layer.filter = clone(filter);
          this._updateLayer(layer);
        }
        /**
         * Get a layer's filter object
         * @param {string} layer the layer to inspect
         * @returns {*} the layer's filter, if any
         */
        getFilter(layer) {
          return clone(this.getLayer(layer).filter);
        }
        setLayoutProperty(layerId, name, value) {
          this._checkLoaded();
          const layer = this.getLayer(layerId);
          if (!layer) {
            this.fire(
              new ErrorEvent3(new Error(`The layer '${layerId}' does not exist in the map's style and cannot be styled.`))
            );
            return;
          }
          if (deepEqual(layer.getLayoutProperty(name), value)) return;
          layer.setLayoutProperty(name, value);
          this._updateLayer(layer);
        }
        /**
         * Get a layout property's value from a given layer
         * @param {string} layer the layer to inspect
         * @param {string} name the name of the layout property
         * @returns {*} the property value
         */
        getLayoutProperty(layer, name) {
          return this.getLayer(layer).getLayoutProperty(name);
        }
        setPaintProperty(layerId, name, value) {
          this._checkLoaded();
          const layer = this.getLayer(layerId);
          if (!layer) {
            this.fire(
              new ErrorEvent3(new Error(`The layer '${layerId}' does not exist in the map's style and cannot be styled.`))
            );
            return;
          }
          if (deepEqual(layer.getPaintProperty(name), value)) return;
          const requiresRelayout = layer.setPaintProperty(name, value);
          if (requiresRelayout) {
            this._updateLayer(layer);
          }
          this._changed = true;
          this._updatedPaintProps[layerId] = true;
        }
        getPaintProperty(layer, name) {
          return this.getLayer(layer).getPaintProperty(name);
        }
        setFeatureState(feature, state) {
          this._checkLoaded();
          const sourceId = feature.source;
          const sourceLayer = feature.sourceLayer;
          const sourceCache = this.sourceCaches[sourceId];
          if (sourceCache === void 0) {
            this.fire(new ErrorEvent3(new Error(`The source '${sourceId}' does not exist in the map's style.`)));
            return;
          }
          const sourceType = sourceCache.getSource().type;
          if (sourceType === "vector" && !sourceLayer) {
            this.fire(new ErrorEvent3(new Error("The sourceLayer parameter must be provided for vector source types.")));
            return;
          }
          if (feature.id == null || feature.id === "") {
            this.fire(new ErrorEvent3(new Error("The feature id parameter must be provided.")));
            return;
          }
          sourceCache.setFeatureState(sourceLayer, feature.id, state);
        }
        getFeatureState(feature) {
          this._checkLoaded();
          const sourceId = feature.source;
          const sourceLayer = feature.sourceLayer;
          const sourceCache = this.sourceCaches[sourceId];
          if (sourceCache === void 0) {
            this.fire(new ErrorEvent3(new Error(`The source '${sourceId}' does not exist in the map's style.`)));
            return;
          }
          const sourceType = sourceCache.getSource().type;
          if (sourceType === "vector" && !sourceLayer) {
            this.fire(new ErrorEvent3(new Error("The sourceLayer parameter must be provided for vector source types.")));
            return;
          }
          return sourceCache.getFeatureState(sourceLayer, feature.id);
        }
        getTransition() {
          return Object.assign({ duration: 300, delay: 0 }, this.stylesheet?.transition);
        }
        serialize() {
          return filterObject(
            {
              version: this.stylesheet.version,
              name: this.stylesheet.name,
              metadata: this.stylesheet.metadata,
              light: this.stylesheet.light,
              center: this.stylesheet.center,
              zoom: this.stylesheet.zoom,
              bearing: this.stylesheet.bearing,
              pitch: this.stylesheet.pitch,
              sprite: this.stylesheet.sprite,
              glyphs: this.stylesheet.glyphs,
              transition: this.stylesheet.transition,
              sources: mapObject(this.sourceCaches, (source) => source.serialize()),
              layers: this._order.map((id) => this._layers[id].serialize())
            },
            (value) => value !== void 0
          );
        }
        _updateLayer(layer) {
          this._updatedLayers[layer.id] = true;
          if (layer.source && !this._updatedSources[layer.source]) {
            this._updatedSources[layer.source] = "reload";
            this.sourceCaches[layer.source].pause();
          }
          this._changed = true;
        }
        _flattenAndSortRenderedFeatures(sourceResults) {
          const features = [];
          const features3D = [];
          for (let l = this._order.length - 1; l >= 0; l--) {
            const layerId = this._order[l];
            for (const sourceResult of sourceResults) {
              const layerFeatures = sourceResult[layerId];
              if (layerFeatures) {
                if (this._layers[layerId].type === "fill-extrusion") {
                  for (const featureWrapper of layerFeatures) {
                    features3D.push(featureWrapper);
                  }
                } else {
                  for (const featureWrapper of layerFeatures) {
                    features.push(featureWrapper.feature);
                  }
                }
              }
            }
          }
          features3D.sort((a, b) => {
            return a.intersectionZ - b.intersectionZ;
          });
          for (const featureWrapper of features3D) {
            features.push(featureWrapper.feature);
          }
          return features;
        }
        queryRenderedFeatures(queryGeometry, params, transform) {
          const includedSources = {};
          if (params?.layers) {
            if (!Array.isArray(params.layers)) {
              this.fire(new ErrorEvent3(new Error("parameters.layers must be an Array.")));
              return [];
            }
            for (const layerId of params.layers) {
              const layer = this._layers[layerId];
              if (layer) {
                includedSources[layer.source] = true;
              }
            }
          }
          const sourceResults = [];
          for (const id in this.sourceCaches) {
            if (params.layers && !includedSources[id]) continue;
            sourceResults.push(
              queryRenderedFeatures(this.sourceCaches[id], this._layers, queryGeometry.viewport, params, transform)
            );
          }
          if (this.placement) {
            sourceResults.push(
              queryRenderedSymbols(
                this._layers,
                this.sourceCaches,
                queryGeometry.viewport,
                params,
                this.placement.collisionIndex,
                this.placement.retainedQueryData
              )
            );
          }
          return this._flattenAndSortRenderedFeatures(sourceResults);
        }
        querySourceFeatures(sourceID, params) {
          const sourceCache = this.sourceCaches[sourceID];
          return sourceCache ? querySourceFeatures(sourceCache, params) : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(lightOptions) {
          this._checkLoaded();
          const light = this.light.getLight();
          let _update = false;
          for (const key in lightOptions) {
            if (!deepEqual(lightOptions[key], light[key])) {
              _update = true;
              break;
            }
          }
          if (!_update) return;
          const parameters = {
            now: browser.now(),
            transition: Object.assign(
              {
                duration: 300,
                delay: 0
              },
              this.stylesheet.transition
            )
          };
          this.light.setLight(lightOptions);
          this.light.updateTransitions(parameters);
        }
        _remove() {
          rtlTextPluginEvented.off("pluginAvailable", this._rtlTextPluginCallback);
          for (const id in this.sourceCaches) {
            this.sourceCaches[id].clearTiles();
          }
          this.dispatcher.remove();
        }
        _clearSource(id) {
          this.sourceCaches[id].clearTiles();
        }
        _reloadSource(id) {
          this.sourceCaches[id].resume();
          this.sourceCaches[id].reload();
        }
        _updateSources(transform) {
          for (const id in this.sourceCaches) {
            this.sourceCaches[id].update(transform);
          }
        }
        _generateCollisionBoxes() {
          for (const id in this.sourceCaches) {
            this._reloadSource(id);
          }
        }
        _updatePlacement(transform, showCollisionBoxes, fadeDuration, crossSourceCollisions) {
          let symbolBucketsChanged = false;
          let placementCommitted = false;
          const layerTiles = {};
          for (const layerID of this._order) {
            const styleLayer = this._layers[layerID];
            if (styleLayer.type !== "symbol") continue;
            if (!layerTiles[styleLayer.source]) {
              const sourceCache = this.sourceCaches[styleLayer.source];
              layerTiles[styleLayer.source] = sourceCache.getRenderableIds(true).map((id) => sourceCache.getTileByID(id)).sort((a, b) => b.tileID.overscaledZ - a.tileID.overscaledZ || (a.tileID.isLessThan(b.tileID) ? -1 : 1));
            }
            const layerBucketsChanged = this.crossTileSymbolIndex.addLayer(
              styleLayer,
              layerTiles[styleLayer.source],
              transform.center.lng
            );
            symbolBucketsChanged = symbolBucketsChanged || layerBucketsChanged;
          }
          this.crossTileSymbolIndex.pruneUnusedLayers(this._order);
          const forceFullPlacement = this._layerOrderChanged;
          if (forceFullPlacement || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(browser.now())) {
            this.pauseablePlacement = new PauseablePlacement(
              transform,
              this._order,
              forceFullPlacement,
              showCollisionBoxes,
              fadeDuration,
              crossSourceCollisions
            );
            this._layerOrderChanged = false;
          }
          if (this.pauseablePlacement.isDone()) {
            this.placement.setStale();
          } else {
            this.pauseablePlacement.continuePlacement(this._order, this._layers, layerTiles);
            if (this.pauseablePlacement.isDone()) {
              this.placement = this.pauseablePlacement.commit(this.placement, browser.now());
              placementCommitted = true;
            }
            if (symbolBucketsChanged) {
              this.pauseablePlacement.placement.setStale();
            }
          }
          if (placementCommitted || symbolBucketsChanged) {
            for (const layerID of this._order) {
              const styleLayer = this._layers[layerID];
              if (styleLayer.type !== "symbol") continue;
              this.placement.updateLayerOpacities(styleLayer, layerTiles[styleLayer.source]);
            }
          }
          const needsRerender = !this.pauseablePlacement.isDone() || this.placement.hasTransitions(browser.now());
          return needsRerender;
        }
        _releaseSymbolFadeTiles() {
          for (const id in this.sourceCaches) {
            this.sourceCaches[id].releaseSymbolFadeTiles();
          }
        }
        // Callbacks from web workers
        getImages(_mapId, { icons }) {
          return this.imageManager.getImages(icons);
        }
        loadGlyphRange(_mapId, { stack, range }) {
          return this.glyphManager.loadGlyphRange(stack, range);
        }
      };
      Style.getSourceType = getSourceType;
      Style.setSourceType = setSourceType;
      Style.registerForPluginAvailability = registerForPluginAvailability;
      module.exports = Style;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/data/pos_attributes.js
  var require_pos_attributes = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/data/pos_attributes.js"(exports, module) {
      var { createLayout } = require_struct_array();
      module.exports = createLayout([{ name: "a_pos", type: "Int16", components: 2 }]);
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/_prelude.fragment.glsl.js
  var require_prelude_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/_prelude.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp 
#endif
#if !defined(mediump)
#define mediump 
#endif
#if !defined(highp)
#define highp 
#endif
#endif
`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/_prelude.vertex.glsl.js
  var require_prelude_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/_prelude.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp 
#endif
#if !defined(mediump)
#define mediump 
#endif
#if !defined(highp)
#define highp 
#endif
#endif
vec2 unpack_float(const float packedValue){int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity){int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.,mod(packedOpacity,2.));}vec4 decode_color(const vec2 encodedColor){return vec4(unpack_float(encodedColor[0])/255.,unpack_float(encodedColor[1])/255.);}float unpack_mix_vec2(const vec2 packedValue,const float t){return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t){vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos){vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.,pattern_size)*256.+pixel_coord_lower,pattern_size);return(tile_units_to_pixels*pos+offset)/pattern_size;}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/background.fragment.glsl.js
  var require_background_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/background.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`uniform vec4 u_color;uniform float u_opacity;void main(){gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/background.vertex.glsl.js
  var require_background_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/background.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`attribute vec2 a_pos;uniform mat4 u_matrix;void main(){gl_Position=u_matrix*vec4(a_pos,0,1);}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/background_pattern.fragment.glsl.js
  var require_background_pattern_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/background_pattern.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main(){vec2 imagecoord=mod(v_pos_a,1.);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/background_pattern.vertex.glsl.js
  var require_background_pattern_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/background_pattern.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main(){gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/circle.fragment.glsl.js
  var require_circle_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/circle.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
varying vec3 v_data;void main(){
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.,antialiased_blur,extrude_length-1.);float color_t=stroke_width<0.01?0.:smoothstep(antialiased_blur,0.,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/circle.vertex.glsl.js
  var require_circle_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/circle.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
varying vec3 v_data;void main(void){
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.)*2.-1.);vec2 circle_center=floor(a_pos*0.5);if(u_pitch_with_map){vec2 corner_position=circle_center;if(u_scale_with_map){corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;}else{vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);}else{gl_Position=u_matrix*vec4(circle_center,0,1);if(u_scale_with_map){gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;}else{gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1./DEVICE_PIXEL_RATIO/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/clipping_mask.fragment.glsl.js
  var require_clipping_mask_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/clipping_mask.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`void main(){gl_FragColor=vec4(1.);}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/clipping_mask.vertex.glsl.js
  var require_clipping_mask_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/clipping_mask.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`attribute vec2 a_pos;uniform mat4 u_matrix;void main(){gl_Position=u_matrix*vec4(a_pos,0,1);}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/heatmap.fragment.glsl.js
  var require_heatmap_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/heatmap.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`#pragma mapbox: define highp float weight
uniform highp float u_intensity;varying vec2 v_extrude;
#define GAUSS_COEF  0.3989422804014327
void main(){
#pragma mapbox: initialize highp float weight
float d=-0.5*3.*3.*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.,1.,1.);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/heatmap.vertex.glsl.js
  var require_heatmap_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/heatmap.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;const highp float ZERO=1./255./16.;
#define GAUSS_COEF  0.3989422804014327
void main(void){
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.)*2.-1.);float S=sqrt(-2.*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/heatmap_texture.fragment.glsl.js
  var require_heatmap_texture_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/heatmap_texture.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main(){float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/heatmap_texture.vertex.glsl.js
  var require_heatmap_texture_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/heatmap_texture.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main(){gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.-a_pos.y;}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/collision_box.fragment.glsl.js
  var require_collision_box_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/collision_box.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`varying float v_placed;varying float v_notUsed;void main(){float alpha=0.5;gl_FragColor=vec4(1.,0.,0.,1.)*alpha;if(v_placed>0.5){gl_FragColor=vec4(0.,0.,1.,0.5)*alpha;}if(v_notUsed>0.5){gl_FragColor*=.1;}}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/collision_box.vertex.glsl.js
  var require_collision_box_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/collision_box.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main(){vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.,4.);gl_Position=u_matrix*vec4(a_pos,0.,1.);gl_Position.xy+=a_extrude*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/collision_circle.fragment.glsl.js
  var require_collision_circle_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/collision_circle.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`uniform float u_overscale_factor;varying float v_placed;varying float v_notUsed;varying float v_radius;varying vec2 v_extrude;varying vec2 v_extrude_scale;void main(){float alpha=0.5;vec4 color=vec4(1.,0.,0.,1.)*alpha;if(v_placed>0.5){color=vec4(0.,0.,1.,0.5)*alpha;}if(v_notUsed>0.5){color*=.2;}float extrude_scale_length=length(v_extrude_scale);float extrude_length=length(v_extrude)*extrude_scale_length;float stroke_width=15.*extrude_scale_length/u_overscale_factor;float radius=v_radius*extrude_scale_length;float distance_to_edge=abs(extrude_length-radius);float opacity_t=smoothstep(-stroke_width,0.,-distance_to_edge);gl_FragColor=opacity_t*color;}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/collision_circle.vertex.glsl.js
  var require_collision_circle_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/collision_circle.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;varying float v_radius;varying vec2 v_extrude;varying vec2 v_extrude_scale;void main(){vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.,4.);gl_Position=u_matrix*vec4(a_pos,0.,1.);highp float padding_factor=1.2;gl_Position.xy+=a_extrude*u_extrude_scale*padding_factor*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;v_radius=abs(a_extrude.y);v_extrude=a_extrude*padding_factor;v_extrude_scale=u_extrude_scale*u_camera_to_center_distance*collision_perspective_ratio;}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/debug.fragment.glsl.js
  var require_debug_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/debug.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`uniform highp vec4 u_color;void main(){gl_FragColor=u_color;}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/debug.vertex.glsl.js
  var require_debug_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/debug.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`attribute vec2 a_pos;uniform mat4 u_matrix;void main(){gl_Position=u_matrix*vec4(a_pos,0,1);}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill.fragment.glsl.js
  var require_fill_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main(){
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill.vertex.glsl.js
  var require_fill_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main(){
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_outline.fragment.glsl.js
  var require_fill_outline_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_outline.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
varying vec2 v_pos;void main(){
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.-smoothstep(0.,1.,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_outline.vertex.glsl.js
  var require_fill_outline_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_outline.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main(){
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.)/2.*u_world;}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_outline_pattern.fragment.glsl.js
  var require_fill_outline_pattern_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_outline_pattern.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main(){
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.-smoothstep(0.,1.,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_outline_pattern.vertex.glsl.js
  var require_fill_outline_pattern_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_outline_pattern.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec4 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main(){
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float pixelRatio=u_scale.x;float tileRatio=u_scale.y;float fromScale=u_scale.z;float toScale=u_scale.w;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=vec2((pattern_br_a.x-pattern_tl_a.x)/pixelRatio,(pattern_br_a.y-pattern_tl_a.y)/pixelRatio);vec2 display_size_b=vec2((pattern_br_b.x-pattern_tl_b.x)/pixelRatio,(pattern_br_b.y-pattern_tl_b.y)/pixelRatio);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.)/2.*u_world;}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_pattern.fragment.glsl.js
  var require_fill_pattern_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_pattern.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main(){
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_pattern.vertex.glsl.js
  var require_fill_pattern_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_pattern.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec4 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main(){
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float pixelRatio=u_scale.x;float tileZoomRatio=u_scale.y;float fromScale=u_scale.z;float toScale=u_scale.w;vec2 display_size_a=vec2((pattern_br_a.x-pattern_tl_a.x)/pixelRatio,(pattern_br_a.y-pattern_tl_a.y)/pixelRatio);vec2 display_size_b=vec2((pattern_br_b.x-pattern_tl_b.x)/pixelRatio,(pattern_br_b.y-pattern_tl_b.y)/pixelRatio);gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_extrusion.fragment.glsl.js
  var require_fill_extrusion_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_extrusion.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`varying vec4 v_color;void main(){gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_extrusion.vertex.glsl.js
  var require_fill_extrusion_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_extrusion.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main(){
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;base=max(0.,base);height=max(0.,height);float t=mod(normal.x,2.);gl_Position=u_matrix*vec4(a_pos,t>0.?height:base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.,0.,0.,1.);vec4 ambientlight=vec4(0.03,0.03,0.03,1.);color+=ambientlight;float directional=clamp(dot(normal/16384.,u_lightpos),0.,1.);directional=mix((1.-u_lightintensity),max((1.-colorvalue+u_lightintensity),1.),directional);if(normal.y!=0.){directional*=((1.-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.,0.5),mix(0.7,0.98,1.-u_lightintensity),1.)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.,0.3,1.-u_lightcolor.r),1.);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.,0.3,1.-u_lightcolor.g),1.);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.,0.3,1.-u_lightcolor.b),1.);v_color*=u_opacity;}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_extrusion_pattern.fragment.glsl.js
  var require_fill_extrusion_pattern_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_extrusion_pattern.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main(){
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_extrusion_pattern.vertex.glsl.js
  var require_fill_extrusion_pattern_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/fill_extrusion_pattern.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec4 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main(){
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float pixelRatio=u_scale.x;float tileRatio=u_scale.y;float fromScale=u_scale.z;float toScale=u_scale.w;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=vec2((pattern_br_a.x-pattern_tl_a.x)/pixelRatio,(pattern_br_a.y-pattern_tl_a.y)/pixelRatio);vec2 display_size_b=vec2((pattern_br_b.x-pattern_tl_b.x)/pixelRatio,(pattern_br_b.y-pattern_tl_b.y)/pixelRatio);base=max(0.,base);height=max(0.,height);float t=mod(normal.x,2.);float z=t>0.?height:base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.&&normal.y==0.&&normal.z==16384.?a_pos:vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.,0.,0.,1.);float directional=clamp(dot(normal/16383.,u_lightpos),0.,1.);directional=mix((1.-u_lightintensity),max((0.5+u_lightintensity),1.),directional);if(normal.y!=0.){directional*=((1.-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.,0.5),mix(0.7,0.98,1.-u_lightintensity),1.)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.),vec3(0.3),1.-u_lightcolor),vec3(1.));v_lighting*=u_opacity;}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/hillshade_prepare.fragment.glsl.js
  var require_hillshade_prepare_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/hillshade_prepare.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform float u_maxzoom;float getElevation(vec2 coord,float bias){vec4 data=texture2D(u_image,coord)*255.;return(data.r+data.g*256.+data.b*256.*256.)/4.;}void main(){vec2 epsilon=1./u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.);float e=getElevation(v_pos,0.);float f=getElevation(v_pos+vec2(epsilon.x,0),0.);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.);float h=getElevation(v_pos+vec2(0,epsilon.y),0.);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.);float exaggeration=u_zoom<2.?0.4:u_zoom<4.5?0.35:0.3;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.,(u_zoom-u_maxzoom)*exaggeration+19.2562-u_zoom);gl_FragColor=clamp(vec4(deriv.x/2.+0.5,deriv.y/2.+0.5,1.,1.),0.,1.);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/hillshade_prepare.vertex.glsl.js
  var require_hillshade_prepare_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/hillshade_prepare.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main(){gl_Position=u_matrix*vec4(a_pos,0,1);vec2 epsilon=1./u_dimension;float scale=(u_dimension.x-2.)/u_dimension.x;v_pos=(a_texture_pos/8192.)*scale+epsilon;}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/hillshade.fragment.glsl.js
  var require_hillshade_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/hillshade.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI  3.141592653589793
void main(){vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.)-1.);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x!=0.?atan(deriv.y,-deriv.x):PI/2.*(deriv.y>0.?1.:-1.);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity!=0.5?((pow(base,slope)-1.)/(pow(base,maxValue)-1.))*maxValue:slope;float accent=cos(scaledSlope);vec4 accent_color=(1.-accent)*u_accent*clamp(intensity*2.,0.,1.);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.)-1.);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.,0.,1.);gl_FragColor=accent_color*(1.-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/hillshade.vertex.glsl.js
  var require_hillshade_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/hillshade.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main(){gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.;}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line.fragment.glsl.js
  var require_line_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;void main(){
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1./DEVICE_PIXEL_RATIO)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.,1.);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line.vertex.glsl.js
  var require_line_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`#define ANTIALIASING  1.0 / DEVICE_PIXEL_RATIO / 2.0
#define scale  0.015873016
attribute vec4 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_gl_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main(){
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
vec2 a_extrude=a_data.xy-128.;float a_direction=mod(a_data.z,4.)-1.;v_linesofar=(floor(a_data.z/4.)+a_data.w*64.)*2.;vec2 pos=a_pos_normal.xy;mediump vec2 normal=a_pos_normal.zw;v_normal=normal;gapwidth=gapwidth/2.;float halfwidth=width/2.;offset=-1.*offset;float inset=gapwidth+(gapwidth>0.?ANTIALIASING:0.);float outset=gapwidth+halfwidth*(gapwidth>0.?2.:1.)+(halfwidth==0.?0.:ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.,0.);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.,1.)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_gl_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line_gradient.fragment.glsl.js
  var require_line_gradient_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line_gradient.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp float v_lineprogress;void main(){
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1./DEVICE_PIXEL_RATIO)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.,1.);vec4 color=texture2D(u_image,vec2(v_lineprogress,0.5));gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line_gradient.vertex.glsl.js
  var require_line_gradient_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line_gradient.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`#define MAX_LINE_DISTANCE  32767.0
#define ANTIALIASING  1.0 / DEVICE_PIXEL_RATIO / 2.0
#define scale  0.015873016
attribute vec4 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_gl_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_lineprogress;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main(){
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
vec2 a_extrude=a_data.xy-128.;float a_direction=mod(a_data.z,4.)-1.;v_lineprogress=(floor(a_data.z/4.)+a_data.w*64.)*2./MAX_LINE_DISTANCE;vec2 pos=a_pos_normal.xy;mediump vec2 normal=a_pos_normal.zw;v_normal=normal;gapwidth=gapwidth/2.;float halfwidth=width/2.;offset=-1.*offset;float inset=gapwidth+(gapwidth>0.?ANTIALIASING:0.);float outset=gapwidth+halfwidth*(gapwidth>0.?2.:1.)+(halfwidth==0.?0.:ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.,0.);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.,1.)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_gl_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line_pattern.fragment.glsl.js
  var require_line_pattern_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line_pattern.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec4 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main(){
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float pixelRatio=u_scale.x;float tileZoomRatio=u_scale.y;float fromScale=u_scale.z;float toScale=u_scale.w;vec2 display_size_a=vec2((pattern_br_a.x-pattern_tl_a.x)/pixelRatio,(pattern_br_a.y-pattern_tl_a.y)/pixelRatio);vec2 display_size_b=vec2((pattern_br_b.x-pattern_tl_b.x)/pixelRatio,(pattern_br_b.y-pattern_tl_b.y)/pixelRatio);vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float dist=length(v_normal)*v_width2.s;float blur2=(blur+1./DEVICE_PIXEL_RATIO)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.,1.);float x_a=mod(v_linesofar/pattern_size_a.x,1.);float x_b=mod(v_linesofar/pattern_size_b.x,1.);float y_a=0.5+(v_normal.y*clamp(v_width2.s,0.,(pattern_size_a.y+2.)/2.)/pattern_size_a.y);float y_b=0.5+(v_normal.y*clamp(v_width2.s,0.,(pattern_size_b.y+2.)/2.)/pattern_size_b.y);vec2 pos_a=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,vec2(x_a,y_a));vec2 pos_b=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,vec2(x_b,y_b));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line_pattern.vertex.glsl.js
  var require_line_pattern_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line_pattern.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`#define scale  0.015873016
#define LINE_DISTANCE_SCALE  2.0
#define ANTIALIASING  1.0 / DEVICE_PIXEL_RATIO / 2.0
attribute vec4 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_gl_units_to_pixels;uniform mediump float u_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main(){
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 a_extrude=a_data.xy-128.;float a_direction=mod(a_data.z,4.)-1.;float a_linesofar=(floor(a_data.z/4.)+a_data.w*64.)*LINE_DISTANCE_SCALE;vec2 pos=a_pos_normal.xy;mediump vec2 normal=a_pos_normal.zw;v_normal=normal;gapwidth=gapwidth/2.;float halfwidth=width/2.;offset=-1.*offset;float inset=gapwidth+(gapwidth>0.?ANTIALIASING:0.);float outset=gapwidth+halfwidth*(gapwidth>0.?2.:1.)+(halfwidth==0.?0.:ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.,0.);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.,1.)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_gl_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line_sdf.fragment.glsl.js
  var require_line_sdf_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line_sdf.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main(){
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1./DEVICE_PIXEL_RATIO)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.,1.);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line_sdf.vertex.glsl.js
  var require_line_sdf_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/line_sdf.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`#define scale  0.015873016
#define LINE_DISTANCE_SCALE  2.0
#define ANTIALIASING  1.0 / DEVICE_PIXEL_RATIO / 2.0
attribute vec4 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_gl_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main(){
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
vec2 a_extrude=a_data.xy-128.;float a_direction=mod(a_data.z,4.)-1.;float a_linesofar=(floor(a_data.z/4.)+a_data.w*64.)*LINE_DISTANCE_SCALE;vec2 pos=a_pos_normal.xy;mediump vec2 normal=a_pos_normal.zw;v_normal=normal;gapwidth=gapwidth/2.;float halfwidth=width/2.;offset=-1.*offset;float inset=gapwidth+(gapwidth>0.?ANTIALIASING:0.);float outset=gapwidth+halfwidth*(gapwidth>0.?2.:1.)+(halfwidth==0.?0.:ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.,0.);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.,1.)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_gl_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/raster.fragment.glsl.js
  var require_raster_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/raster.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main(){vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if(color0.a>0.){color0.rgb=color0.rgb/color0.a;}if(color1.a>0.){color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/raster.vertex.glsl.js
  var require_raster_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/raster.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main(){gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.)-0.5)/u_buffer_scale)+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/symbol_icon.fragment.glsl.js
  var require_symbol_icon_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/symbol_icon.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`uniform sampler2D u_texture;
#pragma mapbox: define lowp float opacity
varying vec2 v_tex;varying float v_fade_opacity;void main(){
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/symbol_icon.vertex.glsl.js
  var require_symbol_icon_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/symbol_icon.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;
#pragma mapbox: define lowp float opacity
uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_gl_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;void main(){
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;highp float segment_angle=-a_projected_pos[2];float size;if(!u_is_size_zoom_constant&&!u_is_size_feature_constant){size=mix(a_size[0],a_size[1],u_size_t)/10.;}else if(u_is_size_zoom_constant&&!u_is_size_feature_constant){size=a_size[0]/10.;}else if(!u_is_size_zoom_constant&&u_is_size_feature_constant){size=u_size;}else{size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map?camera_to_anchor_distance/u_camera_to_center_distance:u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.,4.);size*=perspective_ratio;float fontScale=u_is_text?size/24.:size;highp float symbol_rotation=0.;if(u_rotate_symbol){vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.,1.);gl_Position=u_gl_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.*fontScale),0.,1.);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1]>0.5?u_fade_change:-u_fade_change;v_fade_opacity=max(0.,min(1.,fade_opacity[0]+fade_change));}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/symbol_sdf.fragment.glsl.js
  var require_symbol_sdf_fragment_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/symbol_sdf.fragment.glsl.js"(exports, module) {
      module.exports = String.raw`#define SDF_PX  8.0
#define EDGE_GAMMA  0.105/DEVICE_PIXEL_RATIO
uniform bool u_is_halo;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;void main(){
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text?size/24.:size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.-64.)/256.;if(u_is_halo){color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.);
#endif
}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/build/min/src/shaders/symbol_sdf.vertex.glsl.js
  var require_symbol_sdf_vertex_glsl = __commonJS({
    "node_modules/@mapwhit/tilerenderer/build/min/src/shaders/symbol_sdf.vertex.glsl.js"(exports, module) {
      module.exports = String.raw`const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_gl_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;void main(){
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;highp float segment_angle=-a_projected_pos[2];float size;if(!u_is_size_zoom_constant&&!u_is_size_feature_constant){size=mix(a_size[0],a_size[1],u_size_t)/10.;}else if(u_is_size_zoom_constant&&!u_is_size_feature_constant){size=a_size[0]/10.;}else if(!u_is_size_zoom_constant&&u_is_size_feature_constant){size=u_size;}else{size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map?camera_to_anchor_distance/u_camera_to_center_distance:u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.,4.);size*=perspective_ratio;float fontScale=u_is_text?size/24.:size;highp float symbol_rotation=0.;if(u_rotate_symbol){vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.,1.);gl_Position=u_gl_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.*fontScale),0.,1.);float gamma_scale=gl_Position.w;vec2 tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1]>0.5?u_fade_change:-u_fade_change;float interpolated_fade_opacity=max(0.,min(1.,fade_opacity[0]+fade_change));v_data0=vec2(tex.x,tex.y);v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/shaders/index.js
  var require_shaders = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/shaders/index.js"(exports, module) {
      var shaders = {
        prelude: {
          fragmentSource: require_prelude_fragment_glsl(),
          vertexSource: require_prelude_vertex_glsl()
        },
        background: {
          fragmentSource: require_background_fragment_glsl(),
          vertexSource: require_background_vertex_glsl()
        },
        backgroundPattern: {
          fragmentSource: require_background_pattern_fragment_glsl(),
          vertexSource: require_background_pattern_vertex_glsl()
        },
        circle: {
          fragmentSource: require_circle_fragment_glsl(),
          vertexSource: require_circle_vertex_glsl()
        },
        clippingMask: {
          fragmentSource: require_clipping_mask_fragment_glsl(),
          vertexSource: require_clipping_mask_vertex_glsl()
        },
        heatmap: {
          fragmentSource: require_heatmap_fragment_glsl(),
          vertexSource: require_heatmap_vertex_glsl()
        },
        heatmapTexture: {
          fragmentSource: require_heatmap_texture_fragment_glsl(),
          vertexSource: require_heatmap_texture_vertex_glsl()
        },
        collisionBox: {
          fragmentSource: require_collision_box_fragment_glsl(),
          vertexSource: require_collision_box_vertex_glsl()
        },
        collisionCircle: {
          fragmentSource: require_collision_circle_fragment_glsl(),
          vertexSource: require_collision_circle_vertex_glsl()
        },
        debug: {
          fragmentSource: require_debug_fragment_glsl(),
          vertexSource: require_debug_vertex_glsl()
        },
        fill: {
          fragmentSource: require_fill_fragment_glsl(),
          vertexSource: require_fill_vertex_glsl()
        },
        fillOutline: {
          fragmentSource: require_fill_outline_fragment_glsl(),
          vertexSource: require_fill_outline_vertex_glsl()
        },
        fillOutlinePattern: {
          fragmentSource: require_fill_outline_pattern_fragment_glsl(),
          vertexSource: require_fill_outline_pattern_vertex_glsl()
        },
        fillPattern: {
          fragmentSource: require_fill_pattern_fragment_glsl(),
          vertexSource: require_fill_pattern_vertex_glsl()
        },
        fillExtrusion: {
          fragmentSource: require_fill_extrusion_fragment_glsl(),
          vertexSource: require_fill_extrusion_vertex_glsl()
        },
        fillExtrusionPattern: {
          fragmentSource: require_fill_extrusion_pattern_fragment_glsl(),
          vertexSource: require_fill_extrusion_pattern_vertex_glsl()
        },
        hillshadePrepare: {
          fragmentSource: require_hillshade_prepare_fragment_glsl(),
          vertexSource: require_hillshade_prepare_vertex_glsl()
        },
        hillshade: {
          fragmentSource: require_hillshade_fragment_glsl(),
          vertexSource: require_hillshade_vertex_glsl()
        },
        line: {
          fragmentSource: require_line_fragment_glsl(),
          vertexSource: require_line_vertex_glsl()
        },
        lineGradient: {
          fragmentSource: require_line_gradient_fragment_glsl(),
          vertexSource: require_line_gradient_vertex_glsl()
        },
        linePattern: {
          fragmentSource: require_line_pattern_fragment_glsl(),
          vertexSource: require_line_pattern_vertex_glsl()
        },
        lineSDF: {
          fragmentSource: require_line_sdf_fragment_glsl(),
          vertexSource: require_line_sdf_vertex_glsl()
        },
        raster: {
          fragmentSource: require_raster_fragment_glsl(),
          vertexSource: require_raster_vertex_glsl()
        },
        symbolIcon: {
          fragmentSource: require_symbol_icon_fragment_glsl(),
          vertexSource: require_symbol_icon_vertex_glsl()
        },
        symbolSDF: {
          fragmentSource: require_symbol_sdf_fragment_glsl(),
          vertexSource: require_symbol_sdf_vertex_glsl()
        }
      };
      var re = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g;
      for (const programName in shaders) {
        const program = shaders[programName];
        const fragmentPragmas = {};
        program.fragmentSource = program.fragmentSource.replace(re, (match, operation, precision, type, name) => {
          fragmentPragmas[name] = true;
          if (operation === "define") {
            return `
#ifndef HAS_UNIFORM_u_${name}
varying ${precision} ${type} ${name};
#else
uniform ${precision} ${type} u_${name};
#endif
`;
          }
          return `
#ifdef HAS_UNIFORM_u_${name}
    ${precision} ${type} ${name} = u_${name};
#endif
`;
        });
        program.vertexSource = program.vertexSource.replace(re, (match, operation, precision, type, name) => {
          const attrType = type === "float" ? "vec2" : "vec4";
          const unpackType = name.match(/color/) ? "color" : attrType;
          if (fragmentPragmas[name]) {
            if (operation === "define") {
              return `
#ifndef HAS_UNIFORM_u_${name}
uniform lowp float a_${name}_t;
attribute ${precision} ${attrType} a_${name};
varying ${precision} ${type} ${name};
#else
uniform ${precision} ${type} u_${name};
#endif
`;
            }
            if (unpackType === "vec4") {
              return `
#ifndef HAS_UNIFORM_u_${name}
${name} = a_${name};
#else
${precision} ${type} ${name} = u_${name};
#endif
`;
            }
            return `
#ifndef HAS_UNIFORM_u_${name}
    ${name} = unpack_mix_${unpackType}(a_${name}, a_${name}_t);
#else
    ${precision} ${type} ${name} = u_${name};
#endif
`;
          }
          if (operation === "define") {
            return `
#ifndef HAS_UNIFORM_u_${name}
uniform lowp float a_${name}_t;
attribute ${precision} ${attrType} a_${name};
#else
uniform ${precision} ${type} u_${name};
#endif
`;
          }
          if (unpackType === "vec4") {
            return `
#ifndef HAS_UNIFORM_u_${name}
${precision} ${type} ${name} = a_${name};
#else
${precision} ${type} ${name} = u_${name};
#endif
`;
          }
          return `
#ifndef HAS_UNIFORM_u_${name}
    ${precision} ${type} ${name} = unpack_mix_${unpackType}(a_${name}, a_${name}_t);
#else
    ${precision} ${type} ${name} = u_${name};
#endif
`;
        });
      }
      module.exports = shaders;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/vertex_array_object.js
  var require_vertex_array_object = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/vertex_array_object.js"(exports, module) {
      var assert = require_nanoassert();
      var VertexArrayObject = class {
        constructor() {
          this.boundProgram = null;
          this.boundLayoutVertexBuffer = null;
          this.boundPaintVertexBuffers = [];
          this.boundIndexBuffer = null;
          this.boundVertexOffset = null;
          this.boundDynamicVertexBuffer = null;
          this.vao = null;
        }
        bind(context, program, layoutVertexBuffer, paintVertexBuffers, indexBuffer, vertexOffset, dynamicVertexBuffer, dynamicVertexBuffer2) {
          this.context = context;
          let paintBuffersDiffer = this.boundPaintVertexBuffers.length !== paintVertexBuffers.length;
          for (let i = 0; !paintBuffersDiffer && i < paintVertexBuffers.length; i++) {
            if (this.boundPaintVertexBuffers[i] !== paintVertexBuffers[i]) {
              paintBuffersDiffer = true;
            }
          }
          const isFreshBindRequired = !this.vao || this.boundProgram !== program || this.boundLayoutVertexBuffer !== layoutVertexBuffer || paintBuffersDiffer || this.boundIndexBuffer !== indexBuffer || this.boundVertexOffset !== vertexOffset || this.boundDynamicVertexBuffer !== dynamicVertexBuffer || this.boundDynamicVertexBuffer2 !== dynamicVertexBuffer2;
          if (!context.extVertexArrayObject || isFreshBindRequired) {
            this.freshBind(
              program,
              layoutVertexBuffer,
              paintVertexBuffers,
              indexBuffer,
              vertexOffset,
              dynamicVertexBuffer,
              dynamicVertexBuffer2
            );
          } else {
            context.bindVertexArrayOES.set(this.vao);
            if (dynamicVertexBuffer) {
              dynamicVertexBuffer.bind();
            }
            if (indexBuffer?.dynamicDraw) {
              indexBuffer.bind();
            }
            if (dynamicVertexBuffer2) {
              dynamicVertexBuffer2.bind();
            }
          }
        }
        freshBind(program, layoutVertexBuffer, paintVertexBuffers, indexBuffer, vertexOffset, dynamicVertexBuffer, dynamicVertexBuffer2) {
          let numPrevAttributes;
          const numNextAttributes = program.numAttributes;
          const context = this.context;
          const gl = context.gl;
          if (context.extVertexArrayObject) {
            if (this.vao) this.destroy();
            this.vao = context.extVertexArrayObject.createVertexArrayOES();
            context.bindVertexArrayOES.set(this.vao);
            numPrevAttributes = 0;
            this.boundProgram = program;
            this.boundLayoutVertexBuffer = layoutVertexBuffer;
            this.boundPaintVertexBuffers = paintVertexBuffers;
            this.boundIndexBuffer = indexBuffer;
            this.boundVertexOffset = vertexOffset;
            this.boundDynamicVertexBuffer = dynamicVertexBuffer;
            this.boundDynamicVertexBuffer2 = dynamicVertexBuffer2;
          } else {
            numPrevAttributes = context.currentNumAttributes || 0;
            for (let i = numNextAttributes; i < numPrevAttributes; i++) {
              assert(i !== 0);
              gl.disableVertexAttribArray(i);
            }
          }
          layoutVertexBuffer.enableAttributes(gl, program);
          for (const vertexBuffer of paintVertexBuffers) {
            vertexBuffer.enableAttributes(gl, program);
          }
          if (dynamicVertexBuffer) {
            dynamicVertexBuffer.enableAttributes(gl, program);
          }
          if (dynamicVertexBuffer2) {
            dynamicVertexBuffer2.enableAttributes(gl, program);
          }
          layoutVertexBuffer.bind();
          layoutVertexBuffer.setVertexAttribPointers(gl, program, vertexOffset);
          for (const vertexBuffer of paintVertexBuffers) {
            vertexBuffer.bind();
            vertexBuffer.setVertexAttribPointers(gl, program, vertexOffset);
          }
          if (dynamicVertexBuffer) {
            dynamicVertexBuffer.bind();
            dynamicVertexBuffer.setVertexAttribPointers(gl, program, vertexOffset);
          }
          if (indexBuffer) {
            indexBuffer.bind();
          }
          if (dynamicVertexBuffer2) {
            dynamicVertexBuffer2.bind();
            dynamicVertexBuffer2.setVertexAttribPointers(gl, program, vertexOffset);
          }
          context.currentNumAttributes = numNextAttributes;
        }
        destroy() {
          if (this.vao) {
            this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao);
            this.vao = null;
          }
        }
      };
      module.exports = VertexArrayObject;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/program.js
  var require_program = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/program.js"(exports, module) {
      var browser = require_browser();
      var shaders = require_shaders();
      var assert = require_nanoassert();
      var VertexArrayObject = require_vertex_array_object();
      var Program = class {
        constructor(context, source, configuration, fixedUniforms, showOverdrawInspector) {
          const gl = context.gl;
          this.program = gl.createProgram();
          const defines = configuration.defines().concat(`#define DEVICE_PIXEL_RATIO ${browser.devicePixelRatio.toFixed(1)}`);
          if (showOverdrawInspector) {
            defines.push("#define OVERDRAW_INSPECTOR;");
          }
          const fragmentSource = defines.concat(shaders.prelude.fragmentSource, source.fragmentSource).join("\n");
          const vertexSource = defines.concat(shaders.prelude.vertexSource, source.vertexSource).join("\n");
          const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(fragmentShader, fragmentSource);
          gl.compileShader(fragmentShader);
          assert(gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS), gl.getShaderInfoLog(fragmentShader));
          gl.attachShader(this.program, fragmentShader);
          const vertexShader = gl.createShader(gl.VERTEX_SHADER);
          gl.shaderSource(vertexShader, vertexSource);
          gl.compileShader(vertexShader);
          assert(gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS), gl.getShaderInfoLog(vertexShader));
          gl.attachShader(this.program, vertexShader);
          const layoutAttributes = configuration.layoutAttributes || [];
          for (let i = 0; i < layoutAttributes.length; i++) {
            gl.bindAttribLocation(this.program, i, layoutAttributes[i].name);
          }
          gl.linkProgram(this.program);
          assert(gl.getProgramParameter(this.program, gl.LINK_STATUS), gl.getProgramInfoLog(this.program));
          this.numAttributes = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);
          this.attributes = {};
          const uniformLocations = {};
          for (let i = 0; i < this.numAttributes; i++) {
            const attribute = gl.getActiveAttrib(this.program, i);
            if (attribute) {
              this.attributes[attribute.name] = gl.getAttribLocation(this.program, attribute.name);
            }
          }
          const numUniforms = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
          for (let i = 0; i < numUniforms; i++) {
            const uniform = gl.getActiveUniform(this.program, i);
            if (uniform) {
              uniformLocations[uniform.name] = gl.getUniformLocation(this.program, uniform.name);
            }
          }
          this.fixedUniforms = fixedUniforms(context, uniformLocations);
          this.binderUniforms = configuration.getUniforms(context, uniformLocations);
        }
        draw(context, drawMode, depthMode, stencilMode, colorMode, cullFaceMode, uniformValues, layerID, layoutVertexBuffer, indexBuffer, segments, currentProperties, zoom, configuration, dynamicLayoutBuffer, dynamicLayoutBuffer2) {
          const gl = context.gl;
          context.program.set(this.program);
          context.setDepthMode(depthMode);
          context.setStencilMode(stencilMode);
          context.setColorMode(colorMode);
          context.setCullFace(cullFaceMode);
          for (const name in this.fixedUniforms) {
            this.fixedUniforms[name].set(uniformValues[name]);
          }
          if (configuration) {
            configuration.setUniforms(context, this.binderUniforms, currentProperties, { zoom });
          }
          const primitiveSize = {
            [gl.LINES]: 2,
            [gl.TRIANGLES]: 3,
            [gl.LINE_STRIP]: 1
          }[drawMode];
          for (const segment of segments.get()) {
            const vaos = segment.vaos || (segment.vaos = {});
            const vao = vaos[layerID] || (vaos[layerID] = new VertexArrayObject());
            vao.bind(
              context,
              this,
              layoutVertexBuffer,
              configuration ? configuration.getPaintVertexBuffers() : [],
              indexBuffer,
              segment.vertexOffset,
              dynamicLayoutBuffer,
              dynamicLayoutBuffer2
            );
            gl.drawElements(
              drawMode,
              segment.primitiveLength * primitiveSize,
              gl.UNSIGNED_SHORT,
              segment.primitiveOffset * primitiveSize * 2
            );
          }
        }
      };
      module.exports = Program;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/program/pattern.js
  var require_pattern = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/program/pattern.js"(exports, module) {
      var assert = require_nanoassert();
      var browser = require_browser();
      var pixelsToTileUnits = require_pixels_to_tile_units();
      function patternUniformValues(crossfade, painter, tile) {
        const tileRatio = 1 / pixelsToTileUnits(tile, 1, painter.transform.tileZoom);
        const numTiles = 2 ** tile.tileID.overscaledZ;
        const tileSizeAtNearestZoom = tile.tileSize * 2 ** painter.transform.tileZoom / numTiles;
        const pixelX = tileSizeAtNearestZoom * (tile.tileID.canonical.x + tile.tileID.wrap * numTiles);
        const pixelY = tileSizeAtNearestZoom * tile.tileID.canonical.y;
        return {
          u_image: 0,
          u_texsize: tile.imageAtlasTexture.size,
          // this assumes all images in the icon atlas texture have the same pixel ratio
          u_scale: [browser.devicePixelRatio, tileRatio, crossfade.fromScale, crossfade.toScale],
          u_fade: crossfade.t,
          // split the pixel coord into two pairs of 16 bit numbers. The glsl spec only guarantees 16 bits of precision.
          u_pixel_coord_upper: [pixelX >> 16, pixelY >> 16],
          u_pixel_coord_lower: [pixelX & 65535, pixelY & 65535]
        };
      }
      function bgPatternUniformValues(image, crossfade, painter, tile) {
        const imagePosA = painter.imageManager.getPattern(image.from);
        const imagePosB = painter.imageManager.getPattern(image.to);
        assert(imagePosA && imagePosB);
        const { width, height } = painter.imageManager.getPixelSize();
        const numTiles = 2 ** tile.tileID.overscaledZ;
        const tileSizeAtNearestZoom = tile.tileSize * 2 ** painter.transform.tileZoom / numTiles;
        const pixelX = tileSizeAtNearestZoom * (tile.tileID.canonical.x + tile.tileID.wrap * numTiles);
        const pixelY = tileSizeAtNearestZoom * tile.tileID.canonical.y;
        return {
          u_image: 0,
          u_pattern_tl_a: imagePosA.tl,
          u_pattern_br_a: imagePosA.br,
          u_pattern_tl_b: imagePosB.tl,
          u_pattern_br_b: imagePosB.br,
          u_texsize: [width, height],
          u_mix: crossfade.t,
          u_pattern_size_a: imagePosA.displaySize,
          u_pattern_size_b: imagePosB.displaySize,
          u_scale_a: crossfade.fromScale,
          u_scale_b: crossfade.toScale,
          u_tile_units_to_pixels: 1 / pixelsToTileUnits(tile, 1, painter.transform.tileZoom),
          // split the pixel coord into two pairs of 16 bit numbers. The glsl spec only guarantees 16 bits of precision.
          u_pixel_coord_upper: [pixelX >> 16, pixelY >> 16],
          u_pixel_coord_lower: [pixelX & 65535, pixelY & 65535]
        };
      }
      module.exports = { bgPatternUniformValues, patternUniformValues };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/program/fill_extrusion_program.js
  var require_fill_extrusion_program = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/program/fill_extrusion_program.js"(exports, module) {
      var { patternUniformValues } = require_pattern();
      var { Uniform1i, Uniform1f, Uniform2f, Uniform3f, Uniform4f, UniformMatrix4f } = require_uniform_binding();
      var { mat3, vec3 } = require_gl_matrix();
      var fillExtrusionUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_lightpos: new Uniform3f(context, locations.u_lightpos),
        u_lightintensity: new Uniform1f(context, locations.u_lightintensity),
        u_lightcolor: new Uniform3f(context, locations.u_lightcolor),
        u_vertical_gradient: new Uniform1f(context, locations.u_vertical_gradient),
        u_opacity: new Uniform1f(context, locations.u_opacity)
      });
      var fillExtrusionPatternUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_lightpos: new Uniform3f(context, locations.u_lightpos),
        u_lightintensity: new Uniform1f(context, locations.u_lightintensity),
        u_lightcolor: new Uniform3f(context, locations.u_lightcolor),
        u_vertical_gradient: new Uniform1f(context, locations.u_vertical_gradient),
        u_height_factor: new Uniform1f(context, locations.u_height_factor),
        u_image: new Uniform1i(context, locations.u_image),
        u_texsize: new Uniform2f(context, locations.u_texsize),
        u_pixel_coord_upper: new Uniform2f(context, locations.u_pixel_coord_upper),
        u_pixel_coord_lower: new Uniform2f(context, locations.u_pixel_coord_lower),
        u_scale: new Uniform4f(context, locations.u_scale),
        u_fade: new Uniform1f(context, locations.u_fade),
        u_opacity: new Uniform1f(context, locations.u_opacity)
      });
      var fillExtrusionUniformValues = (matrix, painter, shouldUseVerticalGradient, opacity) => {
        const light = painter.style.light;
        const _lp = light.properties.get("position");
        const lightPos = [_lp.x, _lp.y, _lp.z];
        const lightMat = mat3.create();
        if (light.properties.get("anchor") === "viewport") {
          mat3.fromRotation(lightMat, -painter.transform.angle);
        }
        vec3.transformMat3(lightPos, lightPos, lightMat);
        const lightColor = light.properties.get("color");
        return {
          u_matrix: matrix,
          u_lightpos: lightPos,
          u_lightintensity: light.properties.get("intensity"),
          u_lightcolor: [lightColor.r, lightColor.g, lightColor.b],
          u_vertical_gradient: +shouldUseVerticalGradient,
          u_opacity: opacity
        };
      };
      var fillExtrusionPatternUniformValues = (matrix, painter, shouldUseVerticalGradient, opacity, coord, crossfade, tile) => {
        return Object.assign(
          fillExtrusionUniformValues(matrix, painter, shouldUseVerticalGradient, opacity),
          patternUniformValues(crossfade, painter, tile),
          {
            u_height_factor: -(2 ** coord.overscaledZ) / tile.tileSize / 8
          }
        );
      };
      module.exports = {
        fillExtrusionUniforms,
        fillExtrusionPatternUniforms,
        fillExtrusionUniformValues,
        fillExtrusionPatternUniformValues
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/program/fill_program.js
  var require_fill_program = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/program/fill_program.js"(exports, module) {
      var { patternUniformValues } = require_pattern();
      var { Uniform1i, Uniform1f, Uniform2f, Uniform4f, UniformMatrix4f } = require_uniform_binding();
      var fillUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix)
      });
      var fillPatternUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_image: new Uniform1i(context, locations.u_image),
        u_texsize: new Uniform2f(context, locations.u_texsize),
        u_pixel_coord_upper: new Uniform2f(context, locations.u_pixel_coord_upper),
        u_pixel_coord_lower: new Uniform2f(context, locations.u_pixel_coord_lower),
        u_scale: new Uniform4f(context, locations.u_scale),
        u_fade: new Uniform1f(context, locations.u_fade)
      });
      var fillOutlineUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_world: new Uniform2f(context, locations.u_world)
      });
      var fillOutlinePatternUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_world: new Uniform2f(context, locations.u_world),
        u_image: new Uniform1i(context, locations.u_image),
        u_texsize: new Uniform2f(context, locations.u_texsize),
        u_pixel_coord_upper: new Uniform2f(context, locations.u_pixel_coord_upper),
        u_pixel_coord_lower: new Uniform2f(context, locations.u_pixel_coord_lower),
        u_scale: new Uniform4f(context, locations.u_scale),
        u_fade: new Uniform1f(context, locations.u_fade)
      });
      var fillUniformValues = (matrix) => ({
        u_matrix: matrix
      });
      var fillPatternUniformValues = (matrix, painter, crossfade, tile) => Object.assign(fillUniformValues(matrix), patternUniformValues(crossfade, painter, tile));
      var fillOutlineUniformValues = (matrix, drawingBufferSize) => ({
        u_matrix: matrix,
        u_world: drawingBufferSize
      });
      var fillOutlinePatternUniformValues = (matrix, painter, crossfade, tile, drawingBufferSize) => Object.assign(fillPatternUniformValues(matrix, painter, crossfade, tile), {
        u_world: drawingBufferSize
      });
      module.exports = {
        fillUniforms,
        fillPatternUniforms,
        fillOutlineUniforms,
        fillOutlinePatternUniforms,
        fillUniformValues,
        fillPatternUniformValues,
        fillOutlineUniformValues,
        fillOutlinePatternUniformValues
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/program/circle_program.js
  var require_circle_program = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/program/circle_program.js"(exports, module) {
      var { Uniform1i, Uniform1f, Uniform2f, UniformMatrix4f } = require_uniform_binding();
      var pixelsToTileUnits = require_pixels_to_tile_units();
      var circleUniforms = (context, locations) => ({
        u_camera_to_center_distance: new Uniform1f(context, locations.u_camera_to_center_distance),
        u_scale_with_map: new Uniform1i(context, locations.u_scale_with_map),
        u_pitch_with_map: new Uniform1i(context, locations.u_pitch_with_map),
        u_extrude_scale: new Uniform2f(context, locations.u_extrude_scale),
        u_matrix: new UniformMatrix4f(context, locations.u_matrix)
      });
      var circleUniformValues = (painter, coord, tile, layer) => {
        const transform = painter.transform;
        let pitchWithMap;
        let extrudeScale;
        if (layer.paint.get("circle-pitch-alignment") === "map") {
          const pixelRatio = pixelsToTileUnits(tile, 1, transform.zoom);
          pitchWithMap = true;
          extrudeScale = [pixelRatio, pixelRatio];
        } else {
          pitchWithMap = false;
          extrudeScale = transform.pixelsToGLUnits;
        }
        return {
          u_camera_to_center_distance: transform.cameraToCenterDistance,
          u_scale_with_map: +(layer.paint.get("circle-pitch-scale") === "map"),
          u_matrix: painter.translatePosMatrix(
            coord.posMatrix,
            tile,
            layer.paint.get("circle-translate"),
            layer.paint.get("circle-translate-anchor")
          ),
          u_pitch_with_map: +pitchWithMap,
          u_extrude_scale: extrudeScale
        };
      };
      module.exports = { circleUniforms, circleUniformValues };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/program/collision_program.js
  var require_collision_program = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/program/collision_program.js"(exports, module) {
      var { Uniform1f, Uniform2f, UniformMatrix4f } = require_uniform_binding();
      var pixelsToTileUnits = require_pixels_to_tile_units();
      var collisionUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_camera_to_center_distance: new Uniform1f(context, locations.u_camera_to_center_distance),
        u_pixels_to_tile_units: new Uniform1f(context, locations.u_pixels_to_tile_units),
        u_extrude_scale: new Uniform2f(context, locations.u_extrude_scale),
        u_overscale_factor: new Uniform1f(context, locations.u_overscale_factor)
      });
      var collisionUniformValues = (matrix, transform, tile) => {
        const pixelRatio = pixelsToTileUnits(tile, 1, transform.zoom);
        const scale = 2 ** (transform.zoom - tile.tileID.overscaledZ);
        const overscaleFactor = tile.tileID.overscaleFactor();
        return {
          u_matrix: matrix,
          u_camera_to_center_distance: transform.cameraToCenterDistance,
          u_pixels_to_tile_units: pixelRatio,
          u_extrude_scale: [
            transform.pixelsToGLUnits[0] / (pixelRatio * scale),
            transform.pixelsToGLUnits[1] / (pixelRatio * scale)
          ],
          u_overscale_factor: overscaleFactor
        };
      };
      module.exports = { collisionUniforms, collisionUniformValues };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/program/debug_program.js
  var require_debug_program = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/program/debug_program.js"(exports, module) {
      var { UniformColor, UniformMatrix4f } = require_uniform_binding();
      var debugUniforms = (context, locations) => ({
        u_color: new UniformColor(context, locations.u_color),
        u_matrix: new UniformMatrix4f(context, locations.u_matrix)
      });
      var debugUniformValues = (matrix, color) => ({
        u_matrix: matrix,
        u_color: color
      });
      module.exports = { debugUniforms, debugUniformValues };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/program/clipping_mask_program.js
  var require_clipping_mask_program = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/program/clipping_mask_program.js"(exports, module) {
      var { UniformMatrix4f } = require_uniform_binding();
      var clippingMaskUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix)
      });
      var clippingMaskUniformValues = (matrix) => ({
        u_matrix: matrix
      });
      module.exports = { clippingMaskUniforms, clippingMaskUniformValues };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/program/heatmap_program.js
  var require_heatmap_program = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/program/heatmap_program.js"(exports, module) {
      var { mat4 } = require_gl_matrix();
      var { Uniform1i, Uniform1f, Uniform2f, UniformMatrix4f } = require_uniform_binding();
      var pixelsToTileUnits = require_pixels_to_tile_units();
      var heatmapUniforms = (context, locations) => ({
        u_extrude_scale: new Uniform1f(context, locations.u_extrude_scale),
        u_intensity: new Uniform1f(context, locations.u_intensity),
        u_matrix: new UniformMatrix4f(context, locations.u_matrix)
      });
      var heatmapTextureUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_world: new Uniform2f(context, locations.u_world),
        u_image: new Uniform1i(context, locations.u_image),
        u_color_ramp: new Uniform1i(context, locations.u_color_ramp),
        u_opacity: new Uniform1f(context, locations.u_opacity)
      });
      var heatmapUniformValues = (matrix, tile, zoom, intensity) => ({
        u_matrix: matrix,
        u_extrude_scale: pixelsToTileUnits(tile, 1, zoom),
        u_intensity: intensity
      });
      var heatmapTextureUniformValues = (painter, layer, textureUnit, colorRampUnit) => {
        const matrix = mat4.create();
        mat4.ortho(matrix, 0, painter.width, painter.height, 0, 0, 1);
        const gl = painter.context.gl;
        return {
          u_matrix: matrix,
          u_world: [gl.drawingBufferWidth, gl.drawingBufferHeight],
          u_image: textureUnit,
          u_color_ramp: colorRampUnit,
          u_opacity: layer.paint.get("heatmap-opacity")
        };
      };
      module.exports = {
        heatmapUniforms,
        heatmapTextureUniforms,
        heatmapUniformValues,
        heatmapTextureUniformValues
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/program/hillshade_program.js
  var require_hillshade_program = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/program/hillshade_program.js"(exports, module) {
      var assert = require_nanoassert();
      var { mat4 } = require_gl_matrix();
      var { Uniform1i, Uniform1f, Uniform2f, UniformColor, UniformMatrix4f } = require_uniform_binding();
      var EXTENT = require_extent();
      var Coordinate = require_coordinate();
      var hillshadeUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_image: new Uniform1i(context, locations.u_image),
        u_latrange: new Uniform2f(context, locations.u_latrange),
        u_light: new Uniform2f(context, locations.u_light),
        u_shadow: new UniformColor(context, locations.u_shadow),
        u_highlight: new UniformColor(context, locations.u_highlight),
        u_accent: new UniformColor(context, locations.u_accent)
      });
      var hillshadePrepareUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_image: new Uniform1i(context, locations.u_image),
        u_dimension: new Uniform2f(context, locations.u_dimension),
        u_zoom: new Uniform1f(context, locations.u_zoom),
        u_maxzoom: new Uniform1f(context, locations.u_maxzoom)
      });
      var hillshadeUniformValues = (painter, tile, layer) => {
        const shadow = layer.paint.get("hillshade-shadow-color");
        const highlight = layer.paint.get("hillshade-highlight-color");
        const accent = layer.paint.get("hillshade-accent-color");
        let azimuthal = layer.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
        if (layer.paint.get("hillshade-illumination-anchor") === "viewport") {
          azimuthal -= painter.transform.angle;
        }
        const align = !painter.options.moving;
        return {
          u_matrix: painter.transform.calculatePosMatrix(tile.tileID.toUnwrapped(), align),
          u_image: 0,
          u_latrange: getTileLatRange(painter, tile.tileID),
          u_light: [layer.paint.get("hillshade-exaggeration"), azimuthal],
          u_shadow: shadow,
          u_highlight: highlight,
          u_accent: accent
        };
      };
      var hillshadeUniformPrepareValues = (tile, maxzoom) => {
        assert(tile.dem);
        const stride = tile.dem.stride;
        const matrix = mat4.create();
        mat4.ortho(matrix, 0, EXTENT, -EXTENT, 0, 0, 1);
        mat4.translate(matrix, matrix, [0, -EXTENT, 0]);
        return {
          u_matrix: matrix,
          u_image: 1,
          u_dimension: [stride, stride],
          u_zoom: tile.tileID.overscaledZ,
          u_maxzoom: maxzoom
        };
      };
      function getTileLatRange(painter, tileID) {
        const coordinate0 = tileID.toCoordinate();
        const coordinate1 = new Coordinate(coordinate0.column, coordinate0.row + 1, coordinate0.zoom);
        return [painter.transform.coordinateLocation(coordinate0).lat, painter.transform.coordinateLocation(coordinate1).lat];
      }
      module.exports = {
        hillshadeUniforms,
        hillshadePrepareUniforms,
        hillshadeUniformValues,
        hillshadeUniformPrepareValues
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/program/line_program.js
  var require_line_program = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/program/line_program.js"(exports, module) {
      var { Uniform1i, Uniform1f, Uniform2f, Uniform4f, UniformMatrix4f } = require_uniform_binding();
      var pixelsToTileUnits = require_pixels_to_tile_units();
      var browser = require_browser();
      var lineUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_ratio: new Uniform1f(context, locations.u_ratio),
        u_gl_units_to_pixels: new Uniform2f(context, locations.u_gl_units_to_pixels)
      });
      var lineGradientUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_ratio: new Uniform1f(context, locations.u_ratio),
        u_gl_units_to_pixels: new Uniform2f(context, locations.u_gl_units_to_pixels),
        u_image: new Uniform1i(context, locations.u_image)
      });
      var linePatternUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_texsize: new Uniform2f(context, locations.u_texsize),
        u_ratio: new Uniform1f(context, locations.u_ratio),
        u_image: new Uniform1i(context, locations.u_image),
        u_gl_units_to_pixels: new Uniform2f(context, locations.u_gl_units_to_pixels),
        u_scale: new Uniform4f(context, locations.u_scale),
        u_fade: new Uniform1f(context, locations.u_fade)
      });
      var lineSDFUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_ratio: new Uniform1f(context, locations.u_ratio),
        u_gl_units_to_pixels: new Uniform2f(context, locations.u_gl_units_to_pixels),
        u_patternscale_a: new Uniform2f(context, locations.u_patternscale_a),
        u_patternscale_b: new Uniform2f(context, locations.u_patternscale_b),
        u_sdfgamma: new Uniform1f(context, locations.u_sdfgamma),
        u_image: new Uniform1i(context, locations.u_image),
        u_tex_y_a: new Uniform1f(context, locations.u_tex_y_a),
        u_tex_y_b: new Uniform1f(context, locations.u_tex_y_b),
        u_mix: new Uniform1f(context, locations.u_mix)
      });
      var lineUniformValues = (painter, tile, layer) => {
        const transform = painter.transform;
        return {
          u_matrix: calculateMatrix(painter, tile, layer),
          u_ratio: 1 / pixelsToTileUnits(tile, 1, transform.zoom),
          u_gl_units_to_pixels: [1 / transform.pixelsToGLUnits[0], 1 / transform.pixelsToGLUnits[1]]
        };
      };
      var lineGradientUniformValues = (painter, tile, layer) => {
        return Object.assign(lineUniformValues(painter, tile, layer), {
          u_image: 0
        });
      };
      var linePatternUniformValues = (painter, tile, layer, crossfade) => {
        const transform = painter.transform;
        const tileZoomRatio = calculateTileRatio(tile, transform);
        return {
          u_matrix: calculateMatrix(painter, tile, layer),
          u_texsize: tile.imageAtlasTexture.size,
          // camera zoom ratio
          u_ratio: 1 / pixelsToTileUnits(tile, 1, transform.zoom),
          u_image: 0,
          // this assumes all images in the icon atlas texture have the same pixel ratio
          u_scale: [browser.devicePixelRatio, tileZoomRatio, crossfade.fromScale, crossfade.toScale],
          u_fade: crossfade.t,
          u_gl_units_to_pixels: [1 / transform.pixelsToGLUnits[0], 1 / transform.pixelsToGLUnits[1]]
        };
      };
      var lineSDFUniformValues = (painter, tile, layer, dasharray, crossfade) => {
        const transform = painter.transform;
        const lineAtlas = painter.lineAtlas;
        const tileRatio = calculateTileRatio(tile, transform);
        const round = layer.layout.get("line-cap") === "round";
        const posA = lineAtlas.getDash(dasharray.from, round);
        const posB = lineAtlas.getDash(dasharray.to, round);
        const widthA = posA.width * crossfade.fromScale;
        const widthB = posB.width * crossfade.toScale;
        return Object.assign(lineUniformValues(painter, tile, layer), {
          u_patternscale_a: [tileRatio / widthA, -posA.height / 2],
          u_patternscale_b: [tileRatio / widthB, -posB.height / 2],
          u_sdfgamma: lineAtlas.width / (Math.min(widthA, widthB) * 256 * browser.devicePixelRatio) / 2,
          u_image: 0,
          u_tex_y_a: posA.y,
          u_tex_y_b: posB.y,
          u_mix: crossfade.t
        });
      };
      function calculateTileRatio(tile, transform) {
        return 1 / pixelsToTileUnits(tile, 1, transform.tileZoom);
      }
      function calculateMatrix(painter, tile, layer) {
        return painter.translatePosMatrix(
          tile.tileID.posMatrix,
          tile,
          layer.paint.get("line-translate"),
          layer.paint.get("line-translate-anchor")
        );
      }
      module.exports = {
        lineUniforms,
        lineGradientUniforms,
        linePatternUniforms,
        lineSDFUniforms,
        lineUniformValues,
        lineGradientUniformValues,
        linePatternUniformValues,
        lineSDFUniformValues
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/program/raster_program.js
  var require_raster_program = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/program/raster_program.js"(exports, module) {
      var { Uniform1i, Uniform1f, Uniform2f, Uniform3f, UniformMatrix4f } = require_uniform_binding();
      var rasterUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_tl_parent: new Uniform2f(context, locations.u_tl_parent),
        u_scale_parent: new Uniform1f(context, locations.u_scale_parent),
        u_buffer_scale: new Uniform1f(context, locations.u_buffer_scale),
        u_fade_t: new Uniform1f(context, locations.u_fade_t),
        u_opacity: new Uniform1f(context, locations.u_opacity),
        u_image0: new Uniform1i(context, locations.u_image0),
        u_image1: new Uniform1i(context, locations.u_image1),
        u_brightness_low: new Uniform1f(context, locations.u_brightness_low),
        u_brightness_high: new Uniform1f(context, locations.u_brightness_high),
        u_saturation_factor: new Uniform1f(context, locations.u_saturation_factor),
        u_contrast_factor: new Uniform1f(context, locations.u_contrast_factor),
        u_spin_weights: new Uniform3f(context, locations.u_spin_weights)
      });
      var rasterUniformValues = (matrix, parentTL, parentScaleBy, fade, layer) => ({
        u_matrix: matrix,
        u_tl_parent: parentTL,
        u_scale_parent: parentScaleBy,
        u_buffer_scale: 1,
        u_fade_t: fade.mix,
        u_opacity: fade.opacity * layer.paint.get("raster-opacity"),
        u_image0: 0,
        u_image1: 1,
        u_brightness_low: layer.paint.get("raster-brightness-min"),
        u_brightness_high: layer.paint.get("raster-brightness-max"),
        u_saturation_factor: saturationFactor(layer.paint.get("raster-saturation")),
        u_contrast_factor: contrastFactor(layer.paint.get("raster-contrast")),
        u_spin_weights: spinWeights(layer.paint.get("raster-hue-rotate"))
      });
      function spinWeights(angle) {
        angle *= Math.PI / 180;
        const s = Math.sin(angle);
        const c = Math.cos(angle);
        return [(2 * c + 1) / 3, (-Math.sqrt(3) * s - c + 1) / 3, (Math.sqrt(3) * s - c + 1) / 3];
      }
      function contrastFactor(contrast) {
        return contrast > 0 ? 1 / (1 - contrast) : 1 + contrast;
      }
      function saturationFactor(saturation) {
        return saturation > 0 ? 1 - 1 / (1.001 - saturation) : -saturation;
      }
      module.exports = { rasterUniforms, rasterUniformValues };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/program/symbol_program.js
  var require_symbol_program = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/program/symbol_program.js"(exports, module) {
      var { Uniform1i, Uniform1f, Uniform2f, UniformMatrix4f } = require_uniform_binding();
      var symbolIconUniforms = (context, locations) => ({
        u_is_size_zoom_constant: new Uniform1i(context, locations.u_is_size_zoom_constant),
        u_is_size_feature_constant: new Uniform1i(context, locations.u_is_size_feature_constant),
        u_size_t: new Uniform1f(context, locations.u_size_t),
        u_size: new Uniform1f(context, locations.u_size),
        u_camera_to_center_distance: new Uniform1f(context, locations.u_camera_to_center_distance),
        u_pitch: new Uniform1f(context, locations.u_pitch),
        u_rotate_symbol: new Uniform1i(context, locations.u_rotate_symbol),
        u_aspect_ratio: new Uniform1f(context, locations.u_aspect_ratio),
        u_fade_change: new Uniform1f(context, locations.u_fade_change),
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_label_plane_matrix: new UniformMatrix4f(context, locations.u_label_plane_matrix),
        u_gl_coord_matrix: new UniformMatrix4f(context, locations.u_gl_coord_matrix),
        u_is_text: new Uniform1f(context, locations.u_is_text),
        u_pitch_with_map: new Uniform1i(context, locations.u_pitch_with_map),
        u_texsize: new Uniform2f(context, locations.u_texsize),
        u_texture: new Uniform1i(context, locations.u_texture)
      });
      var symbolSDFUniforms = (context, locations) => ({
        u_is_size_zoom_constant: new Uniform1i(context, locations.u_is_size_zoom_constant),
        u_is_size_feature_constant: new Uniform1i(context, locations.u_is_size_feature_constant),
        u_size_t: new Uniform1f(context, locations.u_size_t),
        u_size: new Uniform1f(context, locations.u_size),
        u_camera_to_center_distance: new Uniform1f(context, locations.u_camera_to_center_distance),
        u_pitch: new Uniform1f(context, locations.u_pitch),
        u_rotate_symbol: new Uniform1i(context, locations.u_rotate_symbol),
        u_aspect_ratio: new Uniform1f(context, locations.u_aspect_ratio),
        u_fade_change: new Uniform1f(context, locations.u_fade_change),
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_label_plane_matrix: new UniformMatrix4f(context, locations.u_label_plane_matrix),
        u_gl_coord_matrix: new UniformMatrix4f(context, locations.u_gl_coord_matrix),
        u_is_text: new Uniform1f(context, locations.u_is_text),
        u_pitch_with_map: new Uniform1i(context, locations.u_pitch_with_map),
        u_texsize: new Uniform2f(context, locations.u_texsize),
        u_texture: new Uniform1i(context, locations.u_texture),
        u_gamma_scale: new Uniform1f(context, locations.u_gamma_scale),
        u_is_halo: new Uniform1f(context, locations.u_is_halo)
      });
      var symbolIconUniformValues = (functionType, size, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, isText, texSize) => {
        const { transform } = painter;
        return {
          u_is_size_zoom_constant: +(functionType === "constant" || functionType === "source"),
          u_is_size_feature_constant: +(functionType === "constant" || functionType === "camera"),
          u_size_t: size ? size.uSizeT : 0,
          u_size: size ? size.uSize : 0,
          u_camera_to_center_distance: transform.cameraToCenterDistance,
          u_pitch: transform.pitch / 360 * 2 * Math.PI,
          u_rotate_symbol: +rotateInShader,
          u_aspect_ratio: transform.width / transform.height,
          u_fade_change: painter.options.fadeDuration ? painter.symbolFadeChange : 1,
          u_matrix: matrix,
          u_label_plane_matrix: labelPlaneMatrix,
          u_gl_coord_matrix: glCoordMatrix,
          u_is_text: +isText,
          u_pitch_with_map: +pitchWithMap,
          u_texsize: texSize,
          u_texture: 0
        };
      };
      var symbolSDFUniformValues = (functionType, size, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, isText, texSize, isHalo) => {
        const { transform } = painter;
        return Object.assign(
          symbolIconUniformValues(
            functionType,
            size,
            rotateInShader,
            pitchWithMap,
            painter,
            matrix,
            labelPlaneMatrix,
            glCoordMatrix,
            isText,
            texSize
          ),
          {
            u_gamma_scale: pitchWithMap ? Math.cos(transform._pitch) * transform.cameraToCenterDistance : 1,
            u_is_halo: +isHalo
          }
        );
      };
      module.exports = { symbolIconUniforms, symbolSDFUniforms, symbolIconUniformValues, symbolSDFUniformValues };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/program/background_program.js
  var require_background_program = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/program/background_program.js"(exports, module) {
      var { bgPatternUniformValues } = require_pattern();
      var { Uniform1i, Uniform1f, Uniform2f, UniformColor, UniformMatrix4f } = require_uniform_binding();
      var backgroundUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_opacity: new Uniform1f(context, locations.u_opacity),
        u_color: new UniformColor(context, locations.u_color)
      });
      var backgroundPatternUniforms = (context, locations) => ({
        u_matrix: new UniformMatrix4f(context, locations.u_matrix),
        u_opacity: new Uniform1f(context, locations.u_opacity),
        u_image: new Uniform1i(context, locations.u_image),
        u_pattern_tl_a: new Uniform2f(context, locations.u_pattern_tl_a),
        u_pattern_br_a: new Uniform2f(context, locations.u_pattern_br_a),
        u_pattern_tl_b: new Uniform2f(context, locations.u_pattern_tl_b),
        u_pattern_br_b: new Uniform2f(context, locations.u_pattern_br_b),
        u_texsize: new Uniform2f(context, locations.u_texsize),
        u_mix: new Uniform1f(context, locations.u_mix),
        u_pattern_size_a: new Uniform2f(context, locations.u_pattern_size_a),
        u_pattern_size_b: new Uniform2f(context, locations.u_pattern_size_b),
        u_scale_a: new Uniform1f(context, locations.u_scale_a),
        u_scale_b: new Uniform1f(context, locations.u_scale_b),
        u_pixel_coord_upper: new Uniform2f(context, locations.u_pixel_coord_upper),
        u_pixel_coord_lower: new Uniform2f(context, locations.u_pixel_coord_lower),
        u_tile_units_to_pixels: new Uniform1f(context, locations.u_tile_units_to_pixels)
      });
      var backgroundUniformValues = (matrix, opacity, color) => ({
        u_matrix: matrix,
        u_opacity: opacity,
        u_color: color
      });
      var backgroundPatternUniformValues = (matrix, opacity, painter, image, tile, crossfade) => Object.assign(bgPatternUniformValues(image, crossfade, painter, tile), {
        u_matrix: matrix,
        u_opacity: opacity
      });
      module.exports = {
        backgroundUniforms,
        backgroundPatternUniforms,
        backgroundUniformValues,
        backgroundPatternUniformValues
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/program/program_uniforms.js
  var require_program_uniforms = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/program/program_uniforms.js"(exports, module) {
      var { fillExtrusionUniforms, fillExtrusionPatternUniforms } = require_fill_extrusion_program();
      var {
        fillUniforms,
        fillPatternUniforms,
        fillOutlineUniforms,
        fillOutlinePatternUniforms
      } = require_fill_program();
      var { circleUniforms } = require_circle_program();
      var { collisionUniforms } = require_collision_program();
      var { debugUniforms } = require_debug_program();
      var { clippingMaskUniforms } = require_clipping_mask_program();
      var { heatmapUniforms, heatmapTextureUniforms } = require_heatmap_program();
      var { hillshadeUniforms, hillshadePrepareUniforms } = require_hillshade_program();
      var { lineUniforms, lineGradientUniforms, linePatternUniforms, lineSDFUniforms } = require_line_program();
      var { rasterUniforms } = require_raster_program();
      var { symbolIconUniforms, symbolSDFUniforms } = require_symbol_program();
      var { backgroundUniforms, backgroundPatternUniforms } = require_background_program();
      var programUniforms = {
        fillExtrusion: fillExtrusionUniforms,
        fillExtrusionPattern: fillExtrusionPatternUniforms,
        fill: fillUniforms,
        fillPattern: fillPatternUniforms,
        fillOutline: fillOutlineUniforms,
        fillOutlinePattern: fillOutlinePatternUniforms,
        circle: circleUniforms,
        collisionBox: collisionUniforms,
        collisionCircle: collisionUniforms,
        debug: debugUniforms,
        clippingMask: clippingMaskUniforms,
        heatmap: heatmapUniforms,
        heatmapTexture: heatmapTextureUniforms,
        hillshade: hillshadeUniforms,
        hillshadePrepare: hillshadePrepareUniforms,
        line: lineUniforms,
        lineGradient: lineGradientUniforms,
        linePattern: linePatternUniforms,
        lineSDF: lineSDFUniforms,
        raster: rasterUniforms,
        symbolIcon: symbolIconUniforms,
        symbolSDF: symbolSDFUniforms,
        background: backgroundUniforms,
        backgroundPattern: backgroundPatternUniforms
      };
      module.exports = { programUniforms };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/gl/index_buffer.js
  var require_index_buffer = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/gl/index_buffer.js"(exports, module) {
      var assert = require_nanoassert();
      var IndexBuffer = class {
        constructor(context, array, dynamicDraw) {
          this.context = context;
          const gl = context.gl;
          this.buffer = gl.createBuffer();
          this.dynamicDraw = Boolean(dynamicDraw);
          this.unbindVAO();
          context.bindElementBuffer.set(this.buffer);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array.arrayBuffer, this.dynamicDraw ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW);
          if (!this.dynamicDraw) {
            delete array.arrayBuffer;
          }
        }
        unbindVAO() {
          if (this.context.extVertexArrayObject) {
            this.context.bindVertexArrayOES.set(null);
          }
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(array) {
          const gl = this.context.gl;
          assert(this.dynamicDraw);
          this.unbindVAO();
          this.bind();
          gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, array.arrayBuffer);
        }
        destroy() {
          const gl = this.context.gl;
          if (this.buffer) {
            gl.deleteBuffer(this.buffer);
            delete this.buffer;
          }
        }
      };
      module.exports = IndexBuffer;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/gl/vertex_buffer.js
  var require_vertex_buffer = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/gl/vertex_buffer.js"(exports, module) {
      var assert = require_nanoassert();
      var AttributeType = {
        Int8: "BYTE",
        Uint8: "UNSIGNED_BYTE",
        Int16: "SHORT",
        Uint16: "UNSIGNED_SHORT",
        Int32: "INT",
        Uint32: "UNSIGNED_INT",
        Float32: "FLOAT"
      };
      var VertexBuffer = class {
        /**
         * @param dynamicDraw Whether this buffer will be repeatedly updated.
         */
        constructor(context, array, attributes, dynamicDraw) {
          this.length = array.length;
          this.attributes = attributes;
          this.itemSize = array.bytesPerElement;
          this.dynamicDraw = dynamicDraw;
          this.context = context;
          const gl = context.gl;
          this.buffer = gl.createBuffer();
          context.bindVertexBuffer.set(this.buffer);
          gl.bufferData(gl.ARRAY_BUFFER, array.arrayBuffer, this.dynamicDraw ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW);
          if (!this.dynamicDraw) {
            delete array.arrayBuffer;
          }
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(array) {
          assert(array.length === this.length);
          const gl = this.context.gl;
          this.bind();
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, array.arrayBuffer);
        }
        enableAttributes(gl, program) {
          for (let j = 0; j < this.attributes.length; j++) {
            const member = this.attributes[j];
            const attribIndex = program.attributes[member.name];
            if (attribIndex !== void 0) {
              gl.enableVertexAttribArray(attribIndex);
            }
          }
        }
        /**
         * Set the attribute pointers in a WebGL context
         * @param gl The WebGL context
         * @param program The active WebGL program
         * @param vertexOffset Index of the starting vertex of the segment
         */
        setVertexAttribPointers(gl, program, vertexOffset) {
          for (let j = 0; j < this.attributes.length; j++) {
            const member = this.attributes[j];
            const attribIndex = program.attributes[member.name];
            if (attribIndex !== void 0) {
              gl.vertexAttribPointer(
                attribIndex,
                member.components,
                gl[AttributeType[member.type]],
                false,
                this.itemSize,
                member.offset + this.itemSize * (vertexOffset || 0)
              );
            }
          }
        }
        /**
         * Destroy the GL buffer bound to the given WebGL context
         */
        destroy() {
          const gl = this.context.gl;
          if (this.buffer) {
            gl.deleteBuffer(this.buffer);
            delete this.buffer;
          }
        }
      };
      module.exports = VertexBuffer;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/gl/value.js
  var require_value = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/gl/value.js"(exports, module) {
      var { Color } = require_style_expressions();
      var ClearColor = class {
        constructor(context) {
          this.context = context;
          this.current = Color.transparent;
        }
        get() {
          return this.current;
        }
        set(v) {
          const c = this.current;
          if (v.r !== c.r || v.g !== c.g || v.b !== c.b || v.a !== c.a) {
            this.context.gl.clearColor(v.r, v.g, v.b, v.a);
            this.current = v;
          }
        }
      };
      var ClearDepth = class {
        constructor(context) {
          this.context = context;
          this.current = 1;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            this.context.gl.clearDepth(v);
            this.current = v;
          }
        }
      };
      var ClearStencil = class {
        constructor(context) {
          this.context = context;
          this.current = 0;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            this.context.gl.clearStencil(v);
            this.current = v;
          }
        }
      };
      var ColorMask = class {
        constructor(context) {
          this.context = context;
          this.current = [true, true, true, true];
        }
        get() {
          return this.current;
        }
        set(v) {
          const c = this.current;
          if (v[0] !== c[0] || v[1] !== c[1] || v[2] !== c[2] || v[3] !== c[3]) {
            this.context.gl.colorMask(v[0], v[1], v[2], v[3]);
            this.current = v;
          }
        }
      };
      var DepthMask = class {
        constructor(context) {
          this.context = context;
          this.current = true;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            this.context.gl.depthMask(v);
            this.current = v;
          }
        }
      };
      var StencilMask = class {
        constructor(context) {
          this.context = context;
          this.current = 255;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            this.context.gl.stencilMask(v);
            this.current = v;
          }
        }
      };
      var StencilFunc = class {
        constructor(context) {
          this.context = context;
          this.current = {
            func: context.gl.ALWAYS,
            ref: 0,
            mask: 255
          };
        }
        get() {
          return this.current;
        }
        set(v) {
          const c = this.current;
          if (v.func !== c.func || v.ref !== c.ref || v.mask !== c.mask) {
            this.context.gl.stencilFunc(v.func, v.ref, v.mask);
            this.current = v;
          }
        }
      };
      var StencilOp = class {
        constructor(context) {
          this.context = context;
          const gl = this.context.gl;
          this.current = [gl.KEEP, gl.KEEP, gl.KEEP];
        }
        get() {
          return this.current;
        }
        set(v) {
          const c = this.current;
          if (v[0] !== c[0] || v[1] !== c[1] || v[2] !== c[2]) {
            this.context.gl.stencilOp(v[0], v[1], v[2]);
            this.current = v;
          }
        }
      };
      var StencilTest = class {
        constructor(context) {
          this.context = context;
          this.current = false;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            const gl = this.context.gl;
            if (v) {
              gl.enable(gl.STENCIL_TEST);
            } else {
              gl.disable(gl.STENCIL_TEST);
            }
            this.current = v;
          }
        }
      };
      var DepthRange = class {
        constructor(context) {
          this.context = context;
          this.current = [0, 1];
        }
        get() {
          return this.current;
        }
        set(v) {
          const c = this.current;
          if (v[0] !== c[0] || v[1] !== c[1]) {
            this.context.gl.depthRange(v[0], v[1]);
            this.current = v;
          }
        }
      };
      var DepthTest = class {
        constructor(context) {
          this.context = context;
          this.current = false;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            const gl = this.context.gl;
            if (v) {
              gl.enable(gl.DEPTH_TEST);
            } else {
              gl.disable(gl.DEPTH_TEST);
            }
            this.current = v;
          }
        }
      };
      var DepthFunc = class {
        constructor(context) {
          this.context = context;
          this.current = context.gl.LESS;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            this.context.gl.depthFunc(v);
            this.current = v;
          }
        }
      };
      var Blend = class {
        constructor(context) {
          this.context = context;
          this.current = false;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            const gl = this.context.gl;
            if (v) {
              gl.enable(gl.BLEND);
            } else {
              gl.disable(gl.BLEND);
            }
            this.current = v;
          }
        }
      };
      var BlendFunc = class {
        constructor(context) {
          this.context = context;
          const gl = this.context.gl;
          this.current = [gl.ONE, gl.ZERO];
        }
        get() {
          return this.current;
        }
        set(v) {
          const c = this.current;
          if (v[0] !== c[0] || v[1] !== c[1]) {
            this.context.gl.blendFunc(v[0], v[1]);
            this.current = v;
          }
        }
      };
      var BlendColor = class {
        constructor(context) {
          this.context = context;
          this.current = Color.transparent;
        }
        get() {
          return this.current;
        }
        set(v) {
          const c = this.current;
          if (v.r !== c.r || v.g !== c.g || v.b !== c.b || v.a !== c.a) {
            this.context.gl.blendColor(v.r, v.g, v.b, v.a);
            this.current = v;
          }
        }
      };
      var CullFace = class {
        constructor(context) {
          this.context = context;
          this.default = false;
          this.current = this.default;
          this.dirty = false;
        }
        get() {
          return this.current;
        }
        setDefault() {
          this.set(this.default);
        }
        set(v) {
          if (this.current !== v || this.dirty === true) {
            const gl = this.context.gl;
            if (v) {
              gl.enable(gl.CULL_FACE);
            } else {
              gl.disable(gl.CULL_FACE);
            }
            this.current = v;
            this.dirty = false;
          }
        }
      };
      var CullFaceSide = class {
        constructor(context) {
          this.context = context;
          const gl = this.context.gl;
          this.default = gl.BACK;
          this.current = this.default;
          this.dirty = false;
        }
        get() {
          return this.current;
        }
        setDefault() {
          this.set(this.default);
        }
        set(v) {
          if (this.current !== v || this.dirty === true) {
            const gl = this.context.gl;
            gl.cullFace(v);
            this.current = v;
            this.dirty = false;
          }
        }
      };
      var FrontFace = class {
        constructor(context) {
          this.context = context;
          const gl = this.context.gl;
          this.default = gl.CCW;
          this.current = this.default;
          this.dirty = false;
        }
        get() {
          return this.current;
        }
        setDefault() {
          this.set(this.default);
        }
        set(v) {
          if (this.current !== v || this.dirty === true) {
            const gl = this.context.gl;
            gl.frontFace(v);
            this.current = v;
            this.dirty = false;
          }
        }
      };
      var Program = class {
        constructor(context) {
          this.context = context;
          this.current = null;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            this.context.gl.useProgram(v);
            this.current = v;
          }
        }
      };
      var ActiveTextureUnit = class {
        constructor(context) {
          this.context = context;
          this.current = context.gl.TEXTURE0;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            this.context.gl.activeTexture(v);
            this.current = v;
          }
        }
      };
      var Viewport = class {
        constructor(context) {
          this.context = context;
          const gl = this.context.gl;
          this.current = [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight];
        }
        get() {
          return this.current;
        }
        set(v) {
          const c = this.current;
          if (v[0] !== c[0] || v[1] !== c[1] || v[2] !== c[2] || v[3] !== c[3]) {
            this.context.gl.viewport(v[0], v[1], v[2], v[3]);
            this.current = v;
          }
        }
      };
      var BindFramebuffer = class {
        constructor(context) {
          this.context = context;
          this.current = null;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            const gl = this.context.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, v);
            this.current = v;
          }
        }
      };
      var BindRenderbuffer = class {
        constructor(context) {
          this.context = context;
          this.current = null;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            const gl = this.context.gl;
            gl.bindRenderbuffer(gl.RENDERBUFFER, v);
            this.current = v;
          }
        }
      };
      var BindTexture = class {
        constructor(context) {
          this.context = context;
          this.current = null;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            const gl = this.context.gl;
            gl.bindTexture(gl.TEXTURE_2D, v);
            this.current = v;
          }
        }
      };
      var BindVertexBuffer = class {
        constructor(context) {
          this.context = context;
          this.current = null;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            const gl = this.context.gl;
            gl.bindBuffer(gl.ARRAY_BUFFER, v);
            this.current = v;
          }
        }
      };
      var BindElementBuffer = class {
        constructor(context) {
          this.context = context;
          this.current = null;
        }
        get() {
          return this.current;
        }
        set(v) {
          const gl = this.context.gl;
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, v);
          this.current = v;
        }
      };
      var BindVertexArrayOES = class {
        constructor(context) {
          this.context = context;
          this.current = null;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v && this.context.extVertexArrayObject) {
            this.context.extVertexArrayObject.bindVertexArrayOES(v);
            this.current = v;
          }
        }
      };
      var PixelStoreUnpack = class {
        constructor(context) {
          this.context = context;
          this.current = 4;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            const gl = this.context.gl;
            gl.pixelStorei(gl.UNPACK_ALIGNMENT, v);
            this.current = v;
          }
        }
      };
      var PixelStoreUnpackPremultiplyAlpha = class {
        constructor(context) {
          this.context = context;
          this.current = false;
        }
        get() {
          return this.current;
        }
        set(v) {
          if (this.current !== v) {
            const gl = this.context.gl;
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, v);
            this.current = v;
          }
        }
      };
      var FramebufferValue = class {
        constructor(context, parent) {
          this.context = context;
          this.current = null;
          this.parent = parent;
        }
        get() {
          return this.current;
        }
      };
      var ColorAttachment = class extends FramebufferValue {
        constructor(context, parent) {
          super(context, parent);
          this.dirty = false;
        }
        set(v) {
          if (this.dirty || this.current !== v) {
            const gl = this.context.gl;
            this.context.bindFramebuffer.set(this.parent);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, v, 0);
            this.current = v;
            this.dirty = false;
          }
        }
        setDirty() {
          this.dirty = true;
        }
      };
      var DepthAttachment = class extends FramebufferValue {
        set(v) {
          if (this.current !== v) {
            const gl = this.context.gl;
            this.context.bindFramebuffer.set(this.parent);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, v);
            this.current = v;
          }
        }
      };
      module.exports = {
        ClearColor,
        ClearDepth,
        ClearStencil,
        ColorMask,
        DepthMask,
        StencilMask,
        StencilFunc,
        StencilOp,
        StencilTest,
        DepthRange,
        DepthTest,
        DepthFunc,
        Blend,
        BlendFunc,
        BlendColor,
        CullFace,
        CullFaceSide,
        FrontFace,
        Program,
        ActiveTextureUnit,
        Viewport,
        BindFramebuffer,
        BindRenderbuffer,
        BindTexture,
        BindVertexBuffer,
        BindElementBuffer,
        BindVertexArrayOES,
        PixelStoreUnpack,
        PixelStoreUnpackPremultiplyAlpha,
        FramebufferValue,
        ColorAttachment,
        DepthAttachment
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/gl/framebuffer.js
  var require_framebuffer = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/gl/framebuffer.js"(exports, module) {
      var { ColorAttachment, DepthAttachment } = require_value();
      var Framebuffer = class {
        constructor(context, width, height) {
          this.context = context;
          this.width = width;
          this.height = height;
          const gl = context.gl;
          const fbo = this.framebuffer = gl.createFramebuffer();
          this.colorAttachment = new ColorAttachment(context, fbo);
          this.depthAttachment = new DepthAttachment(context, fbo);
        }
        destroy() {
          const gl = this.context.gl;
          const texture = this.colorAttachment.get();
          if (texture) gl.deleteTexture(texture);
          const renderbuffer = this.depthAttachment.get();
          if (renderbuffer) gl.deleteRenderbuffer(renderbuffer);
          gl.deleteFramebuffer(this.framebuffer);
        }
      };
      module.exports = Framebuffer;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/gl/color_mode.js
  var require_color_mode = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/gl/color_mode.js"(exports, module) {
      var { Color } = require_style_expressions();
      var ZERO = 0;
      var ONE = 1;
      var ONE_MINUS_SRC_ALPHA = 771;
      var ColorMode = class _ColorMode {
        static Replace = [ONE, ZERO];
        static disabled = new _ColorMode(_ColorMode.Replace, Color.transparent, [false, false, false, false]);
        static unblended = new _ColorMode(_ColorMode.Replace, Color.transparent, [true, true, true, true]);
        static alphaBlended = new _ColorMode([ONE, ONE_MINUS_SRC_ALPHA], Color.transparent, [true, true, true, true]);
        constructor(blendFunction, blendColor, mask) {
          this.blendFunction = blendFunction;
          this.blendColor = blendColor;
          this.mask = mask;
        }
      };
      module.exports = ColorMode;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/gl/context.js
  var require_context = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/gl/context.js"(exports, module) {
      var IndexBuffer = require_index_buffer();
      var VertexBuffer = require_vertex_buffer();
      var Framebuffer = require_framebuffer();
      var ColorMode = require_color_mode();
      var { deepEqual } = require_object();
      var {
        ClearColor,
        ClearDepth,
        ClearStencil,
        ColorMask,
        DepthMask,
        StencilMask,
        StencilFunc,
        StencilOp,
        StencilTest,
        DepthRange,
        DepthTest,
        DepthFunc,
        Blend,
        BlendFunc,
        BlendColor,
        CullFace,
        CullFaceSide,
        FrontFace,
        Program,
        ActiveTextureUnit,
        Viewport,
        BindFramebuffer,
        BindRenderbuffer,
        BindTexture,
        BindVertexBuffer,
        BindElementBuffer,
        BindVertexArrayOES,
        PixelStoreUnpack,
        PixelStoreUnpackPremultiplyAlpha
      } = require_value();
      var Context = class {
        constructor(gl) {
          this.gl = gl;
          this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object");
          this.clearColor = new ClearColor(this);
          this.clearDepth = new ClearDepth(this);
          this.clearStencil = new ClearStencil(this);
          this.colorMask = new ColorMask(this);
          this.depthMask = new DepthMask(this);
          this.stencilMask = new StencilMask(this);
          this.stencilFunc = new StencilFunc(this);
          this.stencilOp = new StencilOp(this);
          this.stencilTest = new StencilTest(this);
          this.depthRange = new DepthRange(this);
          this.depthTest = new DepthTest(this);
          this.depthFunc = new DepthFunc(this);
          this.blend = new Blend(this);
          this.blendFunc = new BlendFunc(this);
          this.blendColor = new BlendColor(this);
          this.cullFace = new CullFace(this);
          this.cullFaceSide = new CullFaceSide(this);
          this.frontFace = new FrontFace(this);
          this.program = new Program(this);
          this.activeTexture = new ActiveTextureUnit(this);
          this.viewport = new Viewport(this);
          this.bindFramebuffer = new BindFramebuffer(this);
          this.bindRenderbuffer = new BindRenderbuffer(this);
          this.bindTexture = new BindTexture(this);
          this.bindVertexBuffer = new BindVertexBuffer(this);
          this.bindElementBuffer = new BindElementBuffer(this);
          this.bindVertexArrayOES = this.extVertexArrayObject && new BindVertexArrayOES(this);
          this.pixelStoreUnpack = new PixelStoreUnpack(this);
          this.pixelStoreUnpackPremultiplyAlpha = new PixelStoreUnpackPremultiplyAlpha(this);
          this.extTextureFilterAnisotropic = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          if (this.extTextureFilterAnisotropic) {
            this.extTextureFilterAnisotropicMax = gl.getParameter(
              this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT
            );
          }
          this.extTextureHalfFloat = gl.getExtension("OES_texture_half_float");
          if (this.extTextureHalfFloat) {
            gl.getExtension("OES_texture_half_float_linear");
          }
        }
        createIndexBuffer(array, dynamicDraw) {
          return new IndexBuffer(this, array, dynamicDraw);
        }
        createVertexBuffer(array, attributes, dynamicDraw) {
          return new VertexBuffer(this, array, attributes, dynamicDraw);
        }
        createRenderbuffer(storageFormat, width, height) {
          const gl = this.gl;
          const rbo = gl.createRenderbuffer();
          this.bindRenderbuffer.set(rbo);
          gl.renderbufferStorage(gl.RENDERBUFFER, storageFormat, width, height);
          this.bindRenderbuffer.set(null);
          return rbo;
        }
        createFramebuffer(width, height) {
          return new Framebuffer(this, width, height);
        }
        clear({ color, depth }) {
          const gl = this.gl;
          let mask = 0;
          if (color) {
            mask |= gl.COLOR_BUFFER_BIT;
            this.clearColor.set(color);
            this.colorMask.set([true, true, true, true]);
          }
          if (typeof depth !== "undefined") {
            mask |= gl.DEPTH_BUFFER_BIT;
            this.depthRange.set([0, 1]);
            this.clearDepth.set(depth);
            this.depthMask.set(true);
          }
          gl.clear(mask);
        }
        setCullFace(cullFaceMode) {
          if (cullFaceMode.enable === false) {
            this.cullFace.set(false);
          } else {
            this.cullFace.set(true);
            this.cullFaceSide.set(cullFaceMode.mode);
            this.frontFace.set(cullFaceMode.frontFace);
          }
        }
        setDepthMode(depthMode) {
          if (depthMode.func === this.gl.ALWAYS && !depthMode.mask) {
            this.depthTest.set(false);
          } else {
            this.depthTest.set(true);
            this.depthFunc.set(depthMode.func);
            this.depthMask.set(depthMode.mask);
            this.depthRange.set(depthMode.range);
          }
        }
        setStencilMode(stencilMode) {
          if (stencilMode.test.func === this.gl.ALWAYS && !stencilMode.mask) {
            this.stencilTest.set(false);
          } else {
            this.stencilTest.set(true);
            this.stencilMask.set(stencilMode.mask);
            this.stencilOp.set([stencilMode.fail, stencilMode.depthFail, stencilMode.pass]);
            this.stencilFunc.set({
              func: stencilMode.test.func,
              ref: stencilMode.ref,
              mask: stencilMode.test.mask
            });
          }
        }
        setColorMode(colorMode) {
          if (deepEqual(colorMode.blendFunction, ColorMode.Replace)) {
            this.blend.set(false);
          } else {
            this.blend.set(true);
            this.blendFunc.set(colorMode.blendFunction);
            this.blendColor.set(colorMode.blendColor);
          }
          this.colorMask.set(colorMode.mask);
        }
      };
      module.exports = Context;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/gl/depth_mode.js
  var require_depth_mode = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/gl/depth_mode.js"(exports, module) {
      var ALWAYS = 519;
      var DepthMode = class {
        // DepthMask enums
        constructor(depthFunc, depthMask, depthRange) {
          this.func = depthFunc;
          this.mask = depthMask;
          this.range = depthRange;
        }
      };
      DepthMode.ReadOnly = false;
      DepthMode.ReadWrite = true;
      DepthMode.disabled = new DepthMode(ALWAYS, DepthMode.ReadOnly, [0, 1]);
      module.exports = DepthMode;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/gl/stencil_mode.js
  var require_stencil_mode = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/gl/stencil_mode.js"(exports, module) {
      var ALWAYS = 519;
      var KEEP = 7680;
      var StencilMode = class {
        constructor(test, ref, mask, fail, depthFail, pass) {
          this.test = test;
          this.ref = ref;
          this.mask = mask;
          this.fail = fail;
          this.depthFail = depthFail;
          this.pass = pass;
        }
      };
      StencilMode.disabled = new StencilMode({ func: ALWAYS, mask: 0 }, 0, 0, KEEP, KEEP, KEEP);
      module.exports = StencilMode;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/gl/cull_face_mode.js
  var require_cull_face_mode = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/gl/cull_face_mode.js"(exports, module) {
      var BACK = 1029;
      var CCW = 2305;
      var CullFaceMode = class {
        enable;
        mode;
        frontFace;
        constructor(enable, mode, frontFace) {
          this.enable = enable;
          this.mode = mode;
          this.frontFace = frontFace;
        }
        static disabled;
        static backCCW;
      };
      CullFaceMode.disabled = new CullFaceMode(false, BACK, CCW);
      CullFaceMode.backCCW = new CullFaceMode(true, BACK, CCW);
      module.exports = CullFaceMode;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/tile_mask.js
  var require_tile_mask = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/tile_mask.js"(exports, module) {
      var { OverscaledTileID, CanonicalTileID } = require_tile_id();
      module.exports = function(renderableTiles, context) {
        const sortedRenderables = renderableTiles.sort((a, b) => {
          return a.tileID.isLessThan(b.tileID) ? -1 : b.tileID.isLessThan(a.tileID) ? 1 : 0;
        });
        for (let i = 0; i < sortedRenderables.length; i++) {
          const mask = {};
          const tile = sortedRenderables[i];
          const childArray = sortedRenderables.slice(i + 1);
          computeTileMasks(
            tile.tileID.wrapped(),
            tile.tileID,
            childArray,
            new OverscaledTileID(0, tile.tileID.wrap + 1, 0, 0, 0),
            mask
          );
          tile.setMask(mask, context);
        }
      };
      function computeTileMasks(rootTile, ref, childArray, lowerBound, mask) {
        for (let i = 0; i < childArray.length; i++) {
          const childTile = childArray[i];
          if (lowerBound.isLessThan(childTile.tileID)) break;
          if (ref.key === childTile.tileID.key) {
            return;
          }
          if (childTile.tileID.isChildOf(ref)) {
            const children = ref.children(Number.POSITIVE_INFINITY);
            for (let j = 0; j < children.length; j++) {
              const child = children[j];
              computeTileMasks(rootTile, child, childArray.slice(i), lowerBound, mask);
            }
            return;
          }
        }
        const diffZ = ref.overscaledZ - rootTile.overscaledZ;
        const maskTileId = new CanonicalTileID(
          diffZ,
          ref.canonical.x - (rootTile.canonical.x << diffZ),
          ref.canonical.y - (rootTile.canonical.y << diffZ)
        );
        mask[maskTileId.key] = mask[maskTileId.key] || maskTileId;
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/draw_collision_debug.js
  var require_draw_collision_debug = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/draw_collision_debug.js"(exports, module) {
      var DepthMode = require_depth_mode();
      var StencilMode = require_stencil_mode();
      var CullFaceMode = require_cull_face_mode();
      var { collisionUniformValues } = require_collision_program();
      module.exports = drawCollisionDebug;
      function drawCollisionDebugGeometry(painter, sourceCache, layer, coords, drawCircles) {
        const context = painter.context;
        const gl = context.gl;
        const program = drawCircles ? painter.useProgram("collisionCircle") : painter.useProgram("collisionBox");
        for (let i = 0; i < coords.length; i++) {
          const coord = coords[i];
          const tile = sourceCache.getTile(coord);
          const bucket = tile.getBucket(layer);
          if (!bucket) continue;
          const buffers = drawCircles ? bucket.collisionCircle : bucket.collisionBox;
          if (!buffers) continue;
          program.draw(
            context,
            drawCircles ? gl.TRIANGLES : gl.LINES,
            DepthMode.disabled,
            StencilMode.disabled,
            painter.colorModeForRenderPass(),
            CullFaceMode.disabled,
            collisionUniformValues(coord.posMatrix, painter.transform, tile),
            layer.id,
            buffers.layoutVertexBuffer,
            buffers.indexBuffer,
            buffers.segments,
            null,
            painter.transform.zoom,
            null,
            null,
            buffers.collisionVertexBuffer
          );
        }
      }
      function drawCollisionDebug(painter, sourceCache, layer, coords) {
        drawCollisionDebugGeometry(painter, sourceCache, layer, coords, false);
        drawCollisionDebugGeometry(painter, sourceCache, layer, coords, true);
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/draw_symbol.js
  var require_draw_symbol = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/draw_symbol.js"(exports, module) {
      var drawCollisionDebug = require_draw_collision_debug();
      var pixelsToTileUnits = require_pixels_to_tile_units();
      var symbolProjection = require_projection();
      var symbolSize = require_symbol_size();
      var { mat4 } = require_gl_matrix();
      var identityMat4 = mat4.identity(new Float32Array(16));
      var properties = require_symbol_style_layer_properties();
      var symbolLayoutProperties = properties.layout;
      var StencilMode = require_stencil_mode();
      var DepthMode = require_depth_mode();
      var CullFaceMode = require_cull_face_mode();
      var { symbolIconUniformValues, symbolSDFUniformValues } = require_symbol_program();
      module.exports = drawSymbols;
      function drawSymbols(painter, sourceCache, layer, coords) {
        if (painter.renderPass !== "translucent") return;
        const stencilMode = StencilMode.disabled;
        const colorMode = painter.colorModeForRenderPass();
        if (layer.paint.get("icon-opacity").constantOr(1) !== 0) {
          drawLayerSymbols(
            painter,
            sourceCache,
            layer,
            coords,
            false,
            layer.paint.get("icon-translate"),
            layer.paint.get("icon-translate-anchor"),
            layer.layout.get("icon-rotation-alignment"),
            layer.layout.get("icon-pitch-alignment"),
            layer.layout.get("icon-keep-upright"),
            stencilMode,
            colorMode
          );
        }
        if (layer.paint.get("text-opacity").constantOr(1) !== 0) {
          drawLayerSymbols(
            painter,
            sourceCache,
            layer,
            coords,
            true,
            layer.paint.get("text-translate"),
            layer.paint.get("text-translate-anchor"),
            layer.layout.get("text-rotation-alignment"),
            layer.layout.get("text-pitch-alignment"),
            layer.layout.get("text-keep-upright"),
            stencilMode,
            colorMode
          );
        }
        if (sourceCache.map.showCollisionBoxes) {
          drawCollisionDebug(painter, sourceCache, layer, coords);
        }
      }
      function drawLayerSymbols(painter, sourceCache, layer, coords, isText, translate, translateAnchor, rotationAlignment, pitchAlignment, keepUpright, stencilMode, colorMode) {
        const context = painter.context;
        const gl = context.gl;
        const tr = painter.transform;
        const rotateWithMap = rotationAlignment === "map";
        const pitchWithMap = pitchAlignment === "map";
        const alongLine = rotateWithMap && layer.layout.get("symbol-placement") !== "point";
        const rotateInShader = rotateWithMap && !pitchWithMap && !alongLine;
        const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);
        let program;
        let size;
        for (const coord of coords) {
          const tile = sourceCache.getTile(coord);
          const bucket = tile.getBucket(layer);
          if (!bucket) continue;
          const buffers = isText ? bucket.text : bucket.icon;
          if (!buffers || !buffers.segments.get().length) continue;
          const programConfiguration = buffers.programConfigurations.get(layer.id);
          const isSDF = isText || bucket.sdfIcons;
          const sizeData = isText ? bucket.textSizeData : bucket.iconSizeData;
          if (!program) {
            program = painter.useProgram(isSDF ? "symbolSDF" : "symbolIcon", programConfiguration);
            size = symbolSize.evaluateSizeForZoom(
              sizeData,
              tr.zoom,
              symbolLayoutProperties.properties[isText ? "text-size" : "icon-size"]
            );
          }
          context.activeTexture.set(gl.TEXTURE0);
          let texSize;
          if (isText) {
            tile.glyphAtlasTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
            texSize = tile.glyphAtlasTexture.size;
          } else {
            const iconScaled = layer.layout.get("icon-size").constantOr(0) !== 1 || bucket.iconsNeedLinear;
            const iconTransformed = pitchWithMap || tr.pitch !== 0;
            tile.imageAtlasTexture.bind(
              isSDF || painter.options.rotating || painter.options.zooming || iconScaled || iconTransformed ? gl.LINEAR : gl.NEAREST,
              gl.CLAMP_TO_EDGE
            );
            texSize = tile.imageAtlasTexture.size;
          }
          const s = pixelsToTileUnits(tile, 1, painter.transform.zoom);
          const labelPlaneMatrix = symbolProjection.getLabelPlaneMatrix(
            coord.posMatrix,
            pitchWithMap,
            rotateWithMap,
            painter.transform,
            s
          );
          const glCoordMatrix = symbolProjection.getGlCoordMatrix(
            coord.posMatrix,
            pitchWithMap,
            rotateWithMap,
            painter.transform,
            s
          );
          if (alongLine) {
            symbolProjection.updateLineLabels(
              bucket,
              coord.posMatrix,
              painter,
              isText,
              labelPlaneMatrix,
              glCoordMatrix,
              pitchWithMap,
              keepUpright
            );
          }
          const matrix = painter.translatePosMatrix(coord.posMatrix, tile, translate, translateAnchor);
          const uLabelPlaneMatrix = alongLine ? identityMat4 : labelPlaneMatrix;
          const uglCoordMatrix = painter.translatePosMatrix(glCoordMatrix, tile, translate, translateAnchor, true);
          let uniformValues;
          if (isSDF) {
            const hasHalo = layer.paint.get(isText ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            uniformValues = symbolSDFUniformValues(
              sizeData.functionType,
              size,
              rotateInShader,
              pitchWithMap,
              painter,
              matrix,
              uLabelPlaneMatrix,
              uglCoordMatrix,
              isText,
              texSize,
              true
            );
            if (hasHalo) {
              drawSymbolElements(buffers, layer, painter, program, depthMode, stencilMode, colorMode, uniformValues);
            }
            uniformValues["u_is_halo"] = 0;
          } else {
            uniformValues = symbolIconUniformValues(
              sizeData.functionType,
              size,
              rotateInShader,
              pitchWithMap,
              painter,
              matrix,
              uLabelPlaneMatrix,
              uglCoordMatrix,
              isText,
              texSize
            );
          }
          drawSymbolElements(buffers, layer, painter, program, depthMode, stencilMode, colorMode, uniformValues);
        }
      }
      function drawSymbolElements(buffers, layer, painter, program, depthMode, stencilMode, colorMode, uniformValues) {
        const context = painter.context;
        const gl = context.gl;
        program.draw(
          context,
          gl.TRIANGLES,
          depthMode,
          stencilMode,
          colorMode,
          CullFaceMode.disabled,
          uniformValues,
          layer.id,
          buffers.layoutVertexBuffer,
          buffers.indexBuffer,
          buffers.segments,
          layer.paint,
          painter.transform.zoom,
          buffers.programConfigurations.get(layer.id),
          buffers.dynamicLayoutVertexBuffer,
          buffers.opacityVertexBuffer
        );
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/draw_circle.js
  var require_draw_circle = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/draw_circle.js"(exports, module) {
      var StencilMode = require_stencil_mode();
      var DepthMode = require_depth_mode();
      var CullFaceMode = require_cull_face_mode();
      var { circleUniformValues } = require_circle_program();
      module.exports = drawCircles;
      function drawCircles(painter, sourceCache, layer, coords) {
        if (painter.renderPass !== "translucent") return;
        const opacity = layer.paint.get("circle-opacity");
        const strokeWidth = layer.paint.get("circle-stroke-width");
        const strokeOpacity = layer.paint.get("circle-stroke-opacity");
        if (opacity.constantOr(1) === 0 && (strokeWidth.constantOr(1) === 0 || strokeOpacity.constantOr(1) === 0)) {
          return;
        }
        const context = painter.context;
        const gl = context.gl;
        const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);
        const stencilMode = StencilMode.disabled;
        const colorMode = painter.colorModeForRenderPass();
        for (let i = 0; i < coords.length; i++) {
          const coord = coords[i];
          const tile = sourceCache.getTile(coord);
          const bucket = tile.getBucket(layer);
          if (!bucket) continue;
          const programConfiguration = bucket.programConfigurations.get(layer.id);
          const program = painter.useProgram("circle", programConfiguration);
          program.draw(
            context,
            gl.TRIANGLES,
            depthMode,
            stencilMode,
            colorMode,
            CullFaceMode.disabled,
            circleUniformValues(painter, coord, tile, layer),
            layer.id,
            bucket.layoutVertexBuffer,
            bucket.indexBuffer,
            bucket.segments,
            layer.paint,
            painter.transform.zoom,
            programConfiguration
          );
        }
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/draw_heatmap.js
  var require_draw_heatmap = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/draw_heatmap.js"(exports, module) {
      var Texture = require_texture();
      var { Color } = require_style_expressions();
      var DepthMode = require_depth_mode();
      var StencilMode = require_stencil_mode();
      var ColorMode = require_color_mode();
      var CullFaceMode = require_cull_face_mode();
      var { heatmapUniformValues, heatmapTextureUniformValues } = require_heatmap_program();
      module.exports = drawHeatmap;
      function drawHeatmap(painter, sourceCache, layer, coords) {
        if (layer.paint.get("heatmap-opacity") === 0) {
          return;
        }
        if (painter.renderPass === "offscreen") {
          const context = painter.context;
          const gl = context.gl;
          const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);
          const stencilMode = StencilMode.disabled;
          const colorMode = new ColorMode([gl.ONE, gl.ONE], Color.transparent, [true, true, true, true]);
          bindFramebuffer(context, painter, layer);
          context.clear({ color: Color.transparent });
          for (let i = 0; i < coords.length; i++) {
            const coord = coords[i];
            if (sourceCache.hasRenderableParent(coord)) continue;
            const tile = sourceCache.getTile(coord);
            const bucket = tile.getBucket(layer);
            if (!bucket) continue;
            const programConfiguration = bucket.programConfigurations.get(layer.id);
            const program = painter.useProgram("heatmap", programConfiguration);
            const { zoom } = painter.transform;
            program.draw(
              context,
              gl.TRIANGLES,
              depthMode,
              stencilMode,
              colorMode,
              CullFaceMode.disabled,
              heatmapUniformValues(coord.posMatrix, tile, zoom, layer.paint.get("heatmap-intensity")),
              layer.id,
              bucket.layoutVertexBuffer,
              bucket.indexBuffer,
              bucket.segments,
              layer.paint,
              painter.transform.zoom,
              programConfiguration
            );
          }
          context.viewport.set([0, 0, painter.width, painter.height]);
        } else if (painter.renderPass === "translucent") {
          painter.context.setColorMode(painter.colorModeForRenderPass());
          renderTextureToMap(painter, layer);
        }
      }
      function bindFramebuffer(context, painter, layer) {
        const gl = context.gl;
        context.activeTexture.set(gl.TEXTURE1);
        context.viewport.set([0, 0, painter.width / 4, painter.height / 4]);
        let fbo = layer.heatmapFbo;
        if (!fbo) {
          const texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          fbo = layer.heatmapFbo = context.createFramebuffer(painter.width / 4, painter.height / 4);
          bindTextureToFramebuffer(context, painter, texture, fbo);
        } else {
          gl.bindTexture(gl.TEXTURE_2D, fbo.colorAttachment.get());
          context.bindFramebuffer.set(fbo.framebuffer);
        }
      }
      function bindTextureToFramebuffer(context, painter, texture, fbo) {
        const gl = context.gl;
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          painter.width / 4,
          painter.height / 4,
          0,
          gl.RGBA,
          context.extTextureHalfFloat ? context.extTextureHalfFloat.HALF_FLOAT_OES : gl.UNSIGNED_BYTE,
          null
        );
        fbo.colorAttachment.set(texture);
        if (context.extTextureHalfFloat && gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
          context.extTextureHalfFloat = null;
          fbo.colorAttachment.setDirty();
          bindTextureToFramebuffer(context, painter, texture, fbo);
        }
      }
      function renderTextureToMap(painter, layer) {
        const context = painter.context;
        const gl = context.gl;
        const fbo = layer.heatmapFbo;
        if (!fbo) return;
        context.activeTexture.set(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, fbo.colorAttachment.get());
        context.activeTexture.set(gl.TEXTURE1);
        let colorRampTexture = layer.colorRampTexture;
        if (!colorRampTexture) {
          colorRampTexture = layer.colorRampTexture = new Texture(context, layer.colorRamp, gl.RGBA);
        }
        colorRampTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
        painter.useProgram("heatmapTexture").draw(
          context,
          gl.TRIANGLES,
          DepthMode.disabled,
          StencilMode.disabled,
          painter.colorModeForRenderPass(),
          CullFaceMode.disabled,
          heatmapTextureUniformValues(painter, layer, 0, 1),
          layer.id,
          painter.viewportBuffer,
          painter.quadTriangleIndexBuffer,
          painter.viewportSegments,
          layer.paint,
          painter.transform.zoom
        );
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/draw_line.js
  var require_draw_line = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/draw_line.js"(exports, module) {
      var DepthMode = require_depth_mode();
      var Texture = require_texture();
      var CullFaceMode = require_cull_face_mode();
      var {
        lineUniformValues,
        linePatternUniformValues,
        lineSDFUniformValues,
        lineGradientUniformValues
      } = require_line_program();
      module.exports = function drawLine(painter, sourceCache, layer, coords) {
        if (painter.renderPass !== "translucent") return;
        const opacity = layer.paint.get("line-opacity");
        const width = layer.paint.get("line-width");
        if (opacity.constantOr(1) === 0 || width.constantOr(1) === 0) return;
        const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);
        const colorMode = painter.colorModeForRenderPass();
        const dasharray = layer.paint.get("line-dasharray");
        const patternProperty = layer.paint.get("line-pattern");
        const image = patternProperty.constantOr(1);
        const gradient = layer.paint.get("line-gradient");
        const crossfade = layer.getCrossfadeParameters();
        const programId = dasharray ? "lineSDF" : image ? "linePattern" : gradient ? "lineGradient" : "line";
        const context = painter.context;
        const gl = context.gl;
        let firstTile = true;
        if (gradient) {
          context.activeTexture.set(gl.TEXTURE0);
          let gradientTexture = layer.gradientTexture;
          if (!layer.gradient) return;
          if (!gradientTexture) gradientTexture = layer.gradientTexture = new Texture(context, layer.gradient, gl.RGBA);
          gradientTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
        }
        for (const coord of coords) {
          const tile = sourceCache.getTile(coord);
          if (image && !tile.patternsLoaded()) continue;
          const bucket = tile.getBucket(layer);
          if (!bucket) continue;
          const programConfiguration = bucket.programConfigurations.get(layer.id);
          const prevProgram = painter.context.program.get();
          const program = painter.useProgram(programId, programConfiguration);
          const programChanged = firstTile || program.program !== prevProgram;
          const constantPattern = patternProperty.constantOr(null);
          if (constantPattern && tile.imageAtlas) {
            const posTo = tile.imageAtlas.patternPositions[constantPattern.to];
            const posFrom = tile.imageAtlas.patternPositions[constantPattern.from];
            if (posTo && posFrom) programConfiguration.setConstantPatternPositions(posTo, posFrom);
          }
          const uniformValues = dasharray ? lineSDFUniformValues(painter, tile, layer, dasharray, crossfade) : image ? linePatternUniformValues(painter, tile, layer, crossfade) : gradient ? lineGradientUniformValues(painter, tile, layer) : lineUniformValues(painter, tile, layer);
          if (dasharray && (programChanged || painter.lineAtlas.dirty)) {
            context.activeTexture.set(gl.TEXTURE0);
            painter.lineAtlas.bind(context);
          } else if (image) {
            tile.imageAtlasTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
            programConfiguration.updatePatternPaintBuffers(crossfade);
          }
          program.draw(
            context,
            gl.TRIANGLES,
            depthMode,
            painter.stencilModeForClipping(coord),
            colorMode,
            CullFaceMode.disabled,
            uniformValues,
            layer.id,
            bucket.layoutVertexBuffer,
            bucket.indexBuffer,
            bucket.segments,
            layer.paint,
            painter.transform.zoom,
            programConfiguration
          );
          firstTile = false;
        }
      };
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/draw_fill.js
  var require_draw_fill = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/draw_fill.js"(exports, module) {
      var { Color } = require_style_expressions();
      var DepthMode = require_depth_mode();
      var CullFaceMode = require_cull_face_mode();
      var {
        fillUniformValues,
        fillPatternUniformValues,
        fillOutlineUniformValues,
        fillOutlinePatternUniformValues
      } = require_fill_program();
      module.exports = drawFill;
      function drawFill(painter, sourceCache, layer, coords) {
        const color = layer.paint.get("fill-color");
        const opacity = layer.paint.get("fill-opacity");
        if (opacity.constantOr(1) === 0) {
          return;
        }
        const colorMode = painter.colorModeForRenderPass();
        const pattern = layer.paint.get("fill-pattern");
        const pass = painter.opaquePassEnabledForLayer() && !pattern.constantOr(1) && color.constantOr(Color.transparent).a === 1 && opacity.constantOr(0) === 1 ? "opaque" : "translucent";
        if (painter.renderPass === pass) {
          const depthMode = painter.depthModeForSublayer(
            1,
            painter.renderPass === "opaque" ? DepthMode.ReadWrite : DepthMode.ReadOnly
          );
          drawFillTiles(painter, sourceCache, layer, coords, depthMode, colorMode, false);
        }
        if (painter.renderPass === "translucent" && layer.paint.get("fill-antialias")) {
          const depthMode = painter.depthModeForSublayer(
            layer.getPaintProperty("fill-outline-color") ? 2 : 0,
            DepthMode.ReadOnly
          );
          drawFillTiles(painter, sourceCache, layer, coords, depthMode, colorMode, true);
        }
      }
      function drawFillTiles(painter, sourceCache, layer, coords, depthMode, colorMode, isOutline) {
        const gl = painter.context.gl;
        const patternProperty = layer.paint.get("fill-pattern");
        const image = patternProperty?.constantOr(1);
        const crossfade = layer.getCrossfadeParameters();
        let drawMode;
        let programName;
        let uniformValues;
        let indexBuffer;
        let segments;
        if (!isOutline) {
          programName = image ? "fillPattern" : "fill";
          drawMode = gl.TRIANGLES;
        } else {
          programName = image && !layer.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline";
          drawMode = gl.LINES;
        }
        for (const coord of coords) {
          const tile = sourceCache.getTile(coord);
          if (image && !tile.patternsLoaded()) continue;
          const bucket = tile.getBucket(layer);
          if (!bucket) continue;
          const programConfiguration = bucket.programConfigurations.get(layer.id);
          const program = painter.useProgram(programName, programConfiguration);
          if (image) {
            painter.context.activeTexture.set(gl.TEXTURE0);
            tile.imageAtlasTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
            programConfiguration.updatePatternPaintBuffers(crossfade);
          }
          const constantPattern = patternProperty.constantOr(null);
          if (constantPattern && tile.imageAtlas) {
            const posTo = tile.imageAtlas.patternPositions[constantPattern.to];
            const posFrom = tile.imageAtlas.patternPositions[constantPattern.from];
            if (posTo && posFrom) programConfiguration.setConstantPatternPositions(posTo, posFrom);
          }
          const tileMatrix = painter.translatePosMatrix(
            coord.posMatrix,
            tile,
            layer.paint.get("fill-translate"),
            layer.paint.get("fill-translate-anchor")
          );
          if (!isOutline) {
            indexBuffer = bucket.indexBuffer;
            segments = bucket.segments;
            uniformValues = image ? fillPatternUniformValues(tileMatrix, painter, crossfade, tile) : fillUniformValues(tileMatrix);
          } else {
            indexBuffer = bucket.indexBuffer2;
            segments = bucket.segments2;
            const drawingBufferSize = [gl.drawingBufferWidth, gl.drawingBufferHeight];
            uniformValues = programName === "fillOutlinePattern" && image ? fillOutlinePatternUniformValues(tileMatrix, painter, crossfade, tile, drawingBufferSize) : fillOutlineUniformValues(tileMatrix, drawingBufferSize);
          }
          program.draw(
            painter.context,
            drawMode,
            depthMode,
            painter.stencilModeForClipping(coord),
            colorMode,
            CullFaceMode.disabled,
            uniformValues,
            layer.id,
            bucket.layoutVertexBuffer,
            indexBuffer,
            segments,
            layer.paint,
            painter.transform.zoom,
            programConfiguration
          );
        }
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/draw_fill_extrusion.js
  var require_draw_fill_extrusion = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/draw_fill_extrusion.js"(exports, module) {
      var DepthMode = require_depth_mode();
      var StencilMode = require_stencil_mode();
      var ColorMode = require_color_mode();
      var CullFaceMode = require_cull_face_mode();
      var { fillExtrusionUniformValues, fillExtrusionPatternUniformValues } = require_fill_extrusion_program();
      module.exports = draw;
      function draw(painter, source, layer, coords) {
        const opacity = layer.paint.get("fill-extrusion-opacity");
        if (opacity === 0) {
          return;
        }
        if (painter.renderPass === "translucent") {
          const depthMode = new DepthMode(painter.context.gl.LEQUAL, DepthMode.ReadWrite, painter.depthRangeFor3D);
          if (opacity === 1 && !layer.paint.get("fill-extrusion-pattern").constantOr(1)) {
            const colorMode = painter.colorModeForRenderPass();
            drawExtrusionTiles(painter, source, layer, coords, depthMode, StencilMode.disabled, colorMode);
          } else {
            drawExtrusionTiles(painter, source, layer, coords, depthMode, StencilMode.disabled, ColorMode.disabled);
            drawExtrusionTiles(
              painter,
              source,
              layer,
              coords,
              depthMode,
              painter.stencilModeFor3D(),
              painter.colorModeForRenderPass()
            );
          }
        }
      }
      function drawExtrusionTiles(painter, source, layer, coords, depthMode, stencilMode, colorMode) {
        const context = painter.context;
        const gl = context.gl;
        const patternProperty = layer.paint.get("fill-extrusion-pattern");
        const image = patternProperty.constantOr(1);
        const crossfade = layer.getCrossfadeParameters();
        const opacity = layer.paint.get("fill-extrusion-opacity");
        for (const coord of coords) {
          const tile = source.getTile(coord);
          const bucket = tile.getBucket(layer);
          if (!bucket) continue;
          const programConfiguration = bucket.programConfigurations.get(layer.id);
          const program = painter.useProgram(image ? "fillExtrusionPattern" : "fillExtrusion", programConfiguration);
          if (image) {
            painter.context.activeTexture.set(gl.TEXTURE0);
            tile.imageAtlasTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
            programConfiguration.updatePatternPaintBuffers(crossfade);
          }
          const constantPattern = patternProperty.constantOr(null);
          if (constantPattern && tile.imageAtlas) {
            const posTo = tile.imageAtlas.patternPositions[constantPattern.to];
            const posFrom = tile.imageAtlas.patternPositions[constantPattern.from];
            if (posTo && posFrom) programConfiguration.setConstantPatternPositions(posTo, posFrom);
          }
          const matrix = painter.translatePosMatrix(
            coord.posMatrix,
            tile,
            layer.paint.get("fill-extrusion-translate"),
            layer.paint.get("fill-extrusion-translate-anchor")
          );
          const shouldUseVerticalGradient = layer.paint.get("fill-extrusion-vertical-gradient");
          const uniformValues = image ? fillExtrusionPatternUniformValues(matrix, painter, shouldUseVerticalGradient, opacity, coord, crossfade, tile) : fillExtrusionUniformValues(matrix, painter, shouldUseVerticalGradient, opacity);
          program.draw(
            context,
            context.gl.TRIANGLES,
            depthMode,
            stencilMode,
            colorMode,
            CullFaceMode.backCCW,
            uniformValues,
            layer.id,
            bucket.layoutVertexBuffer,
            bucket.indexBuffer,
            bucket.segments,
            layer.paint,
            painter.transform.zoom,
            programConfiguration
          );
        }
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/draw_hillshade.js
  var require_draw_hillshade = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/draw_hillshade.js"(exports, module) {
      var Texture = require_texture();
      var StencilMode = require_stencil_mode();
      var DepthMode = require_depth_mode();
      var CullFaceMode = require_cull_face_mode();
      var { hillshadeUniformValues, hillshadeUniformPrepareValues } = require_hillshade_program();
      module.exports = drawHillshade;
      function drawHillshade(painter, sourceCache, layer, tileIDs) {
        if (painter.renderPass !== "offscreen" && painter.renderPass !== "translucent") return;
        const context = painter.context;
        const sourceMaxZoom = sourceCache.getSource().maxzoom;
        const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);
        const stencilMode = StencilMode.disabled;
        const colorMode = painter.colorModeForRenderPass();
        for (const tileID of tileIDs) {
          const tile = sourceCache.getTile(tileID);
          if (tile.needsHillshadePrepare && painter.renderPass === "offscreen") {
            prepareHillshade(painter, tile, layer, sourceMaxZoom, depthMode, stencilMode, colorMode);
          } else if (painter.renderPass === "translucent") {
            renderHillshade(painter, tile, layer, depthMode, stencilMode, colorMode);
          }
        }
        context.viewport.set([0, 0, painter.width, painter.height]);
      }
      function renderHillshade(painter, tile, layer, depthMode, stencilMode, colorMode) {
        const context = painter.context;
        const gl = context.gl;
        const fbo = tile.fbo;
        if (!fbo) return;
        const program = painter.useProgram("hillshade");
        context.activeTexture.set(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, fbo.colorAttachment.get());
        const uniformValues = hillshadeUniformValues(painter, tile, layer);
        if (tile.maskedBoundsBuffer && tile.maskedIndexBuffer && tile.segments) {
          program.draw(
            context,
            gl.TRIANGLES,
            depthMode,
            stencilMode,
            colorMode,
            CullFaceMode.disabled,
            uniformValues,
            layer.id,
            tile.maskedBoundsBuffer,
            tile.maskedIndexBuffer,
            tile.segments
          );
        } else {
          program.draw(
            context,
            gl.TRIANGLES,
            depthMode,
            stencilMode,
            colorMode,
            CullFaceMode.disabled,
            uniformValues,
            layer.id,
            painter.rasterBoundsBuffer,
            painter.quadTriangleIndexBuffer,
            painter.rasterBoundsSegments
          );
        }
      }
      function prepareHillshade(painter, tile, layer, sourceMaxZoom, depthMode, stencilMode, colorMode) {
        const context = painter.context;
        const gl = context.gl;
        if (tile.dem?.data) {
          const tileSize = tile.dem.dim;
          const textureStride = tile.dem.stride;
          const pixelData = tile.dem.getPixels();
          context.activeTexture.set(gl.TEXTURE1);
          context.pixelStoreUnpackPremultiplyAlpha.set(false);
          tile.demTexture = tile.demTexture || painter.getTileTexture(textureStride);
          if (tile.demTexture) {
            const demTexture = tile.demTexture;
            demTexture.update(pixelData, { premultiply: false });
            demTexture.bind(gl.NEAREST, gl.CLAMP_TO_EDGE);
          } else {
            tile.demTexture = new Texture(context, pixelData, gl.RGBA, { premultiply: false });
            tile.demTexture.bind(gl.NEAREST, gl.CLAMP_TO_EDGE);
          }
          context.activeTexture.set(gl.TEXTURE0);
          let fbo = tile.fbo;
          if (!fbo) {
            const renderTexture = new Texture(context, { width: tileSize, height: tileSize, data: null }, gl.RGBA);
            renderTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
            fbo = tile.fbo = context.createFramebuffer(tileSize, tileSize);
            fbo.colorAttachment.set(renderTexture.texture);
          }
          context.bindFramebuffer.set(fbo.framebuffer);
          context.viewport.set([0, 0, tileSize, tileSize]);
          painter.useProgram("hillshadePrepare").draw(
            context,
            gl.TRIANGLES,
            depthMode,
            stencilMode,
            colorMode,
            CullFaceMode.disabled,
            hillshadeUniformPrepareValues(tile, sourceMaxZoom),
            layer.id,
            painter.rasterBoundsBuffer,
            painter.quadTriangleIndexBuffer,
            painter.rasterBoundsSegments
          );
          tile.needsHillshadePrepare = false;
        }
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/draw_raster.js
  var require_draw_raster = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/draw_raster.js"(exports, module) {
      var { clamp } = require_util();
      var ImageSource = require_image_source();
      var browser = require_browser();
      var StencilMode = require_stencil_mode();
      var DepthMode = require_depth_mode();
      var CullFaceMode = require_cull_face_mode();
      var { rasterUniformValues } = require_raster_program();
      module.exports = drawRaster;
      function drawRaster(painter, sourceCache, layer, coords) {
        if (painter.renderPass !== "translucent") return;
        if (layer.paint.get("raster-opacity") === 0) return;
        const context = painter.context;
        const gl = context.gl;
        const source = sourceCache.getSource();
        const program = painter.useProgram("raster");
        const stencilMode = StencilMode.disabled;
        const colorMode = painter.colorModeForRenderPass();
        const minTileZ = coords.length && coords[0].overscaledZ;
        const align = !painter.options.moving;
        for (const coord of coords) {
          const depthMode = painter.depthModeForSublayer(
            coord.overscaledZ - minTileZ,
            layer.paint.get("raster-opacity") === 1 ? DepthMode.ReadWrite : DepthMode.ReadOnly,
            gl.LESS
          );
          const tile = sourceCache.getTile(coord);
          const posMatrix = painter.transform.calculatePosMatrix(coord.toUnwrapped(), align);
          tile.registerFadeDuration(layer.paint.get("raster-fade-duration"));
          const parentTile = sourceCache.findLoadedParent(coord, 0);
          const fade = getFadeValues(tile, parentTile, sourceCache, layer, painter.transform);
          let parentScaleBy;
          let parentTL;
          const textureFilter = layer.paint.get("raster-resampling") === "nearest" ? gl.NEAREST : gl.LINEAR;
          context.activeTexture.set(gl.TEXTURE0);
          tile.texture.bind(textureFilter, gl.CLAMP_TO_EDGE, gl.LINEAR_MIPMAP_NEAREST);
          context.activeTexture.set(gl.TEXTURE1);
          if (parentTile) {
            parentTile.texture.bind(textureFilter, gl.CLAMP_TO_EDGE, gl.LINEAR_MIPMAP_NEAREST);
            parentScaleBy = 2 ** (parentTile.tileID.overscaledZ - tile.tileID.overscaledZ);
            parentTL = [tile.tileID.canonical.x * parentScaleBy % 1, tile.tileID.canonical.y * parentScaleBy % 1];
          } else {
            tile.texture.bind(textureFilter, gl.CLAMP_TO_EDGE, gl.LINEAR_MIPMAP_NEAREST);
          }
          const uniformValues = rasterUniformValues(posMatrix, parentTL || [0, 0], parentScaleBy || 1, fade, layer);
          if (source instanceof ImageSource) {
            program.draw(
              context,
              gl.TRIANGLES,
              depthMode,
              stencilMode,
              colorMode,
              CullFaceMode.disabled,
              uniformValues,
              layer.id,
              source.boundsBuffer,
              painter.quadTriangleIndexBuffer,
              source.boundsSegments
            );
          } else if (tile.maskedBoundsBuffer && tile.maskedIndexBuffer && tile.segments) {
            program.draw(
              context,
              gl.TRIANGLES,
              depthMode,
              stencilMode,
              colorMode,
              CullFaceMode.disabled,
              uniformValues,
              layer.id,
              tile.maskedBoundsBuffer,
              tile.maskedIndexBuffer,
              tile.segments,
              layer.paint,
              painter.transform.zoom
            );
          } else {
            program.draw(
              context,
              gl.TRIANGLES,
              depthMode,
              stencilMode,
              colorMode,
              CullFaceMode.disabled,
              uniformValues,
              layer.id,
              painter.rasterBoundsBuffer,
              painter.quadTriangleIndexBuffer,
              painter.rasterBoundsSegments
            );
          }
        }
      }
      function getFadeValues(tile, parentTile, sourceCache, layer, transform) {
        const fadeDuration = layer.paint.get("raster-fade-duration");
        if (fadeDuration > 0) {
          const now = browser.now();
          const sinceTile = (now - tile.timeAdded) / fadeDuration;
          const sinceParent = parentTile ? (now - parentTile.timeAdded) / fadeDuration : -1;
          const source = sourceCache.getSource();
          const idealZ = transform.coveringZoomLevel({
            tileSize: source.tileSize,
            roundZoom: source.roundZoom
          });
          const fadeIn = !parentTile || Math.abs(parentTile.tileID.overscaledZ - idealZ) > Math.abs(tile.tileID.overscaledZ - idealZ);
          const childOpacity = fadeIn && tile.refreshedUponExpiration ? 1 : clamp(fadeIn ? sinceTile : 1 - sinceParent, 0, 1);
          if (tile.refreshedUponExpiration && sinceTile >= 1) tile.refreshedUponExpiration = false;
          if (parentTile) {
            return {
              opacity: 1,
              mix: 1 - childOpacity
            };
          }
          return {
            opacity: childOpacity,
            mix: 0
          };
        }
        return {
          opacity: 1,
          mix: 0
        };
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/draw_background.js
  var require_draw_background = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/draw_background.js"(exports, module) {
      var StencilMode = require_stencil_mode();
      var DepthMode = require_depth_mode();
      var CullFaceMode = require_cull_face_mode();
      var { backgroundUniformValues, backgroundPatternUniformValues } = require_background_program();
      module.exports = drawBackground;
      function drawBackground(painter, sourceCache, layer) {
        const color = layer.paint.get("background-color");
        const opacity = layer.paint.get("background-opacity");
        if (opacity === 0) return;
        const context = painter.context;
        const gl = context.gl;
        const transform = painter.transform;
        const tileSize = transform.tileSize;
        const image = layer.paint.get("background-pattern");
        if (painter.isPatternMissing(image)) return;
        const pass = !image && color.a === 1 && opacity === 1 && painter.opaquePassEnabledForLayer() ? "opaque" : "translucent";
        if (painter.renderPass !== pass) return;
        const stencilMode = StencilMode.disabled;
        const depthMode = painter.depthModeForSublayer(0, pass === "opaque" ? DepthMode.ReadWrite : DepthMode.ReadOnly);
        const colorMode = painter.colorModeForRenderPass();
        const program = painter.useProgram(image ? "backgroundPattern" : "background");
        const tileIDs = transform.coveringTiles({ tileSize });
        if (image) {
          context.activeTexture.set(gl.TEXTURE0);
          painter.imageManager.bind(painter.context);
        }
        const crossfade = layer.getCrossfadeParameters();
        for (const tileID of tileIDs) {
          const matrix = painter.transform.calculatePosMatrix(tileID.toUnwrapped());
          const uniformValues = image ? backgroundPatternUniformValues(matrix, opacity, painter, image, { tileID, tileSize }, crossfade) : backgroundUniformValues(matrix, opacity, color);
          program.draw(
            context,
            gl.TRIANGLES,
            depthMode,
            stencilMode,
            colorMode,
            CullFaceMode.disabled,
            uniformValues,
            layer.id,
            painter.tileExtentBuffer,
            painter.quadTriangleIndexBuffer,
            painter.tileExtentSegments
          );
        }
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/draw_debug.js
  var require_draw_debug = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/draw_debug.js"(exports, module) {
      var { mat4 } = require_gl_matrix();
      var EXTENT = require_extent();
      var { PosArray } = require_array_types();
      var { LineIndexArray } = require_index_array_type();
      var posAttributes = require_pos_attributes();
      var SegmentVector = require_segment();
      var DepthMode = require_depth_mode();
      var StencilMode = require_stencil_mode();
      var CullFaceMode = require_cull_face_mode();
      var { debugUniformValues } = require_debug_program();
      var { Color } = require_style_expressions();
      module.exports = drawDebug;
      function drawDebug(painter, sourceCache, coords) {
        for (let i = 0; i < coords.length; i++) {
          drawDebugTile(painter, sourceCache, coords[i]);
        }
      }
      function drawDebugTile(painter, sourceCache, coord) {
        const context = painter.context;
        const gl = context.gl;
        const posMatrix = coord.posMatrix;
        const program = painter.useProgram("debug");
        const depthMode = DepthMode.disabled;
        const stencilMode = StencilMode.disabled;
        const colorMode = painter.colorModeForRenderPass();
        const id = "$debug";
        program.draw(
          context,
          gl.LINE_STRIP,
          depthMode,
          stencilMode,
          colorMode,
          CullFaceMode.disabled,
          debugUniformValues(posMatrix, Color.red),
          id,
          painter.debugBuffer,
          painter.tileBorderIndexBuffer,
          painter.debugSegments
        );
        const tileRawData = sourceCache.getTileByID(coord.key).latestRawTileData;
        const tileByteLength = tileRawData?.byteLength || 0;
        const tileSizeKb = Math.floor(tileByteLength / 1024);
        const vertices = createTextVertices(`${coord.toString()} ${tileSizeKb}kb`, 50, 200, 5);
        const debugTextArray = new PosArray();
        const debugTextIndices = new LineIndexArray();
        for (let v = 0; v < vertices.length; v += 2) {
          debugTextArray.emplaceBack(vertices[v], vertices[v + 1]);
          debugTextIndices.emplaceBack(v, v + 1);
        }
        const debugTextBuffer = context.createVertexBuffer(debugTextArray, posAttributes.members);
        const debugTextIndexBuffer = context.createIndexBuffer(debugTextIndices);
        const debugTextSegment = SegmentVector.simpleSegment(0, 0, debugTextArray.length / 2, debugTextArray.length / 2);
        const tileSize = sourceCache.getTile(coord).tileSize;
        const onePixel = EXTENT / (2 ** (painter.transform.zoom - coord.overscaledZ) * tileSize);
        const translations = [
          [-1, -1],
          [-1, 1],
          [1, -1],
          [1, 1]
        ];
        for (let i = 0; i < translations.length; i++) {
          const translation = translations[i];
          program.draw(
            context,
            gl.LINES,
            depthMode,
            stencilMode,
            colorMode,
            CullFaceMode.disabled,
            debugUniformValues(
              mat4.translate([], posMatrix, [onePixel * translation[0], onePixel * translation[1], 0]),
              Color.white
            ),
            id,
            debugTextBuffer,
            debugTextIndexBuffer,
            debugTextSegment
          );
        }
        program.draw(
          context,
          gl.LINES,
          depthMode,
          stencilMode,
          colorMode,
          CullFaceMode.disabled,
          debugUniformValues(posMatrix, Color.black),
          id,
          debugTextBuffer,
          debugTextIndexBuffer,
          debugTextSegment
        );
      }
      var simplexFont = {
        " ": [16, []],
        "!": [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
        '"': [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]],
        "#": [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]],
        $: [
          20,
          [
            8,
            25,
            8,
            -4,
            -1,
            -1,
            12,
            25,
            12,
            -4,
            -1,
            -1,
            17,
            18,
            15,
            20,
            12,
            21,
            8,
            21,
            5,
            20,
            3,
            18,
            3,
            16,
            4,
            14,
            5,
            13,
            7,
            12,
            13,
            10,
            15,
            9,
            16,
            8,
            17,
            6,
            17,
            3,
            15,
            1,
            12,
            0,
            8,
            0,
            5,
            1,
            3,
            3
          ]
        ],
        "%": [
          24,
          [
            21,
            21,
            3,
            0,
            -1,
            -1,
            8,
            21,
            10,
            19,
            10,
            17,
            9,
            15,
            7,
            14,
            5,
            14,
            3,
            16,
            3,
            18,
            4,
            20,
            6,
            21,
            8,
            21,
            10,
            20,
            13,
            19,
            16,
            19,
            19,
            20,
            21,
            21,
            -1,
            -1,
            17,
            7,
            15,
            6,
            14,
            4,
            14,
            2,
            16,
            0,
            18,
            0,
            20,
            1,
            21,
            3,
            21,
            5,
            19,
            7,
            17,
            7
          ]
        ],
        "&": [
          26,
          [
            23,
            12,
            23,
            13,
            22,
            14,
            21,
            14,
            20,
            13,
            19,
            11,
            17,
            6,
            15,
            3,
            13,
            1,
            11,
            0,
            7,
            0,
            5,
            1,
            4,
            2,
            3,
            4,
            3,
            6,
            4,
            8,
            5,
            9,
            12,
            13,
            13,
            14,
            14,
            16,
            14,
            18,
            13,
            20,
            11,
            21,
            9,
            20,
            8,
            18,
            8,
            16,
            9,
            13,
            11,
            10,
            16,
            3,
            18,
            1,
            20,
            0,
            22,
            0,
            23,
            1,
            23,
            2
          ]
        ],
        "'": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]],
        "(": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]],
        ")": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]],
        "*": [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]],
        "+": [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]],
        ",": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
        "-": [26, [4, 9, 22, 9]],
        ".": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
        "/": [22, [20, 25, 2, -7]],
        0: [
          20,
          [
            9,
            21,
            6,
            20,
            4,
            17,
            3,
            12,
            3,
            9,
            4,
            4,
            6,
            1,
            9,
            0,
            11,
            0,
            14,
            1,
            16,
            4,
            17,
            9,
            17,
            12,
            16,
            17,
            14,
            20,
            11,
            21,
            9,
            21
          ]
        ],
        1: [20, [6, 17, 8, 18, 11, 21, 11, 0]],
        2: [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]],
        3: [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
        4: [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]],
        5: [
          20,
          [
            15,
            21,
            5,
            21,
            4,
            12,
            5,
            13,
            8,
            14,
            11,
            14,
            14,
            13,
            16,
            11,
            17,
            8,
            17,
            6,
            16,
            3,
            14,
            1,
            11,
            0,
            8,
            0,
            5,
            1,
            4,
            2,
            3,
            4
          ]
        ],
        6: [
          20,
          [
            16,
            18,
            15,
            20,
            12,
            21,
            10,
            21,
            7,
            20,
            5,
            17,
            4,
            12,
            4,
            7,
            5,
            3,
            7,
            1,
            10,
            0,
            11,
            0,
            14,
            1,
            16,
            3,
            17,
            6,
            17,
            7,
            16,
            10,
            14,
            12,
            11,
            13,
            10,
            13,
            7,
            12,
            5,
            10,
            4,
            7
          ]
        ],
        7: [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]],
        8: [
          20,
          [
            8,
            21,
            5,
            20,
            4,
            18,
            4,
            16,
            5,
            14,
            7,
            13,
            11,
            12,
            14,
            11,
            16,
            9,
            17,
            7,
            17,
            4,
            16,
            2,
            15,
            1,
            12,
            0,
            8,
            0,
            5,
            1,
            4,
            2,
            3,
            4,
            3,
            7,
            4,
            9,
            6,
            11,
            9,
            12,
            13,
            13,
            15,
            14,
            16,
            16,
            16,
            18,
            15,
            20,
            12,
            21,
            8,
            21
          ]
        ],
        9: [
          20,
          [
            16,
            14,
            15,
            11,
            13,
            9,
            10,
            8,
            9,
            8,
            6,
            9,
            4,
            11,
            3,
            14,
            3,
            15,
            4,
            18,
            6,
            20,
            9,
            21,
            10,
            21,
            13,
            20,
            15,
            18,
            16,
            14,
            16,
            9,
            15,
            4,
            13,
            1,
            10,
            0,
            8,
            0,
            5,
            1,
            4,
            3
          ]
        ],
        ":": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
        ";": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
        "<": [24, [20, 18, 4, 9, 20, 0]],
        "=": [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]],
        ">": [24, [4, 18, 20, 9, 4, 0]],
        "?": [
          18,
          [
            3,
            16,
            3,
            17,
            4,
            19,
            5,
            20,
            7,
            21,
            11,
            21,
            13,
            20,
            14,
            19,
            15,
            17,
            15,
            15,
            14,
            13,
            13,
            12,
            9,
            10,
            9,
            7,
            -1,
            -1,
            9,
            2,
            8,
            1,
            9,
            0,
            10,
            1,
            9,
            2
          ]
        ],
        "@": [
          27,
          [
            18,
            13,
            17,
            15,
            15,
            16,
            12,
            16,
            10,
            15,
            9,
            14,
            8,
            11,
            8,
            8,
            9,
            6,
            11,
            5,
            14,
            5,
            16,
            6,
            17,
            8,
            -1,
            -1,
            12,
            16,
            10,
            14,
            9,
            11,
            9,
            8,
            10,
            6,
            11,
            5,
            -1,
            -1,
            18,
            16,
            17,
            8,
            17,
            6,
            19,
            5,
            21,
            5,
            23,
            7,
            24,
            10,
            24,
            12,
            23,
            15,
            22,
            17,
            20,
            19,
            18,
            20,
            15,
            21,
            12,
            21,
            9,
            20,
            7,
            19,
            5,
            17,
            4,
            15,
            3,
            12,
            3,
            9,
            4,
            6,
            5,
            4,
            7,
            2,
            9,
            1,
            12,
            0,
            15,
            0,
            18,
            1,
            20,
            2,
            21,
            3,
            -1,
            -1,
            19,
            16,
            18,
            8,
            18,
            6,
            19,
            5
          ]
        ],
        A: [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]],
        B: [
          21,
          [
            4,
            21,
            4,
            0,
            -1,
            -1,
            4,
            21,
            13,
            21,
            16,
            20,
            17,
            19,
            18,
            17,
            18,
            15,
            17,
            13,
            16,
            12,
            13,
            11,
            -1,
            -1,
            4,
            11,
            13,
            11,
            16,
            10,
            17,
            9,
            18,
            7,
            18,
            4,
            17,
            2,
            16,
            1,
            13,
            0,
            4,
            0
          ]
        ],
        C: [
          21,
          [
            18,
            16,
            17,
            18,
            15,
            20,
            13,
            21,
            9,
            21,
            7,
            20,
            5,
            18,
            4,
            16,
            3,
            13,
            3,
            8,
            4,
            5,
            5,
            3,
            7,
            1,
            9,
            0,
            13,
            0,
            15,
            1,
            17,
            3,
            18,
            5
          ]
        ],
        D: [
          21,
          [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]
        ],
        E: [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]],
        F: [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]],
        G: [
          21,
          [
            18,
            16,
            17,
            18,
            15,
            20,
            13,
            21,
            9,
            21,
            7,
            20,
            5,
            18,
            4,
            16,
            3,
            13,
            3,
            8,
            4,
            5,
            5,
            3,
            7,
            1,
            9,
            0,
            13,
            0,
            15,
            1,
            17,
            3,
            18,
            5,
            18,
            8,
            -1,
            -1,
            13,
            8,
            18,
            8
          ]
        ],
        H: [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]],
        I: [8, [4, 21, 4, 0]],
        J: [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]],
        K: [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]],
        L: [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]],
        M: [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]],
        N: [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]],
        O: [
          22,
          [
            9,
            21,
            7,
            20,
            5,
            18,
            4,
            16,
            3,
            13,
            3,
            8,
            4,
            5,
            5,
            3,
            7,
            1,
            9,
            0,
            13,
            0,
            15,
            1,
            17,
            3,
            18,
            5,
            19,
            8,
            19,
            13,
            18,
            16,
            17,
            18,
            15,
            20,
            13,
            21,
            9,
            21
          ]
        ],
        P: [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]],
        Q: [
          22,
          [
            9,
            21,
            7,
            20,
            5,
            18,
            4,
            16,
            3,
            13,
            3,
            8,
            4,
            5,
            5,
            3,
            7,
            1,
            9,
            0,
            13,
            0,
            15,
            1,
            17,
            3,
            18,
            5,
            19,
            8,
            19,
            13,
            18,
            16,
            17,
            18,
            15,
            20,
            13,
            21,
            9,
            21,
            -1,
            -1,
            12,
            4,
            18,
            -2
          ]
        ],
        R: [
          21,
          [
            4,
            21,
            4,
            0,
            -1,
            -1,
            4,
            21,
            13,
            21,
            16,
            20,
            17,
            19,
            18,
            17,
            18,
            15,
            17,
            13,
            16,
            12,
            13,
            11,
            4,
            11,
            -1,
            -1,
            11,
            11,
            18,
            0
          ]
        ],
        S: [
          20,
          [
            17,
            18,
            15,
            20,
            12,
            21,
            8,
            21,
            5,
            20,
            3,
            18,
            3,
            16,
            4,
            14,
            5,
            13,
            7,
            12,
            13,
            10,
            15,
            9,
            16,
            8,
            17,
            6,
            17,
            3,
            15,
            1,
            12,
            0,
            8,
            0,
            5,
            1,
            3,
            3
          ]
        ],
        T: [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]],
        U: [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]],
        V: [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]],
        W: [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]],
        X: [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]],
        Y: [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]],
        Z: [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]],
        "[": [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]],
        "\\": [14, [0, 21, 14, -3]],
        "]": [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]],
        "^": [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]],
        _: [16, [0, -2, 16, -2]],
        "`": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]],
        a: [
          19,
          [
            15,
            14,
            15,
            0,
            -1,
            -1,
            15,
            11,
            13,
            13,
            11,
            14,
            8,
            14,
            6,
            13,
            4,
            11,
            3,
            8,
            3,
            6,
            4,
            3,
            6,
            1,
            8,
            0,
            11,
            0,
            13,
            1,
            15,
            3
          ]
        ],
        b: [
          19,
          [
            4,
            21,
            4,
            0,
            -1,
            -1,
            4,
            11,
            6,
            13,
            8,
            14,
            11,
            14,
            13,
            13,
            15,
            11,
            16,
            8,
            16,
            6,
            15,
            3,
            13,
            1,
            11,
            0,
            8,
            0,
            6,
            1,
            4,
            3
          ]
        ],
        c: [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        d: [
          19,
          [
            15,
            21,
            15,
            0,
            -1,
            -1,
            15,
            11,
            13,
            13,
            11,
            14,
            8,
            14,
            6,
            13,
            4,
            11,
            3,
            8,
            3,
            6,
            4,
            3,
            6,
            1,
            8,
            0,
            11,
            0,
            13,
            1,
            15,
            3
          ]
        ],
        e: [
          18,
          [
            3,
            8,
            15,
            8,
            15,
            10,
            14,
            12,
            13,
            13,
            11,
            14,
            8,
            14,
            6,
            13,
            4,
            11,
            3,
            8,
            3,
            6,
            4,
            3,
            6,
            1,
            8,
            0,
            11,
            0,
            13,
            1,
            15,
            3
          ]
        ],
        f: [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]],
        g: [
          19,
          [
            15,
            14,
            15,
            -2,
            14,
            -5,
            13,
            -6,
            11,
            -7,
            8,
            -7,
            6,
            -6,
            -1,
            -1,
            15,
            11,
            13,
            13,
            11,
            14,
            8,
            14,
            6,
            13,
            4,
            11,
            3,
            8,
            3,
            6,
            4,
            3,
            6,
            1,
            8,
            0,
            11,
            0,
            13,
            1,
            15,
            3
          ]
        ],
        h: [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
        i: [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]],
        j: [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]],
        k: [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]],
        l: [8, [4, 21, 4, 0]],
        m: [
          30,
          [
            4,
            14,
            4,
            0,
            -1,
            -1,
            4,
            10,
            7,
            13,
            9,
            14,
            12,
            14,
            14,
            13,
            15,
            10,
            15,
            0,
            -1,
            -1,
            15,
            10,
            18,
            13,
            20,
            14,
            23,
            14,
            25,
            13,
            26,
            10,
            26,
            0
          ]
        ],
        n: [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
        o: [
          19,
          [
            8,
            14,
            6,
            13,
            4,
            11,
            3,
            8,
            3,
            6,
            4,
            3,
            6,
            1,
            8,
            0,
            11,
            0,
            13,
            1,
            15,
            3,
            16,
            6,
            16,
            8,
            15,
            11,
            13,
            13,
            11,
            14,
            8,
            14
          ]
        ],
        p: [
          19,
          [
            4,
            14,
            4,
            -7,
            -1,
            -1,
            4,
            11,
            6,
            13,
            8,
            14,
            11,
            14,
            13,
            13,
            15,
            11,
            16,
            8,
            16,
            6,
            15,
            3,
            13,
            1,
            11,
            0,
            8,
            0,
            6,
            1,
            4,
            3
          ]
        ],
        q: [
          19,
          [
            15,
            14,
            15,
            -7,
            -1,
            -1,
            15,
            11,
            13,
            13,
            11,
            14,
            8,
            14,
            6,
            13,
            4,
            11,
            3,
            8,
            3,
            6,
            4,
            3,
            6,
            1,
            8,
            0,
            11,
            0,
            13,
            1,
            15,
            3
          ]
        ],
        r: [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]],
        s: [
          17,
          [
            14,
            11,
            13,
            13,
            10,
            14,
            7,
            14,
            4,
            13,
            3,
            11,
            4,
            9,
            6,
            8,
            11,
            7,
            13,
            6,
            14,
            4,
            14,
            3,
            13,
            1,
            10,
            0,
            7,
            0,
            4,
            1,
            3,
            3
          ]
        ],
        t: [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]],
        u: [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]],
        v: [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]],
        w: [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]],
        x: [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]],
        y: [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]],
        z: [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]],
        "{": [
          14,
          [
            9,
            25,
            7,
            24,
            6,
            23,
            5,
            21,
            5,
            19,
            6,
            17,
            7,
            16,
            8,
            14,
            8,
            12,
            6,
            10,
            -1,
            -1,
            7,
            24,
            6,
            22,
            6,
            20,
            7,
            18,
            8,
            17,
            9,
            15,
            9,
            13,
            8,
            11,
            4,
            9,
            8,
            7,
            9,
            5,
            9,
            3,
            8,
            1,
            7,
            0,
            6,
            -2,
            6,
            -4,
            7,
            -6,
            -1,
            -1,
            6,
            8,
            8,
            6,
            8,
            4,
            7,
            2,
            6,
            1,
            5,
            -1,
            5,
            -3,
            6,
            -5,
            7,
            -6,
            9,
            -7
          ]
        ],
        "|": [8, [4, 25, 4, -7]],
        "}": [
          14,
          [
            5,
            25,
            7,
            24,
            8,
            23,
            9,
            21,
            9,
            19,
            8,
            17,
            7,
            16,
            6,
            14,
            6,
            12,
            8,
            10,
            -1,
            -1,
            7,
            24,
            8,
            22,
            8,
            20,
            7,
            18,
            6,
            17,
            5,
            15,
            5,
            13,
            6,
            11,
            10,
            9,
            6,
            7,
            5,
            5,
            5,
            3,
            6,
            1,
            7,
            0,
            8,
            -2,
            8,
            -4,
            7,
            -6,
            -1,
            -1,
            8,
            8,
            6,
            6,
            6,
            4,
            7,
            2,
            8,
            1,
            9,
            -1,
            9,
            -3,
            8,
            -5,
            7,
            -6,
            5,
            -7
          ]
        ],
        "~": [
          24,
          [
            3,
            6,
            3,
            8,
            4,
            11,
            6,
            12,
            8,
            12,
            10,
            11,
            14,
            8,
            16,
            7,
            18,
            7,
            20,
            8,
            21,
            10,
            -1,
            -1,
            3,
            8,
            4,
            10,
            6,
            11,
            8,
            11,
            10,
            10,
            14,
            7,
            16,
            6,
            18,
            6,
            20,
            7,
            21,
            10,
            21,
            12
          ]
        ]
      };
      function createTextVertices(text, left, baseline, scale) {
        scale = scale || 1;
        const strokes = [];
        let i;
        let len;
        let j;
        let len2;
        let glyph;
        let x;
        let y;
        let prev;
        for (i = 0, len = text.length; i < len; i++) {
          glyph = simplexFont[text[i]];
          if (!glyph) continue;
          prev = null;
          for (j = 0, len2 = glyph[1].length; j < len2; j += 2) {
            if (glyph[1][j] === -1 && glyph[1][j + 1] === -1) {
              prev = null;
            } else {
              x = left + glyph[1][j] * scale;
              y = baseline - glyph[1][j + 1] * scale;
              if (prev) {
                strokes.push(prev.x, prev.y, x, y);
              }
              prev = { x, y };
            }
          }
          left += glyph[0] * scale;
        }
        return strokes;
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/render/painter.js
  var require_painter = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/render/painter.js"(exports, module) {
      var browser = require_browser();
      var { mat4 } = require_gl_matrix();
      var SourceCache = require_source_cache();
      var EXTENT = require_extent();
      var pixelsToTileUnits = require_pixels_to_tile_units();
      var SegmentVector = require_segment();
      var { RasterBoundsArray, PosArray, TriangleIndexArray, LineStripIndexArray } = require_array_types();
      var rasterBoundsAttributes = require_raster_bounds_attributes();
      var posAttributes = require_pos_attributes();
      var ProgramConfiguration = require_program_configuration();
      var CrossTileSymbolIndex = require_cross_tile_symbol_index();
      var shaders = require_shaders();
      var Program = require_program();
      var { programUniforms } = require_program_uniforms();
      var Context = require_context();
      var DepthMode = require_depth_mode();
      var StencilMode = require_stencil_mode();
      var ColorMode = require_color_mode();
      var CullFaceMode = require_cull_face_mode();
      var updateTileMasks = require_tile_mask();
      var { clippingMaskUniformValues } = require_clipping_mask_program();
      var { Color } = require_style_expressions();
      var symbol = require_draw_symbol();
      var circle = require_draw_circle();
      var heatmap = require_draw_heatmap();
      var line = require_draw_line();
      var fill = require_draw_fill();
      var fillExtrusion = require_draw_fill_extrusion();
      var hillshade = require_draw_hillshade();
      var raster = require_draw_raster();
      var background = require_draw_background();
      var debug = require_draw_debug();
      var draw = {
        symbol,
        circle,
        heatmap,
        line,
        fill,
        "fill-extrusion": fillExtrusion,
        hillshade,
        raster,
        background,
        debug
      };
      var Painter = class {
        constructor(gl, transform) {
          this.context = new Context(gl);
          this.transform = transform;
          this._tileTextures = {};
          this.setup();
          this.numSublayers = SourceCache.maxUnderzooming + SourceCache.maxOverzooming + 1;
          this.depthEpsilon = 1 / 2 ** 16;
          this.depthRboNeedsClear = true;
          this.emptyProgramConfiguration = new ProgramConfiguration();
          this.crossTileSymbolIndex = new CrossTileSymbolIndex();
        }
        /*
         * Update the GL viewport, projection matrix, and transforms to compensate
         * for a new width and height value.
         */
        resize(width, height) {
          const gl = this.context.gl;
          this.width = width * browser.devicePixelRatio;
          this.height = height * browser.devicePixelRatio;
          this.context.viewport.set([0, 0, this.width, this.height]);
          if (this.style) {
            for (const layerId of this.style._order) {
              this.style._layers[layerId].resize();
            }
          }
          if (this.depthRbo) {
            gl.deleteRenderbuffer(this.depthRbo);
            this.depthRbo = null;
          }
        }
        setup() {
          const context = this.context;
          const tileExtentArray = new PosArray();
          tileExtentArray.emplaceBack(0, 0);
          tileExtentArray.emplaceBack(EXTENT, 0);
          tileExtentArray.emplaceBack(0, EXTENT);
          tileExtentArray.emplaceBack(EXTENT, EXTENT);
          this.tileExtentBuffer = context.createVertexBuffer(tileExtentArray, posAttributes.members);
          this.tileExtentSegments = SegmentVector.simpleSegment(0, 0, 4, 2);
          const debugArray = new PosArray();
          debugArray.emplaceBack(0, 0);
          debugArray.emplaceBack(EXTENT, 0);
          debugArray.emplaceBack(0, EXTENT);
          debugArray.emplaceBack(EXTENT, EXTENT);
          this.debugBuffer = context.createVertexBuffer(debugArray, posAttributes.members);
          this.debugSegments = SegmentVector.simpleSegment(0, 0, 4, 5);
          const rasterBoundsArray = new RasterBoundsArray();
          rasterBoundsArray.emplaceBack(0, 0, 0, 0);
          rasterBoundsArray.emplaceBack(EXTENT, 0, EXTENT, 0);
          rasterBoundsArray.emplaceBack(0, EXTENT, 0, EXTENT);
          rasterBoundsArray.emplaceBack(EXTENT, EXTENT, EXTENT, EXTENT);
          this.rasterBoundsBuffer = context.createVertexBuffer(rasterBoundsArray, rasterBoundsAttributes.members);
          this.rasterBoundsSegments = SegmentVector.simpleSegment(0, 0, 4, 2);
          const viewportArray = new PosArray();
          viewportArray.emplaceBack(0, 0);
          viewportArray.emplaceBack(1, 0);
          viewportArray.emplaceBack(0, 1);
          viewportArray.emplaceBack(1, 1);
          this.viewportBuffer = context.createVertexBuffer(viewportArray, posAttributes.members);
          this.viewportSegments = SegmentVector.simpleSegment(0, 0, 4, 2);
          const tileLineStripIndices = new LineStripIndexArray();
          tileLineStripIndices.emplaceBack(0);
          tileLineStripIndices.emplaceBack(1);
          tileLineStripIndices.emplaceBack(3);
          tileLineStripIndices.emplaceBack(2);
          tileLineStripIndices.emplaceBack(0);
          this.tileBorderIndexBuffer = context.createIndexBuffer(tileLineStripIndices);
          const quadTriangleIndices = new TriangleIndexArray();
          quadTriangleIndices.emplaceBack(0, 1, 2);
          quadTriangleIndices.emplaceBack(2, 1, 3);
          this.quadTriangleIndexBuffer = context.createIndexBuffer(quadTriangleIndices);
          const gl = this.context.gl;
          this.stencilClearMode = new StencilMode({ func: gl.ALWAYS, mask: 0 }, 0, 255, gl.ZERO, gl.ZERO, gl.ZERO);
        }
        /*
         * Reset the drawing canvas by clearing the stencil buffer so that we can draw
         * new tiles at the same location, while retaining previously drawn pixels.
         */
        clearStencil() {
          const context = this.context;
          const gl = context.gl;
          this.nextStencilID = 1;
          this.currentStencilSource = void 0;
          const matrix = mat4.create();
          mat4.ortho(matrix, 0, this.width, this.height, 0, 0, 1);
          mat4.scale(matrix, matrix, [gl.drawingBufferWidth, gl.drawingBufferHeight, 0]);
          this.useProgram("clippingMask").draw(
            context,
            gl.TRIANGLES,
            DepthMode.disabled,
            this.stencilClearMode,
            ColorMode.disabled,
            CullFaceMode.disabled,
            clippingMaskUniformValues(matrix),
            "$clipping",
            this.viewportBuffer,
            this.quadTriangleIndexBuffer,
            this.viewportSegments
          );
        }
        _renderTileClippingMasks(layer, tileIDs) {
          if (this.currentStencilSource === layer.source || !layer.isTileClipped() || !tileIDs || !tileIDs.length) return;
          this.currentStencilSource = layer.source;
          const context = this.context;
          const gl = context.gl;
          if (this.nextStencilID + tileIDs.length > 256) {
            this.clearStencil();
          }
          context.setColorMode(ColorMode.disabled);
          context.setDepthMode(DepthMode.disabled);
          const program = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const tileID of tileIDs) {
            const id = this._tileClippingMaskIDs[tileID.key] = this.nextStencilID++;
            program.draw(
              context,
              gl.TRIANGLES,
              DepthMode.disabled,
              // Tests will always pass, and ref value will be written to stencil buffer.
              new StencilMode({ func: gl.ALWAYS, mask: 0 }, id, 255, gl.KEEP, gl.KEEP, gl.REPLACE),
              ColorMode.disabled,
              CullFaceMode.disabled,
              clippingMaskUniformValues(tileID.posMatrix),
              "$clipping",
              this.tileExtentBuffer,
              this.quadTriangleIndexBuffer,
              this.tileExtentSegments
            );
          }
        }
        stencilModeFor3D() {
          if (this.nextStencilID + 1 > 256) {
            this.clearStencil();
          }
          const id = this.nextStencilID++;
          const gl = this.context.gl;
          return new StencilMode({ func: gl.NOTEQUAL, mask: 255 }, id, 255, gl.KEEP, gl.KEEP, gl.REPLACE);
        }
        stencilModeForClipping(tileID) {
          const gl = this.context.gl;
          return new StencilMode(
            { func: gl.EQUAL, mask: 255 },
            this._tileClippingMaskIDs[tileID.key],
            0,
            gl.KEEP,
            gl.KEEP,
            gl.REPLACE
          );
        }
        colorModeForRenderPass() {
          const gl = this.context.gl;
          if (this._showOverdrawInspector) {
            const numOverdrawSteps = 8;
            const a = 1 / numOverdrawSteps;
            return new ColorMode([gl.CONSTANT_COLOR, gl.ONE], new Color(a, a, a, 0), [true, true, true, true]);
          }
          if (this.renderPass === "opaque") {
            return ColorMode.unblended;
          }
          return ColorMode.alphaBlended;
        }
        depthModeForSublayer(n, mask, func) {
          if (!this.opaquePassEnabledForLayer()) return DepthMode.disabled;
          const depth = 1 - ((1 + this.currentLayer) * this.numSublayers + n) * this.depthEpsilon;
          return new DepthMode(func || this.context.gl.LEQUAL, mask, [depth, depth]);
        }
        /*
         * The opaque pass and 3D layers both use the depth buffer.
         * Layers drawn above 3D layers need to be drawn using the
         * painter's algorithm so that they appear above 3D features.
         * This returns true for layers that can be drawn using the
         * opaque pass.
         */
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(style, options) {
          this.style = style;
          this.options = options;
          this.lineAtlas = style.lineAtlas;
          this.imageManager = style.imageManager;
          this.glyphManager = style.glyphManager;
          this.symbolFadeChange = style.placement.symbolFadeChange(browser.now());
          const layerIds = this.style._order;
          const sourceCaches = this.style.sourceCaches;
          for (const id in sourceCaches) {
            const sourceCache = sourceCaches[id];
            if (sourceCache.used) {
              sourceCache.prepare(this.context);
            }
          }
          const coordsAscending = {};
          const coordsDescending = {};
          const coordsDescendingSymbol = {};
          for (const id in sourceCaches) {
            const sourceCache = sourceCaches[id];
            coordsAscending[id] = sourceCache.getVisibleCoordinates();
            coordsDescending[id] = coordsAscending[id].slice().reverse();
            coordsDescendingSymbol[id] = sourceCache.getVisibleCoordinates(true).reverse();
          }
          for (const id in sourceCaches) {
            const sourceCache = sourceCaches[id];
            const source = sourceCache.getSource();
            if (source.type !== "raster" && source.type !== "raster-dem") continue;
            const visibleTiles = [];
            for (const coord of coordsAscending[id]) visibleTiles.push(sourceCache.getTile(coord));
            updateTileMasks(visibleTiles, this.context);
          }
          this.opaquePassCutoff = Number.POSITIVE_INFINITY;
          for (let i = 0; i < layerIds.length; i++) {
            const layerId = layerIds[i];
            if (this.style._layers[layerId].is3D()) {
              this.opaquePassCutoff = i;
              break;
            }
          }
          this.renderPass = "offscreen";
          this.depthRboNeedsClear = true;
          for (const layerId of layerIds) {
            const layer = this.style._layers[layerId];
            if (!layer.hasOffscreenPass() || layer.isHidden(this.transform.zoom)) continue;
            const coords = coordsDescending[layer.source];
            if (!coords.length) continue;
            this.renderLayer(this, sourceCaches[layer.source], layer, coords);
          }
          this.context.bindFramebuffer.set(null);
          this.context.clear({ color: options.showOverdrawInspector ? Color.black : Color.transparent, depth: 1 });
          this.clearStencil();
          this._showOverdrawInspector = options.showOverdrawInspector;
          this.depthRangeFor3D = [0, 1 - (style._order.length + 2) * this.numSublayers * this.depthEpsilon];
          this.renderPass = "opaque";
          for (this.currentLayer = layerIds.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            const layer = this.style._layers[layerIds[this.currentLayer]];
            const sourceCache = sourceCaches[layer.source];
            const coords = coordsAscending[layer.source];
            this._renderTileClippingMasks(layer, coords);
            this.renderLayer(this, sourceCache, layer, coords);
          }
          this.renderPass = "translucent";
          for (this.currentLayer = 0; this.currentLayer < layerIds.length; this.currentLayer++) {
            const layer = this.style._layers[layerIds[this.currentLayer]];
            const sourceCache = sourceCaches[layer.source];
            const coords = (layer.type === "symbol" ? coordsDescendingSymbol : coordsDescending)[layer.source];
            this._renderTileClippingMasks(layer, coordsAscending[layer.source]);
            this.renderLayer(this, sourceCache, layer, coords);
          }
          if (this.options.showTileBoundaries) {
            for (const id in sourceCaches) {
              draw.debug(this, sourceCaches[id], coordsAscending[id]);
              break;
            }
          }
        }
        setupOffscreenDepthRenderbuffer() {
          const context = this.context;
          if (!this.depthRbo) {
            this.depthRbo = context.createRenderbuffer(context.gl.DEPTH_COMPONENT16, this.width, this.height);
          }
        }
        renderLayer(painter, sourceCache, layer, coords) {
          if (layer.isHidden(this.transform.zoom)) return;
          if (layer.type !== "background" && !coords.length) return;
          this.id = layer.id;
          draw[layer.type](painter, sourceCache, layer, coords);
        }
        /**
         * Transform a matrix to incorporate the *-translate and *-translate-anchor properties into it.
         * @param inViewportPixelUnitsUnits True when the units accepted by the matrix are in viewport pixels instead of tile units.
         * @returns {Float32Array} matrix
         */
        translatePosMatrix(matrix, tile, translate, translateAnchor, inViewportPixelUnitsUnits) {
          if (!translate[0] && !translate[1]) return matrix;
          const angle = inViewportPixelUnitsUnits ? translateAnchor === "map" ? this.transform.angle : 0 : translateAnchor === "viewport" ? -this.transform.angle : 0;
          if (angle) {
            const sinA = Math.sin(angle);
            const cosA = Math.cos(angle);
            translate = [translate[0] * cosA - translate[1] * sinA, translate[0] * sinA + translate[1] * cosA];
          }
          const translation = [
            inViewportPixelUnitsUnits ? translate[0] : pixelsToTileUnits(tile, translate[0], this.transform.zoom),
            inViewportPixelUnitsUnits ? translate[1] : pixelsToTileUnits(tile, translate[1], this.transform.zoom),
            0
          ];
          const translatedMatrix = new Float32Array(16);
          mat4.translate(translatedMatrix, matrix, translation);
          return translatedMatrix;
        }
        saveTileTexture(texture) {
          const textures = this._tileTextures[texture.size[0]];
          if (!textures) {
            this._tileTextures[texture.size[0]] = [texture];
          } else {
            textures.push(texture);
          }
        }
        getTileTexture(size) {
          const textures = this._tileTextures[size];
          return textures && textures.length > 0 ? textures.pop() : null;
        }
        /**
         * Checks whether a pattern image is needed, and if it is, whether it is not loaded.
         *
         * @returns true if a needed image is missing and rendering needs to be skipped.
         */
        isPatternMissing(image) {
          if (!image) return false;
          const imagePosA = this.imageManager.getPattern(image.from);
          const imagePosB = this.imageManager.getPattern(image.to);
          return !imagePosA || !imagePosB;
        }
        useProgram(name, programConfiguration = this.emptyProgramConfiguration) {
          this.cache = this.cache || {};
          const key = `${name}${programConfiguration.cacheKey || ""}${this._showOverdrawInspector ? "/overdraw" : ""}`;
          if (!this.cache[key]) {
            this.cache[key] = new Program(
              this.context,
              shaders[name],
              programConfiguration,
              programUniforms[name],
              this._showOverdrawInspector
            );
          }
          return this.cache[key];
        }
      };
      module.exports = Painter;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/tile_cover.js
  var require_tile_cover = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/tile_cover.js"(exports, module) {
      var { OverscaledTileID } = require_tile_id();
      module.exports = tileCover;
      function tileCover(z, bounds2, actualZ, renderWorldCopies) {
        if (renderWorldCopies === void 0) {
          renderWorldCopies = true;
        }
        const tiles = 1 << z;
        const t = {};
        function scanLine(x0, x1, y) {
          let x;
          let w;
          let wx;
          let coord;
          if (y >= 0 && y <= tiles) {
            for (x = x0; x < x1; x++) {
              w = Math.floor(x / tiles);
              wx = (x % tiles + tiles) % tiles;
              if (w === 0 || renderWorldCopies === true) {
                coord = new OverscaledTileID(actualZ, w, z, wx, y);
                t[coord.key] = coord;
              }
            }
          }
        }
        scanTriangle(bounds2[0], bounds2[1], bounds2[2], 0, tiles, scanLine);
        scanTriangle(bounds2[2], bounds2[3], bounds2[0], 0, tiles, scanLine);
        return Object.keys(t).map((id) => {
          return t[id];
        });
      }
      function edge(a, b) {
        if (a.row > b.row) {
          const t = a;
          a = b;
          b = t;
        }
        return {
          x0: a.column,
          y0: a.row,
          x1: b.column,
          y1: b.row,
          dx: b.column - a.column,
          dy: b.row - a.row
        };
      }
      function scanSpans(e0, e1, ymin, ymax, scanLine) {
        const y0 = Math.max(ymin, Math.floor(e1.y0));
        const y1 = Math.min(ymax, Math.ceil(e1.y1));
        if (e0.x0 === e1.x0 && e0.y0 === e1.y0 ? e0.x0 + e1.dy / e0.dy * e0.dx < e1.x1 : e0.x1 - e1.dy / e0.dy * e0.dx < e1.x0) {
          const t = e0;
          e0 = e1;
          e1 = t;
        }
        const m0 = e0.dx / e0.dy;
        const m1 = e1.dx / e1.dy;
        const d0 = e0.dx > 0;
        const d1 = e1.dx < 0;
        for (let y = y0; y < y1; y++) {
          const x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0;
          const x1 = m1 * Math.max(0, Math.min(e1.dy, y + d1 - e1.y0)) + e1.x0;
          scanLine(Math.floor(x1), Math.ceil(x0), y);
        }
      }
      function scanTriangle(a, b, c, ymin, ymax, scanLine) {
        let ab = edge(a, b);
        let bc = edge(b, c);
        let ca = edge(c, a);
        let t;
        if (ab.dy > bc.dy) {
          t = ab;
          ab = bc;
          bc = t;
        }
        if (ab.dy > ca.dy) {
          t = ab;
          ab = ca;
          ca = t;
        }
        if (bc.dy > ca.dy) {
          t = bc;
          bc = ca;
          ca = t;
        }
        if (ab.dy) scanSpans(ca, ab, ymin, ymax, scanLine);
        if (bc.dy) scanSpans(ca, bc, ymin, ymax, scanLine);
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/geo/transform.js
  var require_transform = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/geo/transform.js"(exports, module) {
      var LngLat = require_lng_lat();
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      var Coordinate = require_coordinate();
      var { wrap, clamp } = require_util();
      var interpolate2 = require_interpolate3();
      var tileCover = require_tile_cover();
      var { UnwrappedTileID } = require_tile_id();
      var EXTENT = require_extent();
      var { vec4, mat4, mat2 } = require_gl_matrix();
      var Transform = class _Transform {
        constructor(minZoom, maxZoom, renderWorldCopies) {
          this.tileSize = 512;
          this.maxValidLatitude = 85.051129;
          this._renderWorldCopies = renderWorldCopies === void 0 ? true : renderWorldCopies;
          this._minZoom = minZoom || 0;
          this._maxZoom = maxZoom || 22;
          this.latRange = [-this.maxValidLatitude, this.maxValidLatitude];
          this.width = 0;
          this.height = 0;
          this._center = new LngLat(0, 0);
          this.zoom = 0;
          this.angle = 0;
          this._fov = 0.6435011087932844;
          this._pitch = 0;
          this._unmodified = true;
          this._posMatrixCache = {};
          this._alignedPosMatrixCache = {};
        }
        clone() {
          const clone = new _Transform(this._minZoom, this._maxZoom, this._renderWorldCopies);
          clone.tileSize = this.tileSize;
          clone.latRange = this.latRange;
          clone.width = this.width;
          clone.height = this.height;
          clone._center = this._center;
          clone.zoom = this.zoom;
          clone.angle = this.angle;
          clone._fov = this._fov;
          clone._pitch = this._pitch;
          clone._unmodified = this._unmodified;
          clone._calcMatrices();
          return clone;
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(zoom) {
          if (this._minZoom === zoom) return;
          this._minZoom = zoom;
          this.zoom = Math.max(this.zoom, zoom);
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(zoom) {
          if (this._maxZoom === zoom) return;
          this._maxZoom = zoom;
          this.zoom = Math.min(this.zoom, zoom);
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        set renderWorldCopies(renderWorldCopies) {
          if (renderWorldCopies === void 0) {
            renderWorldCopies = true;
          } else if (renderWorldCopies === null) {
            renderWorldCopies = false;
          }
          this._renderWorldCopies = renderWorldCopies;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get centerPoint() {
          return this.size._div(2);
        }
        get size() {
          return new Point3(this.width, this.height);
        }
        get bearing() {
          return -this.angle / Math.PI * 180;
        }
        set bearing(bearing) {
          const b = -wrap(bearing, -180, 180) * Math.PI / 180;
          if (this.angle === b) return;
          this._unmodified = false;
          this.angle = b;
          this._calcMatrices();
          this.rotationMatrix = mat2.create();
          mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle);
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(pitch) {
          const p = clamp(pitch, 0, 60) / 180 * Math.PI;
          if (this._pitch === p) return;
          this._unmodified = false;
          this._pitch = p;
          this._calcMatrices();
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(fov) {
          fov = Math.max(0.01, Math.min(60, fov));
          if (this._fov === fov) return;
          this._unmodified = false;
          this._fov = fov / 180 * Math.PI;
          this._calcMatrices();
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(zoom) {
          const z = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);
          if (this._zoom === z) return;
          this._unmodified = false;
          this._zoom = z;
          this.scale = this.zoomScale(z);
          this.tileZoom = Math.floor(z);
          this.zoomFraction = z - this.tileZoom;
          this._constrain();
          this._calcMatrices();
        }
        get center() {
          return this._center;
        }
        set center(center) {
          if (center.lat === this._center.lat && center.lng === this._center.lng) return;
          this._unmodified = false;
          this._center = center;
          this._constrain();
          this._calcMatrices();
        }
        /**
         * Return a zoom level that will cover all tiles the transform
         * @param {Object} options
         * @param {number} options.tileSize
         * @param {boolean} options.roundZoom
         * @returns {number} zoom level
         */
        coveringZoomLevel(options) {
          return (options.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / options.tileSize));
        }
        /**
         * Return any "wrapped" copies of a given tile coordinate that are visible
         * in the current view.
         *
         * @private
         */
        getVisibleUnwrappedCoordinates(tileID) {
          const result = [new UnwrappedTileID(0, tileID)];
          if (this._renderWorldCopies) {
            const utl = this.pointCoordinate(new Point3(0, 0), 0);
            const utr = this.pointCoordinate(new Point3(this.width, 0), 0);
            const ubl = this.pointCoordinate(new Point3(this.width, this.height), 0);
            const ubr = this.pointCoordinate(new Point3(0, this.height), 0);
            const w0 = Math.floor(Math.min(utl.column, utr.column, ubl.column, ubr.column));
            const w1 = Math.floor(Math.max(utl.column, utr.column, ubl.column, ubr.column));
            const extraWorldCopy = 1;
            for (let w = w0 - extraWorldCopy; w <= w1 + extraWorldCopy; w++) {
              if (w === 0) continue;
              result.push(new UnwrappedTileID(w, tileID));
            }
          }
          return result;
        }
        /**
         * Return all coordinates that could cover this transform for a covering
         * zoom level.
         * @param {Object} options
         * @param {number} options.tileSize
         * @param {number} options.minzoom
         * @param {number} options.maxzoom
         * @param {boolean} options.roundZoom
         * @param {boolean} options.reparseOverscaled
         * @param {boolean} options.renderWorldCopies
         * @returns {Array<Tile>} tiles
         */
        coveringTiles(options) {
          let z = this.coveringZoomLevel(options);
          const actualZ = z;
          if (options.minzoom !== void 0 && z < options.minzoom) return [];
          if (options.maxzoom !== void 0 && z > options.maxzoom) z = options.maxzoom;
          const centerCoord = this.pointCoordinate(this.centerPoint, z);
          const centerPoint = new Point3(centerCoord.column - 0.5, centerCoord.row - 0.5);
          const cornerCoords = [
            this.pointCoordinate(new Point3(0, 0), z),
            this.pointCoordinate(new Point3(this.width, 0), z),
            this.pointCoordinate(new Point3(this.width, this.height), z),
            this.pointCoordinate(new Point3(0, this.height), z)
          ];
          return tileCover(z, cornerCoords, options.reparseOverscaled ? actualZ : z, this._renderWorldCopies).sort(
            (a, b) => centerPoint.dist(a.canonical) - centerPoint.dist(b.canonical)
          );
        }
        resize(width, height) {
          this.width = width;
          this.height = height;
          this.pixelsToGLUnits = [2 / width, -2 / height];
          this._constrain();
          this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(zoom) {
          return 2 ** zoom;
        }
        scaleZoom(scale) {
          return Math.log(scale) / Math.LN2;
        }
        project(lnglat) {
          return new Point3(this.lngX(lnglat.lng), this.latY(lnglat.lat));
        }
        unproject(point) {
          return new LngLat(this.xLng(point.x), this.yLat(point.y));
        }
        get x() {
          return this.lngX(this.center.lng);
        }
        get y() {
          return this.latY(this.center.lat);
        }
        get point() {
          return new Point3(this.x, this.y);
        }
        /**
         * longitude to absolute x coord
         * @returns {number} pixel coordinate
         */
        lngX(lng) {
          return (180 + lng) * this.worldSize / 360;
        }
        /**
         * latitude to absolute y coord
         * @returns {number} pixel coordinate
         */
        latY(lat) {
          lat = clamp(lat, -this.maxValidLatitude, this.maxValidLatitude);
          const y = 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360));
          return (180 - y) * this.worldSize / 360;
        }
        xLng(x) {
          return x * 360 / this.worldSize - 180;
        }
        yLat(y) {
          const y2 = 180 - y * 360 / this.worldSize;
          return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
        }
        setLocationAtPoint(lnglat, point) {
          const translate = this.pointCoordinate(point)._sub(this.pointCoordinate(this.centerPoint));
          this.center = this.coordinateLocation(this.locationCoordinate(lnglat)._sub(translate));
          if (this._renderWorldCopies) {
            this.center = this.center.wrap();
          }
        }
        /**
         * Given a location, return the screen point that corresponds to it
         * @param {LngLat} lnglat location
         * @returns {Point} screen point
         */
        locationPoint(lnglat) {
          return this.coordinatePoint(this.locationCoordinate(lnglat));
        }
        /**
         * Given a point on screen, return its lnglat
         * @param {Point} p screen point
         * @returns {LngLat} lnglat location
         */
        pointLocation(p) {
          return this.coordinateLocation(this.pointCoordinate(p));
        }
        /**
         * Given a geographical lnglat, return an unrounded
         * coordinate that represents it at this transform's zoom level.
         * @param {LngLat} lnglat
         * @returns {Coordinate}
         */
        locationCoordinate(lnglat) {
          return new Coordinate(
            this.lngX(lnglat.lng) / this.tileSize,
            this.latY(lnglat.lat) / this.tileSize,
            this.zoom
          ).zoomTo(this.tileZoom);
        }
        /**
         * Given a Coordinate, return its geographical position.
         * @param {Coordinate} coord
         * @returns {LngLat} lnglat
         */
        coordinateLocation(coord) {
          const zoomedCoord = coord.zoomTo(this.zoom);
          return new LngLat(this.xLng(zoomedCoord.column * this.tileSize), this.yLat(zoomedCoord.row * this.tileSize));
        }
        pointCoordinate(p, zoom) {
          if (zoom === void 0) zoom = this.tileZoom;
          const targetZ = 0;
          const coord0 = [p.x, p.y, 0, 1];
          const coord1 = [p.x, p.y, 1, 1];
          vec4.transformMat4(coord0, coord0, this.pixelMatrixInverse);
          vec4.transformMat4(coord1, coord1, this.pixelMatrixInverse);
          const w0 = coord0[3];
          const w1 = coord1[3];
          const x0 = coord0[0] / w0;
          const x1 = coord1[0] / w1;
          const y0 = coord0[1] / w0;
          const y1 = coord1[1] / w1;
          const z0 = coord0[2] / w0;
          const z1 = coord1[2] / w1;
          const t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);
          return new Coordinate(
            interpolate2(x0, x1, t) / this.tileSize,
            interpolate2(y0, y1, t) / this.tileSize,
            this.zoom
          )._zoomTo(zoom);
        }
        /**
         * Given a coordinate, return the screen point that corresponds to it
         * @param {Coordinate} coord
         * @returns {Point} screen point
         */
        coordinatePoint(coord) {
          const zoomedCoord = coord.zoomTo(this.zoom);
          const p = [zoomedCoord.column * this.tileSize, zoomedCoord.row * this.tileSize, 0, 1];
          vec4.transformMat4(p, p, this.pixelMatrix);
          return new Point3(p[0] / p[3], p[1] / p[3]);
        }
        /**
         * Calculate the posMatrix that, given a tile coordinate, would be used to display the tile on a map.
         * @param {UnwrappedTileID} unwrappedTileID;
         */
        calculatePosMatrix(unwrappedTileID, aligned = false) {
          const posMatrixKey = unwrappedTileID.key;
          const cache = aligned ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (cache[posMatrixKey]) {
            return cache[posMatrixKey];
          }
          const canonical = unwrappedTileID.canonical;
          const scale = this.worldSize / this.zoomScale(canonical.z);
          const unwrappedX = canonical.x + 2 ** canonical.z * unwrappedTileID.wrap;
          const posMatrix = mat4.identity(new Float64Array(16));
          mat4.translate(posMatrix, posMatrix, [unwrappedX * scale, canonical.y * scale, 0]);
          mat4.scale(posMatrix, posMatrix, [scale / EXTENT, scale / EXTENT, 1]);
          mat4.multiply(posMatrix, aligned ? this.alignedProjMatrix : this.projMatrix, posMatrix);
          cache[posMatrixKey] = new Float32Array(posMatrix);
          return cache[posMatrixKey];
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining) return;
          this._constraining = true;
          let minY = -90;
          let maxY = 90;
          let minX = -180;
          let maxX = 180;
          let sy;
          let sx;
          let x2;
          let y2;
          const size = this.size;
          const unmodified = this._unmodified;
          if (this.latRange) {
            const latRange = this.latRange;
            minY = this.latY(latRange[1]);
            maxY = this.latY(latRange[0]);
            sy = maxY - minY < size.y ? size.y / (maxY - minY) : 0;
          }
          if (this.lngRange) {
            const lngRange = this.lngRange;
            minX = this.lngX(lngRange[0]);
            maxX = this.lngX(lngRange[1]);
            sx = maxX - minX < size.x ? size.x / (maxX - minX) : 0;
          }
          const s = Math.max(sx || 0, sy || 0);
          if (s) {
            this.center = this.unproject(new Point3(sx ? (maxX + minX) / 2 : this.x, sy ? (maxY + minY) / 2 : this.y));
            this.zoom += this.scaleZoom(s);
            this._unmodified = unmodified;
            this._constraining = false;
            return;
          }
          if (this.latRange) {
            const y = this.y;
            const h2 = size.y / 2;
            if (y - h2 < minY) y2 = minY + h2;
            if (y + h2 > maxY) y2 = maxY - h2;
          }
          if (this.lngRange) {
            const x = this.x;
            const w2 = size.x / 2;
            if (x - w2 < minX) x2 = minX + w2;
            if (x + w2 > maxX) x2 = maxX - w2;
          }
          if (x2 !== void 0 || y2 !== void 0) {
            this.center = this.unproject(new Point3(x2 !== void 0 ? x2 : this.x, y2 !== void 0 ? y2 : this.y));
          }
          this._unmodified = unmodified;
          this._constraining = false;
        }
        _calcMatrices() {
          if (!this.height) return;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height;
          const halfFov = this._fov / 2;
          const groundAngle = Math.PI / 2 + this._pitch;
          const topHalfSurfaceDistance = Math.sin(halfFov) * this.cameraToCenterDistance / Math.sin(Math.PI - groundAngle - halfFov);
          const x = this.x;
          const y = this.y;
          const furthestDistance = Math.cos(Math.PI / 2 - this._pitch) * topHalfSurfaceDistance + this.cameraToCenterDistance;
          const farZ = furthestDistance * 1.01;
          let m = new Float64Array(16);
          mat4.perspective(m, this._fov, this.width / this.height, 1, farZ);
          mat4.scale(m, m, [1, -1, 1]);
          mat4.translate(m, m, [0, 0, -this.cameraToCenterDistance]);
          mat4.rotateX(m, m, this._pitch);
          mat4.rotateZ(m, m, this.angle);
          mat4.translate(m, m, [-x, -y, 0]);
          const verticalScale = this.worldSize / (2 * Math.PI * 6378137 * Math.abs(Math.cos(this.center.lat * (Math.PI / 180))));
          mat4.scale(m, m, [1, 1, verticalScale, 1]);
          this.projMatrix = m;
          const xShift = this.width % 2 / 2;
          const yShift = this.height % 2 / 2;
          const angleCos = Math.cos(this.angle);
          const angleSin = Math.sin(this.angle);
          const dx = x - Math.round(x) + angleCos * xShift + angleSin * yShift;
          const dy = y - Math.round(y) + angleCos * yShift + angleSin * xShift;
          const alignedM = new Float64Array(m);
          mat4.translate(alignedM, alignedM, [dx > 0.5 ? dx - 1 : dx, dy > 0.5 ? dy - 1 : dy, 0]);
          this.alignedProjMatrix = alignedM;
          m = mat4.create();
          mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);
          mat4.translate(m, m, [1, -1, 0]);
          this.pixelMatrix = mat4.multiply(new Float64Array(16), m, this.projMatrix);
          m = mat4.invert(new Float64Array(16), this.pixelMatrix);
          if (!m) throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = m;
          this._posMatrixCache = {};
          this._alignedPosMatrixCache = {};
        }
        maxPitchScaleFactor() {
          if (!this.pixelMatrixInverse) return 1;
          const coord = this.pointCoordinate(new Point3(0, 0)).zoomTo(this.zoom);
          const p = [coord.column * this.tileSize, coord.row * this.tileSize, 0, 1];
          const topPoint = vec4.transformMat4(p, p, this.pixelMatrix);
          return topPoint[3] / this.cameraToCenterDistance;
        }
        /*
         * The camera looks at the map from a 3D (lng, lat, altitude) location. Let's use `cameraLocation`
         * as the name for the location under the camera and on the surface of the earth (lng, lat, 0).
         * `cameraPoint` is the projected position of the `cameraLocation`.
         *
         * This point is useful to us because only fill-extrusions that are between `cameraPoint` and
         * the query point on the surface of the earth can extend and intersect the query.
         *
         * When the map is not pitched the `cameraPoint` is equivalent to the center of the map because
         * the camera is right above the center of the map.
         */
        getCameraPoint() {
          const pitch = this._pitch;
          const yOffset = Math.tan(pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new Point3(0, yOffset));
        }
        /*
         * When the map is pitched, some of the 3D features that intersect a query will not intersect
         * the query at the surface of the earth. Instead the feature may be closer and only intersect
         * the query because it extrudes into the air.
         *
         * This returns a geometry that includes all of the original query as well as all possible ares of the
         * screen where the *base* of a visible extrusion could be.
         *  - For point queries, the line from the query point to the "camera point"
         *  - For other geometries, the envelope of the query geometry and the "camera point"
         */
        getCameraQueryGeometry(queryGeometry) {
          const c = this.getCameraPoint();
          if (queryGeometry.length === 1) {
            return [queryGeometry[0], c];
          }
          let minX = c.x;
          let minY = c.y;
          let maxX = c.x;
          let maxY = c.y;
          for (const p of queryGeometry) {
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x);
            maxY = Math.max(maxY, p.y);
          }
          return [
            new Point3(minX, minY),
            new Point3(maxX, minY),
            new Point3(maxX, maxY),
            new Point3(minX, maxY),
            new Point3(minX, minY)
          ];
        }
      };
      module.exports = Transform;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/ui/camera.js
  var require_camera = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/ui/camera.js"(exports, module) {
      var { deepEqual } = require_object();
      var { clamp, wrap, ease: defaultEasing } = require_util();
      var warn = require_warn();
      var interpolate2 = require_interpolate3();
      var browser = require_browser();
      var LngLat = require_lng_lat();
      var LngLatBounds = require_lng_lat_bounds();
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      var { Event: Event3, Evented: Evented3 } = (init_events(), __toCommonJS(events_exports));
      var Camera = class extends Evented3 {
        constructor(transform, options) {
          super();
          this._moving = false;
          this._zooming = false;
          this.transform = transform;
          this._bearingSnap = options.bearingSnap;
        }
        /**
         * Returns the map's geographical centerpoint.
         *
         * @memberof Map#
         * @returns The map's geographical centerpoint.
         */
        getCenter() {
          return this.transform.center;
        }
        /**
         * Sets the map's geographical centerpoint. Equivalent to `jumpTo({center: center})`.
         *
         * @memberof Map#
         * @param center The centerpoint to set.
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         * @example
         * map.setCenter([-74, 38]);
         * @see [Move symbol with the keyboard](https://www.mapbox.com/mapbox-gl-js/example/rotating-controllable-marker/)
         */
        setCenter(center, eventData) {
          return this.jumpTo({ center }, eventData);
        }
        /**
         * Pans the map by the specified offest.
         *
         * @memberof Map#
         * @param offset `x` and `y` coordinates by which to pan the map.
         * @param options
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         * @see [Navigate the map with game-like controls](https://www.mapbox.com/mapbox-gl-js/example/game-controls/)
         */
        panBy(offset, options = {}, eventData) {
          offset = Point3.convert(offset).mult(-1);
          return this.panTo(this.transform.center, { offset, ...options }, eventData);
        }
        /**
         * Pans the map to the specified location, with an animated transition.
         *
         * @memberof Map#
         * @param lnglat The location to pan the map to.
         * @param options
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        panTo(lnglat, options = {}, eventData) {
          return this.easeTo({ center: lnglat, ...options }, eventData);
        }
        /**
         * Returns the map's current zoom level.
         *
         * @memberof Map#
         * @returns The map's current zoom level.
         */
        getZoom() {
          return this.transform.zoom;
        }
        /**
         * Sets the map's zoom level. Equivalent to `jumpTo({zoom: zoom})`.
         *
         * @memberof Map#
         * @param zoom The zoom level to set (0-20).
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires zoomstart
         * @fires move
         * @fires zoom
         * @fires moveend
         * @fires zoomend
         * @returns {Map} `this`
         * @example
         * // zoom the map to 5
         * map.setZoom(5);
         */
        setZoom(zoom, eventData) {
          this.jumpTo({ zoom }, eventData);
          return this;
        }
        /**
         * Zooms the map to the specified zoom level, with an animated transition.
         *
         * @memberof Map#
         * @param zoom The zoom level to transition to.
         * @param options
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires zoomstart
         * @fires move
         * @fires zoom
         * @fires moveend
         * @fires zoomend
         * @returns {Map} `this`
         */
        zoomTo(zoom, options = {}, eventData) {
          return this.easeTo({ zoom, ...options }, eventData);
        }
        /**
         * Increases the map's zoom level by 1.
         *
         * @memberof Map#
         * @param options
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires zoomstart
         * @fires move
         * @fires zoom
         * @fires moveend
         * @fires zoomend
         * @returns {Map} `this`
         */
        zoomIn(options, eventData) {
          this.zoomTo(this.getZoom() + 1, options, eventData);
          return this;
        }
        /**
         * Decreases the map's zoom level by 1.
         *
         * @memberof Map#
         * @param options
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires zoomstart
         * @fires move
         * @fires zoom
         * @fires moveend
         * @fires zoomend
         * @returns {Map} `this`
         */
        zoomOut(options, eventData) {
          this.zoomTo(this.getZoom() - 1, options, eventData);
          return this;
        }
        /**
         * Returns the map's current bearing. The bearing is the compass direction that is \"up\"; for example, a bearing
         * of 90 orients the map so that east is up.
         *
         * @memberof Map#
         * @returns The map's current bearing.
         * @see [Navigate the map with game-like controls](https://www.mapbox.com/mapbox-gl-js/example/game-controls/)
         */
        getBearing() {
          return this.transform.bearing;
        }
        /**
         * Sets the map's bearing (rotation). The bearing is the compass direction that is \"up\"; for example, a bearing
         * of 90 orients the map so that east is up.
         *
         * Equivalent to `jumpTo({bearing: bearing})`.
         *
         * @memberof Map#
         * @param bearing The desired bearing.
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         * @example
         * // rotate the map to 90 degrees
         * map.setBearing(90);
         */
        setBearing(bearing, eventData) {
          this.jumpTo({ bearing }, eventData);
          return this;
        }
        /**
         * Rotates the map to the specified bearing, with an animated transition. The bearing is the compass direction
         * that is \"up\"; for example, a bearing of 90 orients the map so that east is up.
         *
         * @memberof Map#
         * @param bearing The desired bearing.
         * @param options
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        rotateTo(bearing, options = {}, eventData) {
          return this.easeTo({ bearing, ...options }, eventData);
        }
        /**
         * Rotates the map so that north is up (0 bearing), with an animated transition.
         *
         * @memberof Map#
         * @param options
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        resetNorth(options = {}, eventData) {
          this.rotateTo(0, { duration: 1e3, ...options }, eventData);
          return this;
        }
        /**
         * Snaps the map so that north is up (0 bearing), if the current bearing is close enough to it (i.e. within the
         * `bearingSnap` threshold).
         *
         * @memberof Map#
         * @param options
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        snapToNorth(options, eventData) {
          if (Math.abs(this.getBearing()) < this._bearingSnap) {
            return this.resetNorth(options, eventData);
          }
          return this;
        }
        /**
         * Returns the map's current pitch (tilt).
         *
         * @memberof Map#
         * @returns The map's current pitch, measured in degrees away from the plane of the screen.
         */
        getPitch() {
          return this.transform.pitch;
        }
        /**
         * Sets the map's pitch (tilt). Equivalent to `jumpTo({pitch: pitch})`.
         *
         * @memberof Map#
         * @param pitch The pitch to set, measured in degrees away from the plane of the screen (0-60).
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires pitchstart
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        setPitch(pitch, eventData) {
          this.jumpTo({ pitch }, eventData);
          return this;
        }
        /**
         * @memberof Map#
         * @param bounds Calculate the center for these bounds in the viewport and use
         *      the highest zoom level up to and including `Map#getMaxZoom()` that fits
         *      in the viewport.
         * @param options
         * @param {number | PaddingOptions} [options.padding] The amount of padding in pixels to add to the given bounds.
         * @param {PointLike} [options.offset=[0, 0]] The center of the given bounds relative to the map's center, measured in pixels.
         * @param {number} [options.maxZoom] The maximum zoom level to allow when the camera would transition to the specified bounds.
         * @returns {CameraOptions | void} If map is able to fit to provided bounds, returns `CameraOptions` with
         *      at least `center`, `zoom`, `bearing`, `offset`, `padding`, and `maxZoom`, as well as any other
         *      `options` provided in arguments. If map is unable to fit, method will warn and return undefined.
         * @example
         * var bbox = [[-79, 43], [-73, 45]];
         * var newCameraTransform = map.cameraForBounds(bbox, {
         *   padding: {top: 10, bottom:25, left: 15, right: 5}
         * });
         */
        cameraForBounds(bounds2, options) {
          options = {
            padding: {
              top: 0,
              bottom: 0,
              right: 0,
              left: 0
            },
            offset: [0, 0],
            maxZoom: this.transform.maxZoom,
            ...options
          };
          if (typeof options.padding === "number") {
            const p = options.padding;
            options.padding = {
              top: p,
              bottom: p,
              right: p,
              left: p
            };
          }
          if (!deepEqual(
            Object.keys(options.padding).sort((a, b) => {
              if (a < b) return -1;
              if (a > b) return 1;
              return 0;
            }),
            ["bottom", "left", "right", "top"]
          )) {
            warn.once("options.padding must be a positive number, or an Object with keys 'bottom', 'left', 'right', 'top'");
            return;
          }
          bounds2 = LngLatBounds.convert(bounds2);
          const paddingOffset = [
            (options.padding.left - options.padding.right) / 2,
            (options.padding.top - options.padding.bottom) / 2
          ];
          const lateralPadding = Math.min(options.padding.right, options.padding.left);
          const verticalPadding = Math.min(options.padding.top, options.padding.bottom);
          options.offset = [options.offset[0] + paddingOffset[0], options.offset[1] + paddingOffset[1]];
          const offset = Point3.convert(options.offset);
          const tr = this.transform;
          const nw = tr.project(bounds2.getNorthWest());
          const se = tr.project(bounds2.getSouthEast());
          const size = se.sub(nw);
          const scaleX = (tr.width - lateralPadding * 2 - Math.abs(offset.x) * 2) / size.x;
          const scaleY = (tr.height - verticalPadding * 2 - Math.abs(offset.y) * 2) / size.y;
          if (scaleY < 0 || scaleX < 0) {
            warn.once("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            return;
          }
          options.center = tr.unproject(nw.add(se).div(2));
          options.zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);
          options.bearing = 0;
          return options;
        }
        /**
         * Pans and zooms the map to contain its visible area within the specified geographical bounds.
         * This function will also reset the map's bearing to 0 if bearing is nonzero.
         *
         * @memberof Map#
         * @param bounds Center these bounds in the viewport and use the highest
         *      zoom level up to and including `Map#getMaxZoom()` that fits them in the viewport.
         * @param options
         * @param {number | PaddingOptions} [options.padding] The amount of padding in pixels to add to the given bounds.
         * @param {boolean} [options.linear=false] If `true`, the map transitions using
         *     {@link Map#easeTo}. If `false`, the map transitions using {@link Map#flyTo}. See
         *     those functions and {@link AnimationOptions} for information about options available.
         * @param {Function} [options.easing] An easing function for the animated transition. See {@link AnimationOptions}.
         * @param {PointLike} [options.offset=[0, 0]] The center of the given bounds relative to the map's center, measured in pixels.
         * @param {number} [options.maxZoom] The maximum zoom level to allow when the map view transitions to the specified bounds.
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         * @example
         * var bbox = [[-79, 43], [-73, 45]];
         * map.fitBounds(bbox, {
         *   padding: {top: 10, bottom:25, left: 15, right: 5}
         * });
         * @see [Fit a map to a bounding box](https://www.mapbox.com/mapbox-gl-js/example/fitbounds/)
         */
        fitBounds(bounds2, options, eventData) {
          const calculatedOptions = this.cameraForBounds(bounds2, options);
          if (!calculatedOptions) return this;
          options = Object.assign(calculatedOptions, options);
          return options.linear ? this.easeTo(options, eventData) : options.animate === false ? this.jumpTo(options, eventData) : this.flyTo(options, eventData);
        }
        /**
         * Changes any combination of center, zoom, bearing, and pitch, without
         * an animated transition. The map will retain its current values for any
         * details not specified in `options`.
         *
         * @memberof Map#
         * @param options
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires zoomstart
         * @fires pitchstart
         * @fires rotate
         * @fires move
         * @fires zoom
         * @fires pitch
         * @fires moveend
         * @fires zoomend
         * @fires pitchend
         * @returns {Map} `this`
         */
        jumpTo(options, eventData) {
          this.stop();
          const tr = this.transform;
          let zoomChanged = false;
          let bearingChanged = false;
          let pitchChanged = false;
          if ("zoom" in options && tr.zoom !== +options.zoom) {
            zoomChanged = true;
            tr.zoom = +options.zoom;
          }
          if (options.center !== void 0) {
            tr.center = LngLat.convert(options.center);
          }
          if ("bearing" in options && tr.bearing !== +options.bearing) {
            bearingChanged = true;
            tr.bearing = +options.bearing;
          }
          if ("pitch" in options && tr.pitch !== +options.pitch) {
            pitchChanged = true;
            tr.pitch = +options.pitch;
          }
          this.fire(new Event3("movestart", eventData)).fire(new Event3("move", eventData));
          if (zoomChanged) {
            this.fire(new Event3("zoomstart", eventData)).fire(new Event3("zoom", eventData)).fire(new Event3("zoomend", eventData));
          }
          if (bearingChanged) {
            this.fire(new Event3("rotatestart", eventData)).fire(new Event3("rotate", eventData)).fire(new Event3("rotateend", eventData));
          }
          if (pitchChanged) {
            this.fire(new Event3("pitchstart", eventData)).fire(new Event3("pitch", eventData)).fire(new Event3("pitchend", eventData));
          }
          return this.fire(new Event3("moveend", eventData));
        }
        /**
         * Changes any combination of center, zoom, bearing, and pitch, with an animated transition
         * between old and new values. The map will retain its current values for any
         * details not specified in `options`.
         *
         * @memberof Map#
         * @param options Options describing the destination and animation of the transition.
         *            Accepts {@link CameraOptions} and {@link AnimationOptions}.
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires zoomstart
         * @fires pitchstart
         * @fires rotate
         * @fires move
         * @fires zoom
         * @fires pitch
         * @fires moveend
         * @fires zoomend
         * @fires pitchend
         * @returns {Map} `this`
         * @see [Navigate the map with game-like controls](https://www.mapbox.com/mapbox-gl-js/example/game-controls/)
         */
        easeTo(options, eventData) {
          this.stop();
          options = {
            offset: [0, 0],
            duration: 500,
            easing: defaultEasing,
            ...options
          };
          if (options.animate === false) options.duration = 0;
          const tr = this.transform;
          const startZoom = this.getZoom();
          const startBearing = this.getBearing();
          const startPitch = this.getPitch();
          const zoom = "zoom" in options ? +options.zoom : startZoom;
          const bearing = "bearing" in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing;
          const pitch = "pitch" in options ? +options.pitch : startPitch;
          const pointAtOffset = tr.centerPoint.add(Point3.convert(options.offset));
          const locationAtOffset = tr.pointLocation(pointAtOffset);
          const center = LngLat.convert(options.center || locationAtOffset);
          this._normalizeCenter(center);
          const from = tr.project(locationAtOffset);
          const delta = tr.project(center).sub(from);
          const finalScale = tr.zoomScale(zoom - startZoom);
          let around;
          let aroundPoint;
          if (options.around) {
            around = LngLat.convert(options.around);
            aroundPoint = tr.locationPoint(around);
          }
          this._zooming = zoom !== startZoom;
          this._rotating = startBearing !== bearing;
          this._pitching = pitch !== startPitch;
          this._prepareEase(eventData, options.noMoveStart);
          clearTimeout(this._easeEndTimeoutID);
          this._ease(
            (k) => {
              if (this._zooming) {
                tr.zoom = interpolate2(startZoom, zoom, k);
              }
              if (this._rotating) {
                tr.bearing = interpolate2(startBearing, bearing, k);
              }
              if (this._pitching) {
                tr.pitch = interpolate2(startPitch, pitch, k);
              }
              if (around) {
                tr.setLocationAtPoint(around, aroundPoint);
              } else {
                const scale = tr.zoomScale(tr.zoom - startZoom);
                const base = zoom > startZoom ? Math.min(2, finalScale) : Math.max(0.5, finalScale);
                const speedup = base ** (1 - k);
                const newCenter = tr.unproject(from.add(delta.mult(k * speedup)).mult(scale));
                tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);
              }
              this._fireMoveEvents(eventData);
            },
            () => {
              if (options.delayEndEvents) {
                this._easeEndTimeoutID = setTimeout(() => this._afterEase(eventData), options.delayEndEvents);
              } else {
                this._afterEase(eventData);
              }
            },
            options
          );
          return this;
        }
        _prepareEase(eventData, noMoveStart) {
          this._moving = true;
          if (!noMoveStart) {
            this.fire(new Event3("movestart", eventData));
          }
          if (this._zooming) {
            this.fire(new Event3("zoomstart", eventData));
          }
          if (this._rotating) {
            this.fire(new Event3("rotatestart", eventData));
          }
          if (this._pitching) {
            this.fire(new Event3("pitchstart", eventData));
          }
        }
        _fireMoveEvents(eventData) {
          this.fire(new Event3("move", eventData));
          if (this._zooming) {
            this.fire(new Event3("zoom", eventData));
          }
          if (this._rotating) {
            this.fire(new Event3("rotate", eventData));
          }
          if (this._pitching) {
            this.fire(new Event3("pitch", eventData));
          }
        }
        _afterEase(eventData) {
          const wasZooming = this._zooming;
          const wasRotating = this._rotating;
          const wasPitching = this._pitching;
          this._moving = false;
          this._zooming = false;
          this._rotating = false;
          this._pitching = false;
          if (wasZooming) {
            this.fire(new Event3("zoomend", eventData));
          }
          if (wasRotating) {
            this.fire(new Event3("rotateend", eventData));
          }
          if (wasPitching) {
            this.fire(new Event3("pitchend", eventData));
          }
          this.fire(new Event3("moveend", eventData));
        }
        /**
         * Changes any combination of center, zoom, bearing, and pitch, animating the transition along a curve that
         * evokes flight. The animation seamlessly incorporates zooming and panning to help
         * the user maintain her bearings even after traversing a great distance.
         *
         * @memberof Map#
         * @param {Object} options Options describing the destination and animation of the transition.
         *     Accepts {@link CameraOptions}, {@link AnimationOptions},
         *     and the following additional options.
         * @param {number} [options.curve=1.42] The zooming "curve" that will occur along the
         *     flight path. A high value maximizes zooming for an exaggerated animation, while a low
         *     value minimizes zooming for an effect closer to {@link Map#easeTo}. 1.42 is the average
         *     value selected by participants in the user study discussed in
         *     [van Wijk (2003)](https://www.win.tue.nl/~vanwijk/zoompan.pdf). A value of
         *     `Math.pow(6, 0.25)` would be equivalent to the root mean squared average velocity. A
         *     value of 1 would produce a circular motion.
         * @param {number} [options.minZoom] The zero-based zoom level at the peak of the flight path. If
         *     `options.curve` is specified, this option is ignored.
         * @param {number} [options.speed=1.2] The average speed of the animation defined in relation to
         *     `options.curve`. A speed of 1.2 means that the map appears to move along the flight path
         *     by 1.2 times `options.curve` screenfuls every second. A _screenful_ is the map's visible span.
         *     It does not correspond to a fixed physical distance, but varies by zoom level.
         * @param {number} [options.screenSpeed] The average speed of the animation measured in screenfuls
         *     per second, assuming a linear timing curve. If `options.speed` is specified, this option is ignored.
         * @param {number} [options.maxDuration] The animation's maximum duration, measured in milliseconds.
         *     If duration exceeds maximum duration, it resets to 0.
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires zoomstart
         * @fires pitchstart
         * @fires move
         * @fires zoom
         * @fires rotate
         * @fires pitch
         * @fires moveend
         * @fires zoomend
         * @fires pitchend
         * @returns {Map} `this`
         * @example
         * // fly with default options to null island
         * map.flyTo({center: [0, 0], zoom: 9});
         * // using flyTo options
         * map.flyTo({
         *   center: [0, 0],
         *   zoom: 9,
         *   speed: 0.2,
         *   curve: 1,
         *   easing(t) {
         *     return t;
         *   }
         * });
         * @see [Fly to a location](https://www.mapbox.com/mapbox-gl-js/example/flyto/)
         * @see [Slowly fly to a location](https://www.mapbox.com/mapbox-gl-js/example/flyto-options/)
         * @see [Fly to a location based on scroll position](https://www.mapbox.com/mapbox-gl-js/example/scroll-fly-to/)
         */
        flyTo(options, eventData) {
          this.stop();
          options = {
            offset: [0, 0],
            speed: 1.2,
            curve: 1.42,
            easing: defaultEasing,
            ...options
          };
          const tr = this.transform;
          const startZoom = this.getZoom();
          const startBearing = this.getBearing();
          const startPitch = this.getPitch();
          const zoom = "zoom" in options ? clamp(+options.zoom, tr.minZoom, tr.maxZoom) : startZoom;
          const bearing = "bearing" in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing;
          const pitch = "pitch" in options ? +options.pitch : startPitch;
          const scale = tr.zoomScale(zoom - startZoom);
          const pointAtOffset = tr.centerPoint.add(Point3.convert(options.offset));
          const locationAtOffset = tr.pointLocation(pointAtOffset);
          const center = LngLat.convert(options.center || locationAtOffset);
          this._normalizeCenter(center);
          const from = tr.project(locationAtOffset);
          const delta = tr.project(center).sub(from);
          let rho = options.curve;
          const w0 = Math.max(tr.width, tr.height);
          const w1 = w0 / scale;
          const u1 = delta.mag();
          if ("minZoom" in options) {
            const minZoom = clamp(Math.min(options.minZoom, startZoom, zoom), tr.minZoom, tr.maxZoom);
            const wMax = w0 / tr.zoomScale(minZoom - startZoom);
            rho = Math.sqrt(wMax / u1 * 2);
          }
          const rho2 = rho * rho;
          function r(i) {
            const b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
            return Math.log(Math.sqrt(b * b + 1) - b);
          }
          function sinh(n) {
            return (Math.exp(n) - Math.exp(-n)) / 2;
          }
          function cosh(n) {
            return (Math.exp(n) + Math.exp(-n)) / 2;
          }
          function tanh(n) {
            return sinh(n) / cosh(n);
          }
          const r0 = r(0);
          let w = function(s) {
            return cosh(r0) / cosh(r0 + rho * s);
          };
          let u = function(s) {
            return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1;
          };
          let S = (r(1) - r0) / rho;
          if (Math.abs(u1) < 1e-6 || !Number.isFinite(S)) {
            if (Math.abs(w0 - w1) < 1e-6) return this.easeTo(options, eventData);
            const k = w1 < w0 ? -1 : 1;
            S = Math.abs(Math.log(w1 / w0)) / rho;
            u = function() {
              return 0;
            };
            w = function(s) {
              return Math.exp(k * rho * s);
            };
          }
          if ("duration" in options) {
            options.duration = +options.duration;
          } else {
            const V = "screenSpeed" in options ? +options.screenSpeed / rho : +options.speed;
            options.duration = 1e3 * S / V;
          }
          if (options.maxDuration && options.duration > options.maxDuration) {
            options.duration = 0;
          }
          this._zooming = true;
          this._rotating = startBearing !== bearing;
          this._pitching = pitch !== startPitch;
          this._prepareEase(eventData, false);
          this._ease(
            (k) => {
              const s = k * S;
              const scale2 = 1 / w(s);
              tr.zoom = k === 1 ? zoom : startZoom + tr.scaleZoom(scale2);
              if (this._rotating) {
                tr.bearing = interpolate2(startBearing, bearing, k);
              }
              if (this._pitching) {
                tr.pitch = interpolate2(startPitch, pitch, k);
              }
              const newCenter = k === 1 ? center : tr.unproject(from.add(delta.mult(u(s))).mult(scale2));
              tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);
              this._fireMoveEvents(eventData);
            },
            () => this._afterEase(eventData),
            options
          );
          return this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        /**
         * Stops any animated transition underway.
         *
         * @memberof Map#
         * @returns {Map} `this`
         */
        stop() {
          if (this._easeFrameId) {
            this._cancelRenderFrame(this._easeFrameId);
            delete this._easeFrameId;
            delete this._onEaseFrame;
          }
          if (this._onEaseEnd) {
            const onEaseEnd = this._onEaseEnd;
            delete this._onEaseEnd;
            onEaseEnd.call(this);
          }
          return this;
        }
        _ease(frame2, finish, options) {
          if (options.animate === false || options.duration === 0) {
            frame2(1);
            finish();
          } else {
            this._easeStart = browser.now();
            this._easeOptions = options;
            this._onEaseFrame = frame2;
            this._onEaseEnd = finish;
            this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback);
          }
        }
        // Callback for map._requestRenderFrame
        _renderFrameCallback() {
          const t = Math.min((browser.now() - this._easeStart) / this._easeOptions.duration, 1);
          this._onEaseFrame(this._easeOptions.easing(t));
          if (t < 1) {
            this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback);
          } else {
            this.stop();
          }
        }
        // convert bearing so that it's numerically close to the current one so that it interpolates properly
        _normalizeBearing(bearing, currentBearing) {
          bearing = wrap(bearing, -180, 180);
          const diff = Math.abs(bearing - currentBearing);
          if (Math.abs(bearing - 360 - currentBearing) < diff) bearing -= 360;
          if (Math.abs(bearing + 360 - currentBearing) < diff) bearing += 360;
          return bearing;
        }
        // If a path crossing the antimeridian would be shorter, extend the final coordinate so that
        // interpolating between the two endpoints will cross it.
        _normalizeCenter(center) {
          const tr = this.transform;
          if (!tr.renderWorldCopies || tr.lngRange) return;
          const delta = center.lng - tr.center.lng;
          center.lng += delta > 180 ? -360 : delta < -180 ? 360 : 0;
        }
      };
      module.exports = Camera;
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/util/task_queue.js
  var require_task_queue = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/util/task_queue.js"(exports, module) {
      var assert = require_nanoassert();
      module.exports = taskQueue;
      function taskQueue(thisArg) {
        const queues = {
          running: [],
          later: []
        };
        let id = Number.MIN_SAFE_INTEGER;
        let cleared = false;
        return {
          add,
          remove,
          run,
          clear
        };
        function add(fn) {
          if (id === Number.MAX_SAFE_INTEGER) id = Number.MIN_SAFE_INTEGER;
          id += 1;
          queues.later.push({ fn, id, cancelled: false });
          return id;
        }
        function remove(id2) {
          const task = queues.running.find((t) => t.id === id2) ?? queues.later.find((t) => t.id === id2);
          if (task) {
            task.cancelled = true;
          }
        }
        function run() {
          assert(queues.running.length === 0);
          queues.running = queues.later;
          queues.later = [];
          for (const { fn, cancelled } of queues.running) {
            if (cancelled) continue;
            fn.call(thisArg);
            if (cleared) break;
          }
          queues.running.length = 0;
          cleared = false;
        }
        function clear() {
          if (queues.running.length > 0) {
            cleared = true;
          }
          queues.later.length = 0;
        }
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/ui/map.js
  var require_map = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/ui/map.js"(exports, module) {
      var { bindAll } = require_object();
      var warn = require_warn();
      var browser = require_browser();
      var DOM = require_dom();
      var loadImage = require_image();
      var Style = require_style();
      var EvaluationParameters = require_evaluation_parameters();
      var Painter = require_painter();
      var Transform = require_transform();
      var Camera = require_camera();
      var LngLat = require_lng_lat();
      var LngLatBounds = require_lng_lat_bounds();
      var { default: Point3 } = (init_point_geometry(), __toCommonJS(point_geometry_exports));
      var { RGBAImage } = require_image2();
      var { Event: Event3, ErrorEvent: ErrorEvent3 } = (init_events(), __toCommonJS(events_exports));
      var taskQueue = require_task_queue();
      var defaultMinZoom = 0;
      var defaultMaxZoom = 22;
      var defaultOptions2 = {
        center: [0, 0],
        zoom: 0,
        bearing: 0,
        pitch: 0,
        minZoom: defaultMinZoom,
        maxZoom: defaultMaxZoom,
        interactive: true,
        bearingSnap: 7,
        attributionControl: true,
        failIfMajorPerformanceCaveat: false,
        preserveDrawingBuffer: false,
        trackResize: true,
        renderWorldCopies: true,
        refreshExpiredTiles: true,
        maxTileCacheSize: null,
        transformRequest: null,
        fadeDuration: 300,
        crossSourceCollisions: true
      };
      var Map2 = class extends Camera {
        constructor(options) {
          options = Object.assign({}, defaultOptions2, options);
          if (options.minZoom != null && options.maxZoom != null && options.minZoom > options.maxZoom) {
            throw new Error("maxZoom must be greater than minZoom");
          }
          const transform = new Transform(options.minZoom, options.maxZoom, options.renderWorldCopies);
          super(transform, options);
          this.loadImage = loadImage;
          this._interactive = options.interactive;
          this._maxTileCacheSize = options.maxTileCacheSize;
          this._failIfMajorPerformanceCaveat = options.failIfMajorPerformanceCaveat;
          this._preserveDrawingBuffer = options.preserveDrawingBuffer;
          this._trackResize = options.trackResize;
          this._bearingSnap = options.bearingSnap;
          this._fadeDuration = options.fadeDuration;
          this._crossSourceCollisions = options.crossSourceCollisions;
          this._crossFadingFactor = 1;
          this._renderTaskQueue = taskQueue(this);
          if (typeof options.container === "string") {
            const container = window.document.getElementById(options.container);
            if (!container) {
              throw new Error(`Container '${options.container}' not found.`);
            }
            this._container = container;
          } else if (options.container instanceof window.HTMLElement) {
            this._container = options.container;
          } else {
            throw new Error(`Invalid type: 'container' must be a String or HTMLElement.`);
          }
          if (options.maxBounds) {
            this.setMaxBounds(options.maxBounds);
          }
          bindAll(
            [
              "_onWindowOnline",
              "_onWindowResize",
              "_contextLost",
              "_contextRestored",
              "_update",
              "_render",
              "_onData",
              "_onDataLoading"
            ],
            this
          );
          this._setupContainer();
          this._setupPainter();
          if (this.painter === void 0) {
            throw new Error("Failed to initialize WebGL.");
          }
          this.on("move", this._update.bind(this, false));
          this.on("moveend", this._update.bind(this, false));
          this.on("zoom", this._update.bind(this, true));
          if (typeof window !== "undefined") {
            window.addEventListener("online", this._onWindowOnline, false);
            window.addEventListener("resize", this._onWindowResize, false);
          }
          this.jumpTo({
            center: options.center,
            zoom: options.zoom,
            bearing: options.bearing,
            pitch: options.pitch
          });
          this.resize();
          if (options.style) this.setStyle(options.style);
          this.on("style.load", function() {
            if (this.transform.unmodified) {
              this.jumpTo(this.style.stylesheet);
            }
          });
          this.on("data", this._onData);
          this.on("dataloading", this._onDataLoading);
        }
        /**
         * Adds a {@link IControl} to the map, calling `control.onAdd(this)`.
         *
         * @param {IControl} control The {@link IControl} to add.
         * @param {string} [position] position on the map to which the control will be added.
         * Valid values are `'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`. Defaults to `'top-right'`.
         * @returns {Map} `this`
         * @see [Display map navigation controls](https://www.mapbox.com/mapbox-gl-js/example/navigation/)
         */
        addControl(control, position) {
          if (position === void 0 && control.getDefaultPosition) {
            position = control.getDefaultPosition();
          }
          if (position === void 0) {
            position = "top-right";
          }
          const controlElement = control.onAdd(this);
          const positionContainer = this._controlPositions[position];
          if (position.indexOf("bottom") !== -1) {
            positionContainer.insertBefore(controlElement, positionContainer.firstChild);
          } else {
            positionContainer.appendChild(controlElement);
          }
          return this;
        }
        /**
         * Removes the control from the map.
         *
         * @param {IControl} control The {@link IControl} to remove.
         * @returns {Map} `this`
         */
        removeControl(control) {
          control.onRemove(this);
          return this;
        }
        /**
         * Resizes the map according to the dimensions of its
         * `container` element.
         *
         * This method must be called after the map's `container` is resized by another script,
         * or when the map is shown after being initially hidden with CSS.
         *
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @returns {Map} `this`
         */
        resize(eventData) {
          const dimensions = this._containerDimensions();
          const width = dimensions[0];
          const height = dimensions[1];
          this._resizeCanvas(width, height);
          this.transform.resize(width, height);
          this.painter.resize(width, height);
          return this.fire(new Event3("movestart", eventData)).fire(new Event3("move", eventData)).fire(new Event3("resize", eventData)).fire(new Event3("moveend", eventData));
        }
        /**
         * Returns the map's geographical bounds. When the bearing or pitch is non-zero, the visible region is not
         * an axis-aligned rectangle, and the result is the smallest bounds that encompasses the visible region.
         *
         * @returns {LngLatBounds}
         */
        getBounds() {
          return new LngLatBounds().extend(this.transform.pointLocation(new Point3(0, 0))).extend(this.transform.pointLocation(new Point3(this.transform.width, 0))).extend(this.transform.pointLocation(new Point3(this.transform.width, this.transform.height))).extend(this.transform.pointLocation(new Point3(0, this.transform.height)));
        }
        /**
         * Gets the map's geographical bounds.
         *
         * Returns the LngLatBounds by which pan and zoom operations on the map are constrained.
         *
         * @returns {LngLatBounds | null} The maximum bounds the map is constrained to, or `null` if none set.
         */
        getMaxBounds() {
          if (this.transform.latRange && this.transform.latRange.length === 2 && this.transform.lngRange && this.transform.lngRange.length === 2) {
            return new LngLatBounds(
              [this.transform.lngRange[0], this.transform.latRange[0]],
              [this.transform.lngRange[1], this.transform.latRange[1]]
            );
          }
          return null;
        }
        /**
         * Sets or clears the map's geographical bounds.
         *
         * Pan and zoom operations are constrained within these bounds.
         * If a pan or zoom is performed that would
         * display regions outside these bounds, the map will
         * instead display a position and zoom level
         * as close as possible to the operation's request while still
         * remaining within the bounds.
         *
         * @param {LngLatBoundsLike | null | undefined} lnglatbounds The maximum bounds to set. If `null` or `undefined` is provided, the function removes the map's maximum bounds.
         * @returns {Map} `this`
         */
        setMaxBounds(lnglatbounds) {
          if (lnglatbounds) {
            const b = LngLatBounds.convert(lnglatbounds);
            this.transform.lngRange = [b.getWest(), b.getEast()];
            this.transform.latRange = [b.getSouth(), b.getNorth()];
            this.transform._constrain();
            this._update();
          } else if (lnglatbounds === null || lnglatbounds === void 0) {
            this.transform.lngRange = null;
            this.transform.latRange = null;
            this._update();
          }
          return this;
        }
        /**
         * Sets or clears the map's minimum zoom level.
         * If the map's current zoom level is lower than the new minimum,
         * the map will zoom to the new minimum.
         *
         * @param {number | null | undefined} minZoom The minimum zoom level to set (0-24).
         *   If `null` or `undefined` is provided, the function removes the current minimum zoom (i.e. sets it to 0).
         * @returns {Map} `this`
         */
        setMinZoom(minZoom) {
          minZoom = minZoom === null || minZoom === void 0 ? defaultMinZoom : minZoom;
          if (minZoom >= defaultMinZoom && minZoom <= this.transform.maxZoom) {
            this.transform.minZoom = minZoom;
            this._update();
            if (this.getZoom() < minZoom) this.setZoom(minZoom);
            return this;
          }
          throw new Error(`minZoom must be between ${defaultMinZoom} and the current maxZoom, inclusive`);
        }
        /**
         * Returns the map's minimum allowable zoom level.
         *
         * @returns {number} minZoom
         */
        getMinZoom() {
          return this.transform.minZoom;
        }
        /**
         * Sets or clears the map's maximum zoom level.
         * If the map's current zoom level is higher than the new maximum,
         * the map will zoom to the new maximum.
         *
         * @param {number | null | undefined} maxZoom The maximum zoom level to set.
         *   If `null` or `undefined` is provided, the function removes the current maximum zoom (sets it to 22).
         * @returns {Map} `this`
         */
        setMaxZoom(maxZoom) {
          maxZoom = maxZoom === null || maxZoom === void 0 ? defaultMaxZoom : maxZoom;
          if (maxZoom >= this.transform.minZoom) {
            this.transform.maxZoom = maxZoom;
            this._update();
            if (this.getZoom() > maxZoom) this.setZoom(maxZoom);
            return this;
          }
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        /**
         * Returns the state of renderWorldCopies.
         *
         * @returns {boolean} renderWorldCopies
         */
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        /**
         * Sets the state of renderWorldCopies.
         *
         * @param {boolean} renderWorldCopies If `true`, multiple copies of the world will be rendered, when zoomed out. `undefined` is treated as `true`, `null` is treated as `false`.
         * @returns {Map} `this`
         */
        setRenderWorldCopies(renderWorldCopies) {
          this.transform.renderWorldCopies = renderWorldCopies;
          this._update();
          return this;
        }
        /**
         * Returns the map's maximum allowable zoom level.
         *
         * @returns {number} maxZoom
         */
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        /**
         * Returns a {@link Point} representing pixel coordinates, relative to the map's `container`,
         * that correspond to the specified geographical location.
         *
         * @param {LngLatLike} lnglat The geographical location to project.
         * @returns {Point} The {@link Point} corresponding to `lnglat`, relative to the map's `container`.
         */
        project(lnglat) {
          return this.transform.locationPoint(LngLat.convert(lnglat));
        }
        /**
         * Returns a {@link LngLat} representing geographical coordinates that correspond
         * to the specified pixel coordinates.
         *
         * @param {PointLike} point The pixel coordinates to unproject.
         * @returns {LngLat} The {@link LngLat} corresponding to `point`.
         * @see [Show polygon information on click](https://www.mapbox.com/mapbox-gl-js/example/polygon-popup-on-click/)
         */
        unproject(point) {
          return this.transform.pointLocation(Point3.convert(point));
        }
        /**
         * Returns true if the map is panning, zooming, rotating, or pitching due to a camera animation or user gesture.
         */
        isMoving() {
          return !!(this._moving || this._mapGestures?.isMoving());
        }
        /**
         * Returns true if the map is zooming due to a camera animation or user gesture.
         */
        isZooming() {
          return !!(this._zooming || this._mapGestures?.isZooming());
        }
        /**
         * Returns true if the map is rotating due to a camera animation or user gesture.
         */
        isRotating() {
          return !!(this._rotating || this._mapGestures?.isRotating());
        }
        /**
         * Returns an array of [GeoJSON](http://geojson.org/)
         * [Feature objects](https://tools.ietf.org/html/rfc7946#section-3.2)
         * representing visible features that satisfy the query parameters.
         *
         * @param {PointLike|Array<PointLike>} [geometry] - The geometry of the query region:
         * either a single point or southwest and northeast points describing a bounding box.
         * Omitting this parameter (i.e. calling {@link Map#queryRenderedFeatures} with zero arguments,
         * or with only a `options` argument) is equivalent to passing a bounding box encompassing the entire
         * map viewport.
         * @param {Object} [options]
         * @param {Array<string>} [options.layers] An array of style layer IDs for the query to inspect.
         *   Only features within these layers will be returned. If this parameter is undefined, all layers will be checked.
         * @param {Array} [options.filter] A [filter](https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter)
         *   to limit query results.
         *
         * @returns {Array<Object>} An array of [GeoJSON](http://geojson.org/)
         * [feature objects](https://tools.ietf.org/html/rfc7946#section-3.2).
         *
         * The `properties` value of each returned feature object contains the properties of its source feature. For GeoJSON sources, only
         * string and numeric property values are supported (i.e. `null`, `Array`, and `Object` values are not supported).
         *
         * Each feature includes top-level `layer`, `source`, and `sourceLayer` properties. The `layer` property is an object
         * representing the style layer to  which the feature belongs. Layout and paint properties in this object contain values
         * which are fully evaluated for the given zoom level and feature.
         *
         * Features from layers whose `visibility` property is `"none"`, or from layers whose zoom range excludes the
         * current zoom level are not included. Symbol features that have been hidden due to text or icon collision are
         * not included. Features from all other layers are included, including features that may have no visible
         * contribution to the rendered result; for example, because the layer's opacity or color alpha component is set to
         * 0.
         *
         * The topmost rendered feature appears first in the returned array, and subsequent features are sorted by
         * descending z-order. Features that are rendered multiple times (due to wrapping across the antimeridian at low
         * zoom levels) are returned only once (though subject to the following caveat).
         *
         * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature
         * geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple
         * times in query results. For example, suppose there is a highway running through the bounding rectangle of a query.
         * The results of the query will be those parts of the highway that lie within the map tiles covering the bounding
         * rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile
         * will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple
         * tiles due to tile buffering.
         *
         * @example
         * // Find all features at a point
         * var features = map.queryRenderedFeatures(
         *   [20, 35],
         *   { layers: ['my-layer-name'] }
         * );
         *
         * @example
         * // Find all features within a static bounding box
         * var features = map.queryRenderedFeatures(
         *   [[10, 20], [30, 50]],
         *   { layers: ['my-layer-name'] }
         * );
         *
         * @example
         * // Find all features within a bounding box around a point
         * var width = 10;
         * var height = 20;
         * var features = map.queryRenderedFeatures([
         *   [point.x - width / 2, point.y - height / 2],
         *   [point.x + width / 2, point.y + height / 2]
         * ], { layers: ['my-layer-name'] });
         *
         * @example
         * // Query all rendered features from a single layer
         * var features = map.queryRenderedFeatures({ layers: ['my-layer-name'] });
         * @see [Get features under the mouse pointer](https://www.mapbox.com/mapbox-gl-js/example/queryrenderedfeatures/)
         * @see [Highlight features within a bounding box](https://www.mapbox.com/mapbox-gl-js/example/using-box-queryrenderedfeatures/)
         * @see [Center the map on a clicked symbol](https://www.mapbox.com/mapbox-gl-js/example/center-on-symbol/)
         */
        queryRenderedFeatures(geometry, options) {
          if (arguments.length === 2) {
            geometry = arguments[0];
            options = arguments[1];
          } else if (arguments.length === 1 && isPointLike(arguments[0])) {
            geometry = arguments[0];
            options = {};
          } else if (arguments.length === 1) {
            geometry = void 0;
            options = arguments[0];
          } else {
            geometry = void 0;
            options = {};
          }
          if (!this.style) {
            return [];
          }
          return this.style.queryRenderedFeatures(this._makeQueryGeometry(geometry), options, this.transform) || [];
          function isPointLike(input) {
            return input instanceof Point3 || Array.isArray(input);
          }
        }
        _makeQueryGeometry(pointOrBox) {
          if (pointOrBox === void 0) {
            pointOrBox = [Point3.convert([0, 0]), Point3.convert([this.transform.width, this.transform.height])];
          }
          let queryGeometry;
          if (pointOrBox instanceof Point3 || typeof pointOrBox[0] === "number") {
            const point = Point3.convert(pointOrBox);
            queryGeometry = [point];
          } else {
            const box = [Point3.convert(pointOrBox[0]), Point3.convert(pointOrBox[1])];
            queryGeometry = [box[0], new Point3(box[1].x, box[0].y), box[1], new Point3(box[0].x, box[1].y), box[0]];
          }
          return {
            viewport: queryGeometry,
            worldCoordinate: queryGeometry.map((p) => {
              return this.transform.pointCoordinate(p);
            })
          };
        }
        /**
         * Returns an array of [GeoJSON](http://geojson.org/)
         * [Feature objects](https://tools.ietf.org/html/rfc7946#section-3.2)
         * representing features within the specified vector tile or GeoJSON source that satisfy the query parameters.
         *
         * @param {string} sourceID The ID of the vector tile or GeoJSON source to query.
         * @param {Object} [parameters]
         * @param {string} [parameters.sourceLayer] The name of the vector tile layer to query. *For vector tile
         *   sources, this parameter is required.* For GeoJSON sources, it is ignored.
         * @param {Array} [parameters.filter] A [filter](https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter)
         *   to limit query results.
         *
         * @returns {Array<Object>} An array of [GeoJSON](http://geojson.org/)
         * [Feature objects](https://tools.ietf.org/html/rfc7946#section-3.2).
         *
         * In contrast to {@link Map#queryRenderedFeatures}, this function
         * returns all features matching the query parameters,
         * whether or not they are rendered by the current style (i.e. visible). The domain of the query includes all currently-loaded
         * vector tiles and GeoJSON source tiles: this function does not check tiles outside the currently
         * visible viewport.
         *
         * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature
         * geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple
         * times in query results. For example, suppose there is a highway running through the bounding rectangle of a query.
         * The results of the query will be those parts of the highway that lie within the map tiles covering the bounding
         * rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile
         * will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple
         * tiles due to tile buffering.
         * @see [Filter features within map view](https://www.mapbox.com/mapbox-gl-js/example/filter-features-within-map-view/)
         * @see [Highlight features containing similar data](https://www.mapbox.com/mapbox-gl-js/example/query-similar-features/)
         */
        querySourceFeatures(sourceID, parameters) {
          return this.style.querySourceFeatures(sourceID, parameters);
        }
        /**
         * Updates the map's Mapbox style object with a new value.  If the given
         * value is style JSON object, compares it against the the map's current
         * state and perform only the changes necessary to make the map style match
         * the desired state.
         *
         * @param style A JSON object conforming to the schema described in the
         *   [Mapbox Style Specification](https://mapbox.com/mapbox-gl-style-spec/), or a URL to such JSON.
         * @param {Object} [options]
         * @param {boolean} [options.diff=true] If false, force a 'full' update, removing the current style
         *   and adding building the given one instead of attempting a diff-based update.
         * @returns {Map} `this`
         * @see [Change a map's style](https://www.mapbox.com/mapbox-gl-js/example/setstyle/)
         */
        setStyle(style, options) {
          if (this.style) {
            this.style.setEventedParent(null);
            this.style._remove();
          }
          if (!style) {
            delete this.style;
            return this;
          }
          this.style = new Style(this, options || {});
          this.style.setEventedParent(this, { style: this.style });
          this.style.loadJSON(style);
          return this;
        }
        /**
         * Returns the map's Mapbox style object, which can be used to recreate the map's style.
         *
         * @returns {Object} The map's style object.
         */
        getStyle() {
          if (this.style) {
            return this.style.serialize();
          }
        }
        /**
         * Returns a Boolean indicating whether the map's style is fully loaded.
         *
         * @returns {boolean} A Boolean indicating whether the style is fully loaded.
         */
        isStyleLoaded() {
          if (!this.style) return warn.once("There is no style added to the map.");
          return this.style.loaded();
        }
        /**
         * Adds a source to the map's style.
         *
         * @param {string} id The ID of the source to add. Must not conflict with existing sources.
         * @param {Object} source The source object, conforming to the
         * Mapbox Style Specification's [source definition](https://www.mapbox.com/mapbox-gl-style-spec/#sources) or
         * {@link CanvasSourceOptions}.
         * @fires source.add
         * @returns {Map} `this`
         * @see [Draw GeoJSON points](https://www.mapbox.com/mapbox-gl-js/example/geojson-markers/)
         * @see [Style circles using data-driven styling](https://www.mapbox.com/mapbox-gl-js/example/data-driven-circle-colors/)
         * @see [Set a point after Geocoder result](https://www.mapbox.com/mapbox-gl-js/example/point-from-geocoder-result/)
         */
        addSource(id, source) {
          this.style.addSource(id, source);
          this._update(true);
          return this;
        }
        /**
         * Returns a Boolean indicating whether the source is loaded.
         *
         * @param {string} id The ID of the source to be checked.
         * @returns {boolean} A Boolean indicating whether the source is loaded.
         */
        isSourceLoaded(id) {
          const source = this.style?.sourceCaches[id];
          if (source === void 0) {
            this.fire(new ErrorEvent3(new Error(`There is no source with ID '${id}'`)));
            return;
          }
          return source.loaded();
        }
        /**
         * Returns a Boolean indicating whether all tiles in the viewport from all sources on
         * the style are loaded.
         *
         * @returns {boolean} A Boolean indicating whether all tiles are loaded.
         */
        areTilesLoaded() {
          const sources = this.style?.sourceCaches;
          for (const id in sources) {
            const source = sources[id];
            const tiles = source._tiles;
            for (const t in tiles) {
              const tile = tiles[t];
              if (!(tile.state === "loaded" || tile.state === "errored")) return false;
            }
          }
          return true;
        }
        /**
         * Removes a source from the map's style.
         *
         * @param {string} id The ID of the source to remove.
         * @returns {Map} `this`
         */
        removeSource(id) {
          this.style.removeSource(id);
          this._update(true);
          return this;
        }
        /**
         * Returns the source with the specified ID in the map's style.
         *
         * @param {string} id The ID of the source to get.
         * @returns {?Object} The style source with the specified ID, or `undefined`
         *   if the ID corresponds to no existing sources.
         * @see [Create a draggable point](https://www.mapbox.com/mapbox-gl-js/example/drag-a-point/)
         * @see [Animate a point](https://www.mapbox.com/mapbox-gl-js/example/animate-point-along-line/)
         * @see [Add live realtime data](https://www.mapbox.com/mapbox-gl-js/example/live-geojson/)
         */
        getSource(id) {
          return this.style.getSource(id);
        }
        /**
         * Add an image to the style. This image can be used in `icon-image`,
         * `background-pattern`, `fill-pattern`, and `line-pattern`. An
         * {@link Map#error} event will be fired if there is not enough space in the
         * sprite to add this image.
         *
         * @see [Add an icon to the map](https://www.mapbox.com/mapbox-gl-js/example/add-image/)
         * @see [Add a generated icon to the map](https://www.mapbox.com/mapbox-gl-js/example/add-image-generated/)
         * @param id The ID of the image.
         * @param image The image as an `HTMLImageElement`, `ImageData`, or object with `width`, `height`, and `data`
         * properties with the same format as `ImageData`.
         * @param options
         * @param options.pixelRatio The ratio of pixels in the image to physical pixels on the screen
         * @param options.sdf Whether the image should be interpreted as an SDF image
         */
        addImage(id, image, { pixelRatio = 1, sdf = false } = {}) {
          if (image instanceof HTMLImageElement) {
            const { width, height, data } = browser.getImageData(image);
            this.style.addImage(id, { data: new RGBAImage({ width, height }, data), pixelRatio, sdf });
          } else if (image.width === void 0 || image.height === void 0) {
            return this.fire(
              new ErrorEvent3(
                new Error(
                  "Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"
                )
              )
            );
          } else {
            const { width, height, data } = image;
            this.style.addImage(id, {
              data: new RGBAImage({ width, height }, new Uint8Array(data)),
              pixelRatio,
              sdf
            });
          }
        }
        /**
         * Define wether the image has been added or not
         *
         * @param id The ID of the image.
         */
        hasImage(id) {
          if (!id) {
            this.fire(new ErrorEvent3(new Error("Missing required image id")));
            return false;
          }
          return !!this.style.getImage(id);
        }
        /**
         * Remove an image from the style (such as one used by `icon-image` or `background-pattern`).
         *
         * @param id The ID of the image.
         */
        removeImage(id) {
          this.style.removeImage(id);
        }
        /**
         * Returns an Array of strings containing the names of all sprites/images currently available in the map
         *
         * @returns {Array<string>} An Array of strings containing the names of all sprites/images currently available in the map
         *
         */
        listImages() {
          return this.style.listImages();
        }
        /**
         * Adds a [Mapbox style layer](https://www.mapbox.com/mapbox-gl-style-spec/#layers)
         * to the map's style.
         *
         * A layer defines styling for data from a specified source.
         *
         * @param {Object} layer The style layer to add, conforming to the Mapbox Style Specification's
         *   [layer definition](https://www.mapbox.com/mapbox-gl-style-spec/#layers).
         * @param {string} [before] The ID of an existing layer to insert the new layer before.
         *   If this argument is omitted, the layer will be appended to the end of the layers array.
         * @returns {Map} `this`
         * @see [Create and style clusters](https://www.mapbox.com/mapbox-gl-js/example/cluster/)
         * @see [Add a vector tile source](https://www.mapbox.com/mapbox-gl-js/example/vector-source/)
         * @see [Add a WMS source](https://www.mapbox.com/mapbox-gl-js/example/wms/)
         */
        addLayer(layer, before) {
          this.style.addLayer(layer, before);
          this._update(true);
          return this;
        }
        /**
         * Moves a layer to a different z-position.
         *
         * @param {string} id The ID of the layer to move.
         * @param {string} [beforeId] The ID of an existing layer to insert the new layer before.
         *   If this argument is omitted, the layer will be appended to the end of the layers array.
         * @returns {Map} `this`
         */
        moveLayer(id, beforeId) {
          this.style.moveLayer(id, beforeId);
          this._update(true);
          return this;
        }
        /**
         * Removes the layer with the given id from the map's style.
         *
         * If no such layer exists, an `error` event is fired.
         *
         * @param {string} id id of the layer to remove
         * @fires error
         */
        removeLayer(id) {
          this.style.removeLayer(id);
          this._update(true);
          return this;
        }
        /**
         * Returns the layer with the specified ID in the map's style.
         *
         * @param {string} id The ID of the layer to get.
         * @returns {?Object} The layer with the specified ID, or `undefined`
         *   if the ID corresponds to no existing layers.
         * @see [Filter symbols by toggling a list](https://www.mapbox.com/mapbox-gl-js/example/filter-markers/)
         * @see [Filter symbols by text input](https://www.mapbox.com/mapbox-gl-js/example/filter-markers-by-input/)
         */
        getLayer(id) {
          return this.style.getLayer(id);
        }
        /**
         * Sets the filter for the specified style layer.
         *
         * @param {string} layer The ID of the layer to which the filter will be applied.
         * @param {Array | null | undefined} filter The filter, conforming to the Mapbox Style Specification's
         *   [filter definition](https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter).  If `null` or `undefined` is provided, the function removes any existing filter from the layer.
         * @returns {Map} `this`
         * @example
         * map.setFilter('my-layer', ['==', 'name', 'USA']);
         * @see [Filter features within map view](https://www.mapbox.com/mapbox-gl-js/example/filter-features-within-map-view/)
         * @see [Highlight features containing similar data](https://www.mapbox.com/mapbox-gl-js/example/query-similar-features/)
         * @see [Create a timeline animation](https://www.mapbox.com/mapbox-gl-js/example/timeline-animation/)
         */
        setFilter(layer, filter) {
          this.style.setFilter(layer, filter);
          this._update(true);
          return this;
        }
        /**
         * Sets the zoom extent for the specified style layer.
         *
         * @param {string} layerId The ID of the layer to which the zoom extent will be applied.
         * @param {number} minzoom The minimum zoom to set (0-24).
         * @param {number} maxzoom The maximum zoom to set (0-24).
         * @returns {Map} `this`
         * @example
         * map.setLayerZoomRange('my-layer', 2, 5);
         */
        setLayerZoomRange(layerId, minzoom, maxzoom) {
          this.style.setLayerZoomRange(layerId, minzoom, maxzoom);
          this._update(true);
          return this;
        }
        /**
         * Returns the filter applied to the specified style layer.
         *
         * @param {string} layer The ID of the style layer whose filter to get.
         * @returns {Array} The layer's filter.
         */
        getFilter(layer) {
          return this.style.getFilter(layer);
        }
        /**
         * Sets the value of a paint property in the specified style layer.
         *
         * @param {string} layer The ID of the layer to set the paint property in.
         * @param {string} name The name of the paint property to set.
         * @param {*} value The value of the paint propery to set.
         *   Must be of a type appropriate for the property, as defined in the [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/).
         * @returns {Map} `this`
         * @example
         * map.setPaintProperty('my-layer', 'fill-color', '#faafee');
         * @see [Change a layer's color with buttons](https://www.mapbox.com/mapbox-gl-js/example/color-switcher/)
         * @see [Adjust a layer's opacity](https://www.mapbox.com/mapbox-gl-js/example/adjust-layer-opacity/)
         * @see [Create a draggable point](https://www.mapbox.com/mapbox-gl-js/example/drag-a-point/)
         */
        setPaintProperty(layer, name, value) {
          this.style.setPaintProperty(layer, name, value);
          this._update(true);
          return this;
        }
        /**
         * Returns the value of a paint property in the specified style layer.
         *
         * @param {string} layer The ID of the layer to get the paint property from.
         * @param {string} name The name of a paint property to get.
         * @returns {*} The value of the specified paint property.
         */
        getPaintProperty(layer, name) {
          return this.style.getPaintProperty(layer, name);
        }
        /**
         * Sets the value of a layout property in the specified style layer.
         *
         * @param {string} layer The ID of the layer to set the layout property in.
         * @param {string} name The name of the layout property to set.
         * @param {*} value The value of the layout propery. Must be of a type appropriate for the property, as defined in the [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/).
         * @returns {Map} `this`
         * @example
         * map.setLayoutProperty('my-layer', 'visibility', 'none');
         */
        setLayoutProperty(layer, name, value) {
          this.style.setLayoutProperty(layer, name, value);
          this._update(true);
          return this;
        }
        /**
         * Returns the value of a layout property in the specified style layer.
         *
         * @param {string} layer The ID of the layer to get the layout property from.
         * @param {string} name The name of the layout property to get.
         * @returns {*} The value of the specified layout property.
         */
        getLayoutProperty(layer, name) {
          return this.style.getLayoutProperty(layer, name);
        }
        /**
         * Sets the any combination of light values.
         *
         * @param light Light properties to set. Must conform to the [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/).
         * @returns {Map} `this`
         */
        setLight(light) {
          this.style.setLight(light);
          this._update(true);
          return this;
        }
        /**
         * Returns the value of the light object.
         *
         * @returns {Object} light Light properties of the style.
         */
        getLight() {
          return this.style.getLight();
        }
        /**
         * Sets the state of a feature. The `state` object is merged in with the existing state of the feature.
         *
         * @param {Object} [feature] Feature identifier. Feature objects returned from
         * {@link Map#queryRenderedFeatures} or event handlers can be used as feature identifiers.
         * @param {string} [feature.source] The Id of the vector source or GeoJSON source for the feature.
         * @param {string} [feature.sourceLayer] (optional)  *For vector tile sources, the sourceLayer is
         *  required.*
         * @param {string} [feature.id] Unique id of the feature.
         * @param {Object} state A set of key-value pairs. The values should be valid JSON types.
         */
        setFeatureState(feature, state) {
          this.style.setFeatureState(feature, state);
          this._update();
        }
        /**
         * Gets the state of a feature.
         *
         * @param {Object} [feature] Feature identifier. Feature objects returned from
         * {@link Map#queryRenderedFeatures} or event handlers can be used as feature identifiers.
         * @param {string} [feature.source] The Id of the vector source or GeoJSON source for the feature.
         * @param {string} [feature.sourceLayer] (optional)  *For vector tile sources, the sourceLayer is
         *  required.*
         * @param {string} [feature.id] Unique id of the feature.
         *
         * @returns {Object} The state of the feature.
         */
        getFeatureState(feature) {
          return this.style.getFeatureState(feature);
        }
        /**
         * Returns the map's containing HTML element.
         *
         * @returns {HTMLElement} The map's container.
         */
        getContainer() {
          return this._container;
        }
        /**
         * Returns the HTML element containing the map's `<canvas>` element.
         *
         * If you want to add non-GL overlays to the map, you should append them to this element.
         *
         * This is the element to which event bindings for map interactivity (such as panning and zooming) are
         * attached. It will receive bubbled events from child elements such as the `<canvas>`, but not from
         * map controls.
         *
         * @returns {HTMLElement} The container of the map's `<canvas>`.
         * @see [Create a draggable point](https://www.mapbox.com/mapbox-gl-js/example/drag-a-point/)
         * @see [Highlight features within a bounding box](https://www.mapbox.com/mapbox-gl-js/example/using-box-queryrenderedfeatures/)
         */
        getCanvasContainer() {
          return this._canvasContainer;
        }
        /**
         * Returns the map's `<canvas>` element.
         *
         * @returns {HTMLCanvasElement} The map's `<canvas>` element.
         * @see [Measure distances](https://www.mapbox.com/mapbox-gl-js/example/measure/)
         * @see [Display a popup on hover](https://www.mapbox.com/mapbox-gl-js/example/popup-on-hover/)
         * @see [Center the map on a clicked symbol](https://www.mapbox.com/mapbox-gl-js/example/center-on-symbol/)
         */
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let width = 0;
          let height = 0;
          if (this._container) {
            width = this._container.offsetWidth || 400;
            height = this._container.offsetHeight || 300;
          }
          return [width, height];
        }
        _setupContainer() {
          const container = this._container;
          container.classList.add("mapboxgl-map");
          const canvasContainer = this._canvasContainer = DOM.create("div", "mapboxgl-canvas-container", container);
          if (this._interactive) {
            canvasContainer.classList.add("mapboxgl-interactive");
          }
          this._canvas = DOM.create("canvas", "mapboxgl-canvas", canvasContainer);
          this._canvas.style.position = "absolute";
          this._canvas.addEventListener("webglcontextlost", this._contextLost, false);
          this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false);
          this._canvas.setAttribute("tabindex", "0");
          this._canvas.setAttribute("aria-label", "Map");
          const dimensions = this._containerDimensions();
          this._resizeCanvas(dimensions[0], dimensions[1]);
          const controlContainer = this._controlContainer = DOM.create("div", "mapboxgl-control-container", container);
          const positions = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((positionName) => {
            positions[positionName] = DOM.create("div", `mapboxgl-ctrl-${positionName}`, controlContainer);
          });
        }
        _resizeCanvas(width, height) {
          const pixelRatio = window.devicePixelRatio || 1;
          this._canvas.width = pixelRatio * width;
          this._canvas.height = pixelRatio * height;
          this._canvas.style.width = `${width}px`;
          this._canvas.style.height = `${height}px`;
        }
        _setupPainter() {
          const attributes = {
            antialias: false,
            alpha: true,
            stencil: true,
            depth: true,
            failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
            preserveDrawingBuffer: this._preserveDrawingBuffer
          };
          const gl = this._canvas.getContext("webgl", attributes) || this._canvas.getContext("experimental-webgl", attributes);
          if (!gl) {
            throw new Error("Failed to initialize WebGL");
          }
          this.painter = new Painter(gl, this.transform);
        }
        _contextLost(event) {
          event.preventDefault();
          if (this._frameId) {
            browser.cancelFrame(this._frameId);
            this._frameId = null;
          }
          this.fire(new Event3("webglcontextlost", { originalEvent: event }));
        }
        _contextRestored(event) {
          this._setupPainter();
          this.resize();
          this._update();
          this.fire(new Event3("webglcontextrestored", { originalEvent: event }));
        }
        /**
         * Returns a Boolean indicating whether the map is fully loaded.
         *
         * Returns `false` if the style is not yet fully loaded,
         * or if there has been a change to the sources or style that
         * has not yet fully loaded.
         *
         * @returns {boolean} A Boolean indicating whether the map is fully loaded.
         */
        loaded() {
          if (this._styleDirty || this._sourcesDirty) return false;
          if (!this.style || !this.style.loaded()) return false;
          return true;
        }
        /**
         * Update this map's style and sources, and re-render the map.
         *
         * @param {boolean} updateStyle mark the map's style for reprocessing as
         * well as its sources
         * @returns {Map} this
         * @private
         */
        _update(updateStyle) {
          if (!this.style) return;
          this._styleDirty = this._styleDirty || updateStyle;
          this._sourcesDirty = true;
          this._rerender();
        }
        /**
         * Request that the given callback be executed during the next render
         * frame.  Schedule a render frame if one is not already scheduled.
         * @returns An id that can be used to cancel the callback
         * @private
         */
        _requestRenderFrame(callback) {
          this._update();
          return this._renderTaskQueue.add(callback);
        }
        _cancelRenderFrame(id) {
          this._renderTaskQueue.remove(id);
        }
        /**
         * Call when a (re-)render of the map is required:
         * - The style has changed (`setPaintProperty()`, etc.)
         * - Source data has changed (e.g. tiles have finished loading)
         * - The map has is moving (or just finished moving)
         * - A transition is in progress
         *
         * @returns {Map} this
         * @private
         */
        _render() {
          this._renderTaskQueue.run();
          let crossFading = false;
          if (this.style && this._styleDirty) {
            this._styleDirty = false;
            const zoom = this.transform.zoom;
            const now = browser.now();
            this.style.zoomHistory.update(zoom, now);
            const parameters = new EvaluationParameters(zoom, {
              now,
              fadeDuration: this._fadeDuration,
              zoomHistory: this.style.zoomHistory,
              transition: this.style.getTransition()
            });
            const factor = parameters.crossFadingFactor();
            if (factor !== 1 || factor !== this._crossFadingFactor) {
              crossFading = true;
              this._crossFadingFactor = factor;
            }
            this.style.update(parameters);
          }
          if (this.style && this._sourcesDirty) {
            this._sourcesDirty = false;
            this.style._updateSources(this.transform);
          }
          this._placementDirty = this.style?._updatePlacement(
            this.painter.transform,
            this.showCollisionBoxes,
            this._fadeDuration,
            this._crossSourceCollisions
          );
          this.painter.render(this.style, {
            showTileBoundaries: this.showTileBoundaries,
            showOverdrawInspector: this._showOverdrawInspector,
            rotating: this.isRotating(),
            zooming: this.isZooming(),
            moving: this.isMoving(),
            fadeDuration: this._fadeDuration
          });
          this.fire(new Event3("render"));
          if (this.loaded() && !this._loaded) {
            this._loaded = true;
            this.fire(new Event3("load"));
          }
          if (this.style && (this.style.hasTransitions() || crossFading)) {
            this._styleDirty = true;
          }
          if (this.style && !this._placementDirty) {
            this.style._releaseSymbolFadeTiles();
          }
          if (this._sourcesDirty || this._repaint || this._styleDirty || this._placementDirty) {
            this._rerender();
          }
          return this;
        }
        /**
         * Clean up and release all internal resources associated with this map.
         *
         * This includes DOM elements, event bindings, web workers, and WebGL resources.
         *
         * Use this method when you are done using the map and wish to ensure that it no
         * longer consumes browser resources. Afterwards, you must not call any other
         * methods on the map.
         */
        remove() {
          browser.cancelFrame(this._frameId);
          this._renderTaskQueue.clear();
          this._frameId = null;
          this.setStyle(null);
          if (typeof window !== "undefined") {
            window.removeEventListener("resize", this._onWindowResize, false);
            window.removeEventListener("online", this._onWindowOnline, false);
          }
          const extension = this.painter.context.gl.getExtension("WEBGL_lose_context");
          if (extension) extension.loseContext();
          removeNode2(this._canvasContainer);
          removeNode2(this._controlContainer);
          this._container.classList.remove("mapboxgl-map");
          this.fire(new Event3("remove"));
        }
        _rerender() {
          if (this.style && !this._frameId) {
            this._frameId = browser.frame(() => {
              this._frameId = null;
              this._render();
            });
          }
        }
        _onWindowOnline() {
          this._update();
        }
        _onWindowResize() {
          if (this._trackResize) {
            this.stop().resize()._update();
          }
        }
        /**
         * Gets and sets a Boolean indicating whether the map will render an outline
         * around each tile. These tile boundaries are useful for debugging.
         *
         * @name showTileBoundaries
         * @type {boolean}
         * @instance
         * @memberof Map
         */
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(value) {
          if (this._showTileBoundaries === value) return;
          this._showTileBoundaries = value;
          this._update();
        }
        /**
         * Gets and sets a Boolean indicating whether the map will render boxes
         * around all symbols in the data source, revealing which symbols
         * were rendered or which were hidden due to collisions.
         * This information is useful for debugging.
         *
         * @name showCollisionBoxes
         * @type {boolean}
         * @instance
         * @memberof Map
         */
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(value) {
          if (this._showCollisionBoxes === value) return;
          this._showCollisionBoxes = value;
          if (value) {
            this.style._generateCollisionBoxes();
          } else {
            this._update();
          }
        }
        /*
         * Gets and sets a Boolean indicating whether the map should color-code
         * each fragment to show how many times it has been shaded.
         * White fragments have been shaded 8 or more times.
         * Black fragments have been shaded 0 times.
         * This information is useful for debugging.
         *
         * @name showOverdraw
         * @type {boolean}
         * @instance
         * @memberof Map
         */
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(value) {
          if (this._showOverdrawInspector === value) return;
          this._showOverdrawInspector = value;
          this._update();
        }
        /**
         * Gets and sets a Boolean indicating whether the map will
         * continuously repaint. This information is useful for analyzing performance.
         *
         * @name repaint
         * @type {boolean}
         * @instance
         * @memberof Map
         */
        get repaint() {
          return !!this._repaint;
        }
        set repaint(value) {
          this._repaint = value;
          this._update();
        }
        // show vertices
        get vertices() {
          return !!this._vertices;
        }
        set vertices(value) {
          this._vertices = value;
          this._update();
        }
        _onData(event) {
          this._update(event.dataType === "style");
          this.fire(new Event3(`${event.dataType}data`, event));
        }
        _onDataLoading(event) {
          this.fire(new Event3(`${event.dataType}dataloading`, event));
        }
      };
      module.exports = Map2;
      function removeNode2(node) {
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
      }
    }
  });

  // node_modules/@mapwhit/tilerenderer/src/index.js
  var require_src = __commonJS({
    "node_modules/@mapwhit/tilerenderer/src/index.js"(exports, module) {
      require_polyfill();
      module.exports = {
        version: require_package().version,
        setRTLTextPlugin: require_rtl_text_plugin().setRTLTextPlugin,
        Map: require_map(),
        Style: require_style(),
        LngLat: require_lng_lat(),
        LngLatBounds: require_lng_lat_bounds(),
        Point: (init_point_geometry(), __toCommonJS(point_geometry_exports)).default,
        Evented: (init_events(), __toCommonJS(events_exports)).Evented,
        config: require_config(),
        get workerCount() {
          return this.config.WORKER_COUNT;
        },
        set workerCount(count) {
          this.config.WORKER_COUNT = count;
        },
        get workerUrl() {
          return this.config.WORKER_URL;
        },
        set workerUrl(url) {
          this.config.WORKER_URL = url;
        }
      };
      var assert = require_nanoassert();
      assert(true, "canary assert");
    }
  });

  // node_modules/@pirxpilot/google-polyline/lib/encode.js
  var require_encode = __commonJS({
    "node_modules/@pirxpilot/google-polyline/lib/encode.js"(exports, module) {
      module.exports = encode;
      function encode(points, { factor = 1e5, prefix = "", mapFn } = {}) {
        let px = 0, py = 0;
        let str = prefix;
        for (let i = 0; i < points.length; ++i) {
          let point = points[i];
          if (mapFn) {
            point = mapFn(point, i, points);
          }
          let x = round(factor * point[0]);
          let y = round(factor * point[1]);
          str = chars(str, sign2(y - py));
          str = chars(str, sign2(x - px));
          px = x;
          py = y;
        }
        return str;
      }
      function round(v) {
        return v < 0 ? -Math.floor(0.5 - v) : Math.round(v);
      }
      function sign2(v) {
        return v < 0 ? ~(v << 1) : v << 1;
      }
      function chars(str, value) {
        while (value >= 32) {
          str += String.fromCharCode((value & 31 | 32) + 63);
          value = value >> 5;
        }
        return str + String.fromCharCode(value + 63);
      }
    }
  });

  // node_modules/@pirxpilot/google-polyline/lib/decode.js
  var require_decode = __commonJS({
    "node_modules/@pirxpilot/google-polyline/lib/decode.js"(exports, module) {
      module.exports = decode2;
      function decode2(value, {
        factor = 1e5,
        mapFn,
        start = 0,
        end = value.length
      } = {}) {
        const points = [];
        let x, y, px = 0, py = 0;
        let point;
        integers(value, start, end, function(v) {
          if (y === void 0) {
            y = v;
            return;
          }
          x = v;
          x = x + px;
          y = y + py;
          point = [x / factor, y / factor];
          if (mapFn) {
            point = mapFn(point);
          }
          points.push(point);
          px = x;
          py = y;
          x = y = void 0;
        });
        return points;
      }
      function sign2(value) {
        return value & 1 ? ~(value >>> 1) : value >>> 1;
      }
      function integers(value, start, end, fn) {
        let byte = 0;
        let current = 0;
        let bits = 0;
        for (let i = start; i < end; i++) {
          byte = value.charCodeAt(i) - 63;
          current = current | (byte & 31) << bits;
          bits += 5;
          if (byte < 32) {
            if (byte === -1 && bits === 5) {
              current = 0;
            }
            fn(sign2(current));
            current = 0;
            bits = 0;
          }
        }
      }
    }
  });

  // node_modules/@pirxpilot/google-polyline/index.js
  var require_google_polyline = __commonJS({
    "node_modules/@pirxpilot/google-polyline/index.js"(exports, module) {
      module.exports = {
        encode: require_encode(),
        decode: require_decode()
      };
    }
  });

  // common.js
  var require_common = __commonJS({
    "common.js"(exports, module) {
      module.exports = {
        bounds: bounds2
      };
      function bounds2(points) {
        return points.reduce(
          function(points2, pt) {
            let i;
            for (i = 0; i < 2; i++) {
              if (pt[i] < points2[0][i]) {
                points2[0][i] = pt[i];
              } else if (pt[i] > points2[1][i]) {
                points2[1][i] = pt[i];
              }
            }
            return points2;
          },
          [points[0].slice(), points[0].slice()]
        );
      }
    }
  });

  // samples/directly.js
  var require_directly = __commonJS({
    "samples/directly.js"(exports, module) {
      module.exports = addedDirectly2;
      function addedDirectly2(maps2, map, source, points, path) {
        const poly = maps2.feature({
          map,
          source,
          data: {
            properties: {
              type: "polyline"
            },
            type: "Feature",
            geometry: {
              type: "LineString",
              coordinates: path
            }
          }
        });
        map.registerImage(
          "marker_icon",
          "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNiIgaGVpZ2h0PSIzMCI+PHBhdGggZD0iTTAgMEgyNlYyNkgxNkwxMyAzMEwxMCAyNkgwWiIgZmlsbD0iI2Y4MDAxMiIvPjxwYXRoIGQ9Ik0yIDJIMjRWMjRIMloiIGZpbGw9IiNmZmYiLz48cGF0aCBkPSJNMjEuOCAxMC40TDcuNSA2LjZWNC40SDYuNFYxOS44SDQuMlYyMkg5LjdWMTkuOEg3LjVWMTQuM1oiIGZpbGw9IiNmODAwMTIiLz48L3N2Zz4=",
          [26, 30]
        ).then(() => {
          const markers = points.map((pt) => {
            return maps2.feature({
              map,
              source,
              data: {
                properties: {
                  type: "marker",
                  opacity: 1
                },
                type: "Feature",
                geometry: {
                  type: "Point",
                  coordinates: pt
                }
              }
            });
          });
          setTimeout(() => {
            markers.forEach((mk, i) => {
              if (i < 10) {
                mk.remove();
              }
              const data = mk.data();
              data.properties = i === 12 || i === 11 || i === 5 ? {
                type: "marker",
                icon: true,
                opacity: 1
              } : {
                type: "marker",
                color: "violet",
                opacity: 1
              };
              mk.data(data);
              if (i < 10) {
                mk.add(map);
              }
            });
            setTimeout(() => {
              markers[5].remove();
              const mData = markers[5].data();
              mData.properties = {
                type: "marker",
                color: "violet",
                opacity: 1
              };
              markers[5].data(mData);
              markers[5].add(map);
              markers.forEach((mk, i) => {
                if (i % 2 === 0) {
                  const data2 = mk.data();
                  data2.properties.opacity = 0;
                  mk.data(data2);
                }
              });
              const data = poly.data();
              delete data.type;
              poly.data(data);
            }, 5e3);
          }, 3e3);
        });
      }
    }
  });

  // samples/collator.js
  var require_collator3 = __commonJS({
    "samples/collator.js"(exports, module) {
      module.exports = addedWithCollator2;
      function addedWithCollator2(maps2, map, source, points, path) {
        maps2.feature({
          map,
          source,
          data: {
            properties: {
              type: "polyline"
            },
            type: "Feature",
            geometry: {
              type: "LineString",
              coordinates: path
            }
          }
        });
        const collate = maps2.collate({
          map
        });
        points.forEach((pt) => {
          const ft = maps2.feature({
            map,
            source,
            data: {
              properties: {
                type: "circle"
              },
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates: pt
              }
            }
          });
          ft.zindex = () => 1;
          collate.add(ft);
        });
        collate.calculate();
      }
    }
  });

  // samples/collator-spreader.js
  var require_collator_spreader = __commonJS({
    "samples/collator-spreader.js"(exports, module) {
      module.exports = addedWithCollatorAndSpreader2;
      function addedWithCollatorAndSpreader2(maps2, map, source, points, path) {
        maps2.feature({
          map,
          source,
          data: {
            properties: {
              type: "polyline"
            },
            type: "Feature",
            geometry: {
              type: "LineString",
              coordinates: path
            }
          }
        });
        function calculate() {
          if (spread && collate) {
            spread.calculate();
            collate.calculate();
          }
        }
        const proj = maps2.projection({
          map,
          calculate
        });
        const spread = maps2.spread({
          map,
          projection: proj
        });
        const collate = maps2.collate({
          map,
          projection: proj
        });
        points.forEach((pt, i) => {
          let m;
          if (i % 2) {
            m = maps2.feature({
              map,
              source,
              data: {
                properties: {
                  type: "circle_orange"
                },
                type: "Feature",
                geometry: {
                  type: "Point",
                  coordinates: pt
                }
              }
            });
            collate.add(m);
          } else {
            m = maps2.feature({
              map,
              source,
              data: {
                properties: {
                  type: "circle_teal"
                },
                type: "Feature",
                geometry: {
                  type: "Point",
                  coordinates: pt
                }
              }
            });
            m.zindex = () => 2;
            spread.add(m);
            collate.add(m, true);
          }
        });
        calculate();
      }
    }
  });

  // samples/spreader.js
  var require_spreader = __commonJS({
    "samples/spreader.js"(exports, module) {
      module.exports = addedWithSpreader2;
      function addedWithSpreader2(maps2, map, source, points, path) {
        maps2.feature({
          map,
          source,
          data: {
            properties: {
              type: "polyline"
            },
            type: "Feature",
            geometry: {
              type: "LineString",
              coordinates: path
            }
          }
        });
        const spread = maps2.spread({
          map,
          threshold: 20
        });
        map.registerImage("circle_label", {
          path: "M 15 8 A 7 7 0 1 0 1 8 A 7 7 0 1 0 15 8",
          fillColor: "teal",
          strokeColor: "#0074D9",
          strokeWeight: 0,
          scale: 10
        }).then(() => {
          points.forEach((pt, i) => {
            spread.add(
              maps2.feature({
                map,
                source,
                data: {
                  properties: {
                    type: "circle_label",
                    label: "" + (i + 1)
                  },
                  type: "Feature",
                  geometry: {
                    type: "Point",
                    coordinates: pt
                  }
                }
              })
            );
          });
          spread.calculate();
        });
      }
    }
  });

  // samples/china.js
  var require_china = __commonJS({
    "samples/china.js"(exports, module) {
      module.exports = sampleChina2;
      function sampleChina2(srv, map, source) {
        const center = [116.383473, 39.903331];
        const path = [center, [center[0] - 1e-3, center[1] + 1e-3], [center[0] + 1e-3, center[1] + 1e-3], center];
        const poly = [center, [center[0] - 1e-3, center[1] - 1e-3], [center[0] + 1e-3, center[1] - 1e-3], center];
        srv.feature({
          map,
          source,
          data: {
            properties: {
              type: "china_circle"
            },
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: center
            }
          }
        });
        srv.feature({
          map,
          source,
          data: {
            properties: {
              type: "china_line"
            },
            type: "Feature",
            geometry: {
              type: "LineString",
              coordinates: path
            }
          }
        });
        srv.feature({
          map,
          source,
          data: {
            properties: {
              type: "china_polygon"
            },
            type: "Feature",
            geometry: {
              type: "Polygon",
              coordinates: [poly]
            }
          }
        });
        setTimeout(function() {
          map.move({ zoom: 17, center }, false);
        }, 0);
      }
    }
  });

  // samples/markers.js
  var require_markers = __commonJS({
    "samples/markers.js"(exports, module) {
      module.exports = sampleMarkers2;
      function sampleMarkers2(srv, map, source) {
        let i;
        let mk;
        map.center([0.5, 0]);
        map.zoom(9);
        Promise.all([
          map.registerImage("markers_circle", {
            path: "M 15 8 A 7 7 0 1 0 1 8 A 7 7 0 1 0 15 8",
            fillColor: "transparent",
            strokeColor: "#0074D9",
            strokeWeight: 2
          }),
          map.registerImage("markers_flag", {
            path: "M 2 0 L 2 0.28125 L 2 13.6875 L 2 14 L 0.59375 14 L 0 14 L 0 14.59375 L 0 15.375 L 0 16 L 0.59375 16 L 4.40625 16 L 5 16 L 5 15.375 L 5 14.59375 L 5 14 L 4.40625 14 L 3 14 L 3 13.6875 L 3 9 L 16 5.5 L 3 2 L 3 0.28125 L 3 0 L 2.6875 0 L 2.3125 0 L 2 0 z ",
            fillColor: "orange",
            strokeColor: "orange",
            strokeWeight: 1
          }),
          map.registerImage(
            "markers_icon",
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNiIgaGVpZ2h0PSIzMCI+PHBhdGggZD0iTTAgMEgyNlYyNkgxNkwxMyAzMEwxMCAyNkgwWiIgZmlsbD0iI2Y4MDAxMiIvPjxwYXRoIGQ9Ik0yIDJIMjRWMjRIMloiIGZpbGw9IiNmZmYiLz48cGF0aCBkPSJNMjEuOCAxMC40TDcuNSA2LjZWNC40SDYuNFYxOS44SDQuMlYyMkg5LjdWMTkuOEg3LjVWMTQuM1oiIGZpbGw9IiNmODAwMTIiLz48L3N2Zz4=",
            [26, 30]
          )
        ]).then(() => {
          for (i = 0; i <= 8; i += 1) {
            let animate = i === 3;
            mk = srv.feature({
              map,
              source,
              animation: animate && "offset",
              data: {
                properties: {
                  type: "markers_symbol",
                  image: "markers_circle",
                  offset: [0, 0],
                  range: animate && 64,
                  size: (1 + i) / 8
                },
                type: "Feature",
                geometry: {
                  type: "Point",
                  coordinates: [i / 8, 3 / 8]
                }
              }
            });
            if (animate) {
              mk.animation("bounce");
              setTimeout(mk.animation, 15 * 1e3);
            }
            srv.feature({
              map,
              source,
              data: {
                properties: {
                  type: "markers_symbol",
                  image: "markers_flag",
                  offset: [16, -16],
                  size: (1 + i) / 7
                },
                type: "Feature",
                geometry: {
                  type: "Point",
                  coordinates: [i / 8, 1 / 8]
                }
              }
            });
            animate = i === 4;
            mk = srv.feature({
              map,
              source,
              animation: animate && "offset",
              data: {
                properties: {
                  type: "markers_symbol",
                  image: "markers_icon",
                  size: 0.5,
                  offset: [0, -30]
                },
                type: "Feature",
                geometry: {
                  type: "Point",
                  coordinates: [i / 8, -1 / 8]
                }
              }
            });
            if (animate) {
              mk.animation("bounce");
              setTimeout(mk.animation, 15 * 1e3);
            }
          }
        });
      }
    }
  });

  // samples/index.js
  var require_samples = __commonJS({
    "samples/index.js"(exports, module) {
      module.exports = {
        addedDirectly: require_directly(),
        addedWithCollator: require_collator3(),
        addedWithCollatorAndSpreader: require_collator_spreader(),
        addedWithSpreader: require_spreader(),
        sampleChina: require_china(),
        sampleMarkers: require_markers()
      };
    }
  });

  // node_modules/@mapwhit/map-style/lib/caching/expression.js
  var require_expression2 = __commonJS({
    "node_modules/@mapwhit/map-style/lib/caching/expression.js"(exports, module) {
      module.exports = check;
      function checkSingleProperty(property, object) {
        return object[property];
      }
      function checkProperty(property) {
        return checkSingleProperty(property, this);
      }
      function checkAnyProperty(properties, object) {
        return properties.some(checkProperty, object);
      }
      function checkAllProperties(properties, object) {
        return properties.every(checkProperty, object);
      }
      function check(expr) {
        if (Array.isArray(expr)) {
          if (expr[0] === "all") {
            return checkAllProperties.bind(void 0, expr.slice(1));
          }
          return checkAnyProperty.bind(void 0, expr.slice(1));
        }
        return checkSingleProperty.bind(void 0, expr);
      }
    }
  });

  // node_modules/@mapwhit/map-style/lib/caching/index.js
  var require_caching = __commonJS({
    "node_modules/@mapwhit/map-style/lib/caching/index.js"(exports, module) {
      var expression = require_expression2();
      module.exports = {
        initCaching,
        getStrategy
      };
      function initCaching(caching) {
        if (!caching) {
          return;
        }
        const result = Object.keys(caching).reduce(transformCaching, {
          caching,
          checks: []
        });
        return result.checks;
      }
      function checkStrategy(check) {
        this.strategy = check(this.object);
        return this.strategy;
      }
      function getStrategy(checks, object) {
        if (!checks) {
          return;
        }
        const result = {
          object
        };
        checks.some(checkStrategy, result);
        return result.strategy;
      }
      function checkDefault(strategy) {
        return strategy;
      }
      function checkProperty(strategy, check, object) {
        if (check(object)) {
          return strategy;
        }
      }
      function transformCaching(result, key) {
        const { caching, checks } = result;
        if (key === "default") {
          checks.push(checkDefault.bind(void 0, caching[key]));
        } else {
          checks.unshift(checkProperty.bind(void 0, key, expression(caching[key])));
        }
        return result;
      }
    }
  });

  // node_modules/mlasq/lib/mlasq.js
  var require_mlasq = __commonJS({
    "node_modules/mlasq/lib/mlasq.js"(exports, module) {
      module.exports = database;
      function database(name, stores, version = 1) {
        let dbFuture;
        const self2 = {
          store: getStore,
          execute,
          close,
          remove
        };
        return self2;
        function getStore(name2) {
          return store(self2, name2);
        }
        async function execute(operation) {
          if (!dbFuture) {
            dbFuture = do_open(name, stores, version);
          }
          return operation(await dbFuture);
        }
        async function close() {
          if (dbFuture) {
            const db = await dbFuture;
            db.close();
            dbFuture = void 0;
          }
        }
        async function remove() {
          await close();
          const request = indexedDB.deleteDatabase(name);
          await addHandlers(request);
        }
      }
      function store(db, name) {
        return {
          put,
          get,
          getAll,
          getAllKeys,
          update,
          remove,
          count,
          clear
        };
        function put(key, item) {
          return db.execute((db2) => do_put(db2, name, key, item));
        }
        function get(key) {
          return db.execute((db2) => do_get(db2, name, key));
        }
        function getAll() {
          return db.execute((db2) => do_getAll(db2, name));
        }
        function getAllKeys() {
          return db.execute((db2) => do_getAllKeys(db2, name));
        }
        function update(key, item) {
          return db.execute((db2) => do_update(db2, name, key, item));
        }
        function count(key) {
          return db.execute((db2) => do_count(db2, name, key));
        }
        function remove(key) {
          return db.execute((db2) => do_delete(db2, name, key));
        }
        function clear() {
          return db.execute((db2) => do_clear(db2, name));
        }
      }
      function do_open(name, stores, version) {
        const request = indexedDB.open(name, version);
        request.onupgradeneeded = ({ target }) => {
          const db = target.result;
          const existing = new Set(db.objectStoreNames);
          const desired = new Set(stores);
          existing.forEach((store2) => {
            if (!desired.has(store2)) {
              db.deleteObjectStore(store2);
            }
          });
          desired.forEach((store2) => {
            if (!existing.has(store2)) {
              db.createObjectStore(store2);
            }
          });
        };
        return addHandlers(request);
      }
      function do_put(db, store2, key, item) {
        const request = db.transaction(store2, "readwrite").objectStore(store2).put(item, key);
        return addHandlers(request);
      }
      function do_get(db, store2, key) {
        const request = db.transaction(store2).objectStore(store2).get(key);
        return addHandlers(request);
      }
      function do_getAll(db, store2) {
        const request = db.transaction(store2).objectStore(store2).getAll();
        return addHandlers(request);
      }
      function do_getAllKeys(db, store2) {
        const request = db.transaction(store2).objectStore(store2).getAllKeys();
        return addHandlers(request);
      }
      async function do_update(db, store2, key, item) {
        const s = db.transaction(store2, "readwrite").objectStore(store2);
        const getRequest = s.get(key);
        const result = await addHandlers(getRequest);
        const updated = result ? Object.assign(result, item) : item;
        const putRequest = s.put(updated, key);
        key = await addHandlers(putRequest);
        return [key, updated];
      }
      function do_count(db, store2, key) {
        const request = db.transaction(store2).objectStore(store2).count(key);
        return addHandlers(request);
      }
      function do_delete(db, store2, key) {
        const request = db.transaction(store2, "readwrite").objectStore(store2).delete(key);
        return addHandlers(request);
      }
      function do_clear(db, store2) {
        const request = db.transaction(store2, "readwrite").objectStore(store2).clear();
        return addHandlers(request);
      }
      function addHandlers(request) {
        return new Promise((resolve, reject) => {
          request.onerror = (e) => reject(e.target.error);
          request.onsuccess = (e) => resolve(e.target.result);
        });
      }
    }
  });

  // node_modules/mlasq/lib/dummy.js
  var require_dummy = __commonJS({
    "node_modules/mlasq/lib/dummy.js"(exports, module) {
      module.exports = database;
      function database() {
        const self2 = {
          store,
          close: noopCallback(),
          remove: noopCallback()
        };
        return self2;
      }
      function store() {
        const self2 = {
          put: noopCallback((id) => id),
          get: noopCallback(),
          update: noopCallback((id, item) => [id, item]),
          remove: noopCallback(),
          clear: noopCallback(),
          count: noopCallback(() => 0)
        };
        return self2;
      }
      function noopCallback(processArgs = () => {
      }) {
        return function(...myArgs) {
          if (typeof myArgs.at(-1) !== "function") {
            return processArgs(...myArgs);
          }
          const fn = myArgs.pop();
          const result = processArgs(...myArgs);
          return Array.isArray(result) ? fn(null, ...result) : fn(null, result);
        };
      }
    }
  });

  // node_modules/mlasq/index.js
  var require_mlasq2 = __commonJS({
    "node_modules/mlasq/index.js"(exports, module) {
      var mlasq = require_mlasq();
      var dummy = require_dummy();
      module.exports = detect() ? mlasq : dummy;
      function detect() {
        return typeof self !== "undefined" && "indexedDB" in self && !("_mlasq_old_browser" in self);
      }
    }
  });

  // node_modules/tile-cache/lib/is-supported.js
  var require_is_supported = __commonJS({
    "node_modules/tile-cache/lib/is-supported.js"(exports, module) {
      var mlasq = require_mlasq2();
      module.exports = isSupported;
      function equalBuffers(a, b) {
        if (a === b) {
          return true;
        }
        if (!(a && b)) {
          return false;
        }
        if (a.byteLength !== b.byteLength) {
          return false;
        }
        const av = new Uint8Array(a);
        const bv = new Uint8Array(b);
        let i = av.length;
        while (i--) {
          if (av[i] !== bv[i]) {
            return false;
          }
        }
        return true;
      }
      async function isSupported() {
        const db = mlasq("test-tile-cache", ["data"]);
        const data = new Uint8Array([1, 2]).buffer;
        const key = ["a", 5];
        try {
          const store = db.store("data");
          await store.put(key, data);
          const supported = equalBuffers(data, await store.get(key));
          return supported;
        } finally {
          await db.remove();
        }
      }
    }
  });

  // node_modules/tile-cache/lib/tile-cache.js
  var require_tile_cache2 = __commonJS({
    "node_modules/tile-cache/lib/tile-cache.js"(exports, module) {
      module.exports = {
        put,
        get,
        check,
        drop,
        remove,
        supported: require_is_supported()
      };
      var db = require_mlasq2()("tile-cache", ["tiles", "fonts", "data", "images"]);
      var stores = {
        tile: db.store("tiles"),
        font: db.store("fonts"),
        json: db.store("data"),
        image: db.store("images")
      };
      function put(name, key, data) {
        return stores[name].put(key, data);
      }
      function get(name, key) {
        return stores[name].get(key);
      }
      function remove(name, key) {
        return stores[name].remove(key);
      }
      async function check(name, key) {
        const store = stores[name];
        const count = await store.count(key);
        return count > 0;
      }
      function drop(name) {
        return stores[name].clear();
      }
    }
  });

  // node_modules/tile-cache/index.js
  var require_tile_cache3 = __commonJS({
    "node_modules/tile-cache/index.js"(exports, module) {
      module.exports = require_tile_cache2();
    }
  });

  // node_modules/@mapwhit/map-style/lib/cache.js
  var require_cache = __commonJS({
    "node_modules/@mapwhit/map-style/lib/cache.js"(exports, module) {
      var tileCache = require_tile_cache3();
      module.exports = { from, update };
      function from(params, store = "json") {
        return tileCache.get(store, getKey(params));
      }
      function update(params, data, store = "json") {
        return tileCache.put(store, getKey(params), data);
      }
      function getKey({ url, fontstack, range, x, y, z }) {
        if (fontstack) {
          return [fontstack, Number.parseInt(range, 10)];
        }
        if (x !== void 0) {
          return [x, y, z];
        }
        return url;
      }
    }
  });

  // node_modules/@mapwhit/map-style/lib/loader.js
  var require_loader = __commonJS({
    "node_modules/@mapwhit/map-style/lib/loader.js"(exports, module) {
      var cache = require_cache();
      module.exports = selectStrategy;
      var strategies = {
        "network-only": networkOnly,
        "network-first": networkFirst,
        "network-then-cache": networkThenCache,
        "network-first-then-cache": networkFirstThenCache,
        "cache-only": cacheOnly,
        "cache-first": cacheFirst,
        "cache-first-then-cache": cacheFirstThenCache,
        "do-nothing": doNothing
      };
      function selectStrategy(strategy = "network-only") {
        return strategies[strategy] ?? networkOnly;
      }
      var fetchType = {
        json: fetchJSON,
        image: fetchData,
        font: fetchData,
        tile: fetchData
      };
      async function networkOnly(params, type = "json") {
        const { url, transform, controller } = params;
        const signal = controller?.signal;
        const res = await fetch(url, { signal });
        const data = await fetchType[type](res);
        if (!data) {
          return res;
        }
        if (transform?.pre) {
          return await transform.pre(data);
        }
        return data;
      }
      function cacheOnly(params, type = "json") {
        return cache.from(params, type);
      }
      async function doNothing() {
      }
      async function networkThenCache(params, type = "json") {
        const received = await networkOnly(params, type);
        if (received) {
          let data = received;
          const { transform } = params;
          if (transform?.post) {
            data = await transform.post(data);
          }
          if (data) {
            cache.update(params, data, type);
          }
        }
        return received;
      }
      function networkFirst(params, type = "json") {
        return untilSuccess([networkOnly, cacheOnly], params, type);
      }
      function cacheFirst(params, type = "json") {
        return untilSuccess([cacheOnly, networkOnly], params, type);
      }
      async function networkFirstThenCache(params, type = "json") {
        return untilSuccess([networkThenCache, cacheOnly], params, type);
      }
      async function cacheFirstThenCache(params, type = "json") {
        return untilSuccess([cacheOnly, networkThenCache], params, type);
      }
      async function untilSuccess(tasks, params, type) {
        while (tasks.length > 1) {
          const task = tasks.shift();
          const received = await task(params, type);
          if (received) {
            if (received.byteLength === 0) {
              continue;
            }
            return received;
          }
        }
        return tasks[0](params, type);
      }
      function fetchJSON(res) {
        return res.json();
      }
      function fetchData(res) {
        return res.arrayBuffer();
      }
    }
  });

  // node_modules/@mapwhit/map-style/lib/glyphs.js
  var require_glyphs = __commonJS({
    "node_modules/@mapwhit/map-style/lib/glyphs.js"(exports, module) {
      module.exports = loadGlyphs;
      function loadGlyphs(load, glyphs) {
        return (fontstack, range) => {
          const begin = range * 256;
          const end = begin + 255;
          const url = glyphs.replace("{fontstack}", fontstack).replace("{range}", `${begin}-${end}`);
          return load({ url, fontstack, range }, "font");
        };
      }
    }
  });

  // node_modules/@mapwhit/map-style/lib/sprite.js
  var require_sprite = __commonJS({
    "node_modules/@mapwhit/map-style/lib/sprite.js"(exports, module) {
      module.exports = {
        selectSprite,
        loadSprite
      };
      function selectSprite(baseUrl, urls) {
        return urlsFromMetaData(urls) ?? urlsFromMetaData(baseUrl) ?? urlsFromBase(baseUrl);
      }
      async function loadSprite(load, sprite) {
        const [json, image] = await Promise.all([load({ url: sprite.json }, "json"), load({ url: sprite.src }, "image")]);
        return { json, image };
      }
      function urlsFromBase(baseUrl) {
        const format = window.devicePixelRatio > 1 ? "@2x" : "";
        return {
          json: `${baseUrl}${format}.json`,
          src: `${baseUrl}${format}.png`
        };
      }
      function urlsFromMetaData(urls) {
        if (!Array.isArray(urls)) {
          return;
        }
        let index = Math.round(window.devicePixelRatio || 1) - 1;
        if (index >= urls.length) {
          index = urls.length - 1;
        }
        return urls[index];
      }
    }
  });

  // node_modules/@mapwhit/map-style/lib/localize.js
  var require_localize = __commonJS({
    "node_modules/@mapwhit/map-style/lib/localize.js"(exports, module) {
      module.exports = localize;
      function localize(lang) {
        if (!lang) {
          return;
        }
        return ["coalesce", ["get", `name:${lang}`], ["get", "name:latin"], ["get", "name_int"], ["get", "name"], ""];
      }
    }
  });

  // node_modules/@mapwhit/map-style/lib/source/geojson.js
  var require_geojson = __commonJS({
    "node_modules/@mapwhit/map-style/lib/source/geojson.js"(exports, module) {
      var { initCaching, getStrategy } = require_caching();
      module.exports = {
        init,
        reset
      };
      function init(loader, source, style, options) {
        if (!source.data || typeof source.data !== "string") {
          return;
        }
        source.metadata = source.metadata ?? {};
        source.metadata.caching = initCaching(source.metadata.caching) ?? style.metadata.caching;
        source.data = initJSON(loader, source);
        reset(source, options);
      }
      function reset(source, options) {
        source.data?.resetLoad?.(options);
      }
      function initJSON(loader, source) {
        const {
          metadata: { caching },
          data
        } = source;
        let load;
        async function loadJSON() {
          const json = await load({ url: data }, "json");
          if (!json) {
            return;
          }
          source.data = json;
          return json;
        }
        function resetLoad(options) {
          load = loader(getStrategy(caching, options));
          loadJSON();
        }
        loadJSON.resetLoad = resetLoad;
        return loadJSON;
      }
    }
  });

  // node_modules/@mapwhit/map-style/lib/source/image.js
  var require_image3 = __commonJS({
    "node_modules/@mapwhit/map-style/lib/source/image.js"(exports, module) {
      var { initCaching, getStrategy } = require_caching();
      module.exports = {
        init,
        reset
      };
      function init(loader, source, style, options) {
        if (!source.url) {
          return;
        }
        source.metadata = source.metadata ?? {};
        source.metadata.caching = initCaching(source.metadata.caching) ?? style.metadata.caching;
        source.url = initImage(loader, source);
        reset(source, options);
      }
      function reset(source, options) {
        source.url?.resetLoad?.(options);
      }
      function initImage(loader, source) {
        const {
          metadata: { caching },
          url
        } = source;
        let load;
        async function loadImage() {
          const data = await load({ url }, "image");
          if (!data) {
            return;
          }
          source.url = data;
        }
        function resetLoad(options) {
          load = loader(getStrategy(caching, options));
          loadImage();
        }
        loadImage.resetLoad = resetLoad;
        return loadImage;
      }
    }
  });

  // node_modules/@mapwhit/map-style/lib/source/tiles.js
  var require_tiles = __commonJS({
    "node_modules/@mapwhit/map-style/lib/source/tiles.js"(exports, module) {
      var { initCaching, getStrategy } = require_caching();
      module.exports = {
        init,
        reset
      };
      function init(loader, source, style, options) {
        if (!source.tiles) {
          return;
        }
        source.metadata = source.metadata ?? {};
        source.metadata.caching = initCaching(source.metadata.caching) ?? style.metadata.caching;
        source.tiles = initTiles(loader, source);
        reset(source, options);
      }
      function reset(source, options) {
        source.tiles?.resetLoad(options);
      }
      function initTiles(loader, source) {
        const {
          metadata: { caching },
          scheme,
          tiles
        } = source;
        let load;
        function loadTile({ x, y, z }, controller) {
          const url = tiles[(x + y) % tiles.length].replace("{prefix}", (x % 16).toString(16) + (y % 16).toString(16)).replace("{z}", String(z)).replace("{x}", String(x)).replace("{y}", String(scheme === "tms" ? 2 ** z - y - 1 : y));
          return load({ url, x, y, z, controller }, "tile");
        }
        function resetLoad(options) {
          load = loader(getStrategy(caching, options));
        }
        loadTile.resetLoad = resetLoad;
        return loadTile;
      }
    }
  });

  // node_modules/@mapwhit/map-style/lib/source/index.js
  var require_source2 = __commonJS({
    "node_modules/@mapwhit/map-style/lib/source/index.js"(exports, module) {
      module.exports = {
        geojson: require_geojson(),
        image: require_image3(),
        raster: require_tiles(),
        "raster-dem": require_tiles(),
        vector: require_tiles()
      };
    }
  });

  // node_modules/@mapwhit/map-style/lib/map-style.js
  var require_map_style = __commonJS({
    "node_modules/@mapwhit/map-style/lib/map-style.js"(exports, module) {
      var { initCaching } = require_caching();
      var loader = require_loader();
      var loadGlyphs = require_glyphs();
      var { loadSprite, selectSprite } = require_sprite();
      var localize = require_localize();
      var sourceLoaders = require_source2();
      module.exports = {
        mapStyle: mapStyle2,
        reset
      };
      async function mapStyle2(url, cacheStrategy, options = {}) {
        const load = loader(cacheStrategy);
        const style = await load(
          {
            url,
            transform: {
              pre: instantiateSources,
              post: cacheableOnly
            }
          },
          "json"
        );
        if (style.sprite) {
          style.sprite = await loadSprite(load, style.sprite);
        }
        if (style.glyphs) {
          style.glyphs = loadGlyphs(load, style.glyphs);
        }
        initSources(style, options);
        initLayers(style, options);
        return style;
        async function instantiateSources(style2) {
          if (style2.sources) {
            const indirectSources = Object.entries(style2.sources).filter(
              ([, source]) => source.url && source.type !== "image"
            );
            const controller = new AbortController();
            const abortTimeout = setTimeout(() => {
              controller.abort();
            }, 3e3);
            const loadedSources = await Promise.allSettled(
              indirectSources.map(
                ([, source]) => load(
                  {
                    url: source.url,
                    transform: { post: doNotCache },
                    controller
                  },
                  "json"
                )
              )
            );
            clearTimeout(abortTimeout);
            indirectSources.forEach(([sourceId, source], index) => {
              delete source.url;
              const loadedSource = loadedSources[index];
              if (loadedSource.status === "fulfilled") {
                delete loadedSource.value.type;
                Object.assign(source, loadedSource.value);
              } else {
                delete style2.sources[sourceId];
              }
            });
          }
          if (style2.sprite) {
            style2.sprite = selectSprite(style2.sprite, style2.metadata?.sprite);
          }
          return style2;
        }
      }
      function reset(style, options = {}) {
        resetSources(style, options);
        resetLayers(style, options);
      }
      function doNotCache() {
        return;
      }
      function cacheableOnly(style) {
        const { version, name, metadata, sources, sprite, glyphs, layers } = style;
        const cached = {
          version,
          name,
          metadata: Object.assign({}, metadata),
          sprite,
          glyphs
        };
        const cacheDefault = isCacheable(metadata?.caching);
        if (sources) {
          cached.sources = Object.entries(sources).reduce((result, [key, source]) => {
            const cacheable = source.metadata?.caching ? isCacheable(source.metadata?.caching) : cacheDefault;
            if (cacheable) {
              result[key] = Object.assign({}, source);
            }
            return result;
          }, {});
        }
        if (layers) {
          cached.layers = layers.reduce((result, layer) => {
            const { source } = layer;
            if (!source || cached.sources[source]) {
              result.push(layer);
            }
            return result;
          }, []);
        }
        return cached;
      }
      function isCacheable(caching) {
        if (!caching) {
          return;
        }
        const keys = Object.keys(caching);
        if (caching.default) {
          keys.push(caching.default);
        }
        return keys.some((key) => key.startsWith("cache-"));
      }
      function initSources(style, options) {
        if (!style.sources) {
          return;
        }
        style.metadata = style.metadata ?? {};
        style.metadata.caching = initCaching(style.metadata.caching);
        Object.values(style.sources).forEach((source) => {
          sourceLoaders[source.type]?.init(loader, source, style, options);
        });
      }
      function resetSources({ sources }, options = {}) {
        if (!sources) {
          return;
        }
        Object.values(sources).forEach((source) => {
          sourceLoaders[source.type]?.reset(source, options);
        });
      }
      function initLayers(style, options) {
        if (!style.layers) {
          return;
        }
        const textField = localize(options.language);
        if (!textField) {
          return;
        }
        style.layers.forEach((layer) => {
          if (layer.layout?.["text-field"] === "{name}") {
            layer.metadata = layer.metadata ?? {};
            layer.metadata["text-field"] = "{name}";
            layer.layout["text-field"] = textField;
          }
        });
      }
      function resetLayers({ layers }, options = {}) {
        if (!layers) {
          return;
        }
        const textField = localize(options.language) ?? "{name}";
        layers.forEach((layer) => {
          if (layer.layout?.["text-field"] === "{name}" || layer.metadata?.["text-field"] === "{name}") {
            layer.metadata = layer.metadata ?? {};
            layer.metadata["text-field"] = "{name}";
            layer.layout["text-field"] = textField;
          }
        });
      }
    }
  });

  // node_modules/@mapwhit/map-style/index.js
  var require_map_style2 = __commonJS({
    "node_modules/@mapwhit/map-style/index.js"(exports, module) {
      module.exports = require_map_style();
    }
  });

  // ../lib/util.js
  var require_util2 = __commonJS({
    "../lib/util.js"(exports, module) {
      function distance(p1, p2) {
        return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
      }
      function between(p, p1, p2, l) {
        if (p1[l] <= p2[l]) {
          return p[l] >= p1[l] && p[l] <= p2[l];
        }
        return p[l] >= p2[l] && p[l] <= p1[l];
      }
      function distanceSquare(p1, p2) {
        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2;
      }
      function pointOnLine(p, p1, p2) {
        if (p1[0] === p2[0]) {
          return [p1[0], p[1]];
        }
        if (p1[1] === p2[1]) {
          return [p[0], p1[1]];
        }
        const m1 = (p2[1] - p1[1]) / (p2[0] - p1[0]);
        const m2 = -1 / m1;
        const x = (m1 * p1[0] - m2 * p[0] + p[1] - p1[1]) / (m1 - m2);
        const y = m2 * (x - p[0]) + p[1];
        return [x, y];
      }
      function closestPoint(res, p1, i, path) {
        let p2;
        let p;
        if (Math.abs(res.point[0] - p1[0]) < res.margin[0] && Math.abs(res.point[1] - p1[1]) < res.margin[1]) {
          p = p1;
        } else if (i < path.length - 1) {
          p2 = path[i + 1];
          p = pointOnLine(res.point, p1, p2);
          p = between(p, p1, p2, 0) && between(p, p1, p2, 1) && p;
        }
        if (p) {
          const dist = distanceSquare(res.point, p);
          if (dist < res.dist) {
            res.dist = dist;
            res.idx = i;
            res.p = p;
          }
        }
        return res;
      }
      function findPointOnPath(point, path, margin) {
        if (point && path && margin) {
          const result = path.reduce(closestPoint, {
            dist: Number.MAX_VALUE,
            point,
            margin
          });
          if (result.idx !== void 0) {
            point = path[result.idx];
            result.pol = result.p !== path[result.idx] && (result.idx === path.length - 1 || result.p !== path[result.idx + 1]);
            return result;
          }
        }
      }
      function mll2ll(mll) {
        return mll.toArray();
      }
      function mbounds2bounds(mb) {
        return mb && [mb.getSouthWest(), mb.getNorthEast()].map(mll2ll);
      }
      module.exports = {
        distance,
        findPoint: findPointOnPath,
        mbounds2bounds,
        mll2ll
      };
    }
  });

  // ../lib/zindex.js
  var require_zindex = __commonJS({
    "../lib/zindex.js"(exports, module) {
      module.exports = zindex;
      function zindex(feature) {
        const {
          _data: { id: featureId },
          _layers,
          _m,
          _source
        } = feature;
        const zIndexValues = new Map(_layers.map((layer, i) => [layer, i]));
        let zi = 0;
        _m?.queryRenderedFeatures({ _layers }).forEach(({ id, layer: { id: layerId }, source }) => {
          if (id === featureId && source === _source) {
            zi = Math.max(zi, zIndexValues.get(layerId));
          }
        });
        return zi;
      }
    }
  });

  // ../lib/collate.js
  var require_collate = __commonJS({
    "../lib/collate.js"(exports, module) {
      var { distance } = require_util2();
      var zindex = require_zindex();
      module.exports = collate;
      function collate(options) {
        let regions;
        let markers = [];
        const threshold = options.threshold || 18;
        const proj = options.projection || this.projection({
          map: options.map,
          calculate
        });
        return {
          add,
          reset,
          calculate
        };
        function reset() {
          markers = [];
          regions = void 0;
        }
        function add(marker, referenceOnly) {
          marker.referenceOnly = referenceOnly;
          markers.push(marker);
        }
        function calculate() {
          if (!proj.isReady()) {
            return;
          }
          regions = [];
          prepareRegions();
          hideMarkers();
        }
        function prepareRegions() {
          markers.forEach(function(m) {
            if (!regions.some(function(r) {
              return addToRegion(r, m);
            })) {
              regions.push(createRegion(m));
            }
          });
        }
        function createRegion(m) {
          return {
            show: m,
            hide: []
          };
        }
        function position(m) {
          return proj.position(m);
        }
        function addToRegion(r, m) {
          if (distance(position(r.show), position(m)) < threshold) {
            if (zindex(r.show) < zindex(m)) {
              r.hide.push(r.show);
              r.show = m;
            } else {
              r.hide.push(m);
            }
            return true;
          }
        }
        function hideMarkers() {
          regions.forEach(function(r) {
            if (!r.show.referenceOnly) {
              r.show.add(options.map);
            }
            r.hide.forEach(function(m) {
              if (!m.referenceOnly) {
                m.remove();
              }
            });
          });
        }
      }
    }
  });

  // ../lib/feature/source.js
  var require_source3 = __commonJS({
    "../lib/feature/source.js"(exports, module) {
      module.exports = {
        addToSource,
        refresh,
        removeFromSource
      };
      var sources = /* @__PURE__ */ new Map();
      var updates = /* @__PURE__ */ new Map();
      function updateMap(map, id, data) {
        if (updates.get(id)) {
          return;
        }
        updates.set(
          id,
          setTimeout(() => {
            updates.delete(id);
            map?._m?.getSource(id)?.setData(data);
          }, 0)
        );
      }
      function addToSource(map, id, feature) {
        let data = sources.get(id);
        if (!data) {
          data = {
            type: "FeatureCollection",
            features: []
          };
          sources.set(id, data);
        }
        data.features.push(feature);
        updateMap(map, id, data);
      }
      function removeFromSource(map, id, featureId) {
        const data = sources.get(id);
        if (!data) {
          return;
        }
        const idx = data.features.findIndex((f) => f.id === featureId);
        if (idx === -1) {
          return;
        }
        data.features.splice(idx, 1);
        updateMap(map, id, data);
      }
      function refresh(map) {
        sources.forEach((data, id) => updateMap(map, id, data));
      }
    }
  });

  // ../lib/animation.js
  var require_animation = __commonJS({
    "../lib/animation.js"(exports, module) {
      module.exports = init;
      function init(self2, { animation: animationProperty }) {
        let animating;
        let interval;
        let savedProperty;
        function nextFrame(params) {
          params.counter += params.delta;
          if (params.counter >= params.range || params.counter <= 0) {
            params.delta = -params.delta;
          }
        }
        function animateMarker(params) {
          if (self2._m._loaded) {
            const data = self2.data();
            data.properties[animationProperty] = [savedProperty[0], savedProperty[1] - params.counter];
            self2.data(data);
            nextFrame(params);
          }
        }
        function startBounce() {
          if (interval) {
            return;
          }
          const params = {
            counter: 0,
            delta: 4
          };
          const { properties } = self2.data();
          savedProperty = properties[animationProperty];
          params.range = properties.range ?? Math.abs(savedProperty[1]);
          params.range += params.delta - params.range % params.delta;
          interval = setInterval(animateMarker.bind(void 0, params), 100);
        }
        function stopBounce() {
          if (!interval) {
            return;
          }
          clearInterval(interval);
          interval = void 0;
          const data = self2.data();
          data.properties[animationProperty] = savedProperty;
          self2.data(data);
          return true;
        }
        function animation(type) {
          if (animating !== type) {
            animating = type;
            setTimeout(self2.fire.bind(self2, "animation_changed"), 1);
            if (type === "bounce") {
              startBounce();
            } else if (!type) {
              stopBounce();
            }
          }
        }
        self2.animation = animation;
        return self2;
      }
    }
  });

  // ../lib/draggable.js
  var require_draggable = __commonJS({
    "../lib/draggable.js"(exports, module) {
      module.exports = draggable;
      function dragPosition(e) {
        return e;
      }
      function draggable(self2, options) {
        let enabled = false;
        let dragging = false;
        let pending = false;
        let touchTimeout;
        function onmove(e) {
          e.preventDefault();
          e.originalEvent.preventDefault();
          if (!dragging) {
            if (pending) {
              pending = false;
              dragging = true;
              e.drag = true;
              self2.fire("dragstart", self2.dragPosition(e));
            }
            return;
          }
          e.drag = true;
          self2.fire("drag", self2.dragPosition(e));
        }
        function cancel(e = {}) {
          if (!self2._m) {
            return;
          }
          self2._m.off("mouseup", mouseup);
          self2._m.off("touchend", touchend);
          self2._m.off("touchcancel", cancel);
          self2._m.off("mousemove", onmove);
          self2._m.off("touchmove", onmove);
          if (pending) {
            pending = false;
            return;
          }
          if (!dragging) {
            return;
          }
          dragging = false;
          e.drag = true;
          self2.fire("dragcancel", e);
        }
        function mouseup(e) {
          self2._m.off("mousemove", onmove);
          e.preventDefault();
          e.originalEvent.preventDefault();
          dragging = false;
          e.drag = true;
          self2.fire("dragend", self2.dragPosition(e));
        }
        function touchend(e) {
          self2._m.off("movestart", cancel);
          self2._m.off("touchmove", onmove);
          self2._m.off("touchcancel", cancel);
          e.preventDefault();
          e.originalEvent.preventDefault();
          if (!dragging) {
            if (touchTimeout) {
              clearTimeout(touchTimeout);
              touchTimeout = void 0;
              self2.fire("click", e);
            }
            return;
          }
          dragging = false;
          e.drag = true;
          self2.fire("dragend", self2.dragPosition(e));
        }
        function onmousedown(e) {
          if (!enabled) {
            return;
          }
          e.preventDefault();
          if (dragging || self2._m.isMoving()) {
            return;
          }
          pending = true;
          self2._m.once("mouseup", mouseup);
          self2._m.on("mousemove", onmove);
        }
        function ontouchstart(e) {
          if (!enabled) {
            return;
          }
          e.preventDefault();
          if (dragging || self2._m.isMoving() || e.originalEvent.touches.length > 1) {
            return;
          }
          self2._m.once("touchend", touchend);
          self2._m.once("touchcancel", cancel);
          self2._m.once("movestart", cancel);
          touchTimeout = setTimeout(function() {
            touchTimeout = void 0;
            pending = true;
            self2._m.on("touchmove", onmove);
          }, 300);
        }
        function enable() {
          if (enabled) {
            return;
          }
          enabled = true;
          self2.on("mousedown", onmousedown);
          self2.on("touchstart", ontouchstart);
        }
        function disable() {
          if (!enabled) {
            return;
          }
          enabled = false;
          self2.off("mousedown", onmousedown);
          self2.off("touchstart", ontouchstart);
          cancel();
        }
        function changeDraggable(d) {
          return d ? enable() : disable();
        }
        self2.changeDraggable = changeDraggable;
        self2.dragPosition = self2.dragPosition || dragPosition;
        self2.cancelDrag = cancel;
        if (options.draggable) {
          enable();
        }
        return self2;
      }
    }
  });

  // ../lib/events.js
  var require_events = __commonJS({
    "../lib/events.js"(exports, module) {
      function expand(result, e) {
        result[e] = e;
        return result;
      }
      module.exports = {
        drag: ["dragstart", "drag", "dragend"].reduce(expand, {}),
        mouse: [
          "click",
          "mouseenter",
          "mouseleave",
          "mousemove",
          "mouseover",
          "mouseout",
          "dragstart",
          "drag",
          "dragend",
          "touchstart",
          "touchmove",
          "touchend"
        ].reduce(expand, {})
      };
    }
  });

  // ../lib/object.js
  var require_object2 = __commonJS({
    "../lib/object.js"(exports, module) {
      var { drag, mouse } = require_events();
      var util = require_util2();
      module.exports = init;
      var events = {
        bounds_changed: "moveend",
        center_changed: "moveend",
        zoom_changed: "zoomend"
      };
      function handleEvent(self2, fn, e) {
        if (e?.stopPropagation) {
          e.stopPropagation();
        }
        fn.call(self2, e);
      }
      function handleMouseEvent(self2, fn, e) {
        self2.ll(e);
        if (!e.ll) {
          return;
        }
        handleEvent(self2, fn, e);
      }
      function handleClickEvent(self2, fn, e) {
        e.alreadyHandledByFeature = true;
        if (e?.stopPropagation) {
          e.stopPropagation();
        }
        self2.ll(e);
        if (!e.ll) {
          return;
        }
        fn.call(self2, e);
      }
      function handlePreprocessEvent(preprocessEvent, self2, fn, e) {
        if (!preprocessEvent(e)) {
          return;
        }
        handleEvent(self2, fn, e);
      }
      function ll(e) {
        if (e?.lngLat) {
          e.ll = util.mll2ll(e.lngLat);
        }
      }
      function init(self2, options) {
        let listeners3 = {};
        function on(event, fn) {
          let handler;
          let feature;
          event = events[event] || event;
          if (event === "click" && self2._data) {
            handler = handleClickEvent.bind(void 0, self2, fn);
          } else if (mouse[event]) {
            handler = handleMouseEvent.bind(void 0, self2, fn);
          } else if (options?.preprocessEvent?.[event]) {
            handler = handlePreprocessEvent.bind(void 0, options.preprocessEvent[event], self2, fn);
          } else {
            handler = handleEvent.bind(void 0, self2, fn);
          }
          if (!drag[event]) {
            if (self2._data) {
              feature = self2._data.id;
              if (self2._m) {
                self2._featureEventHandler.on(event, self2._layers, feature, handler);
              }
            } else if (self2._m) {
              self2._featureEventHandler.mapOn(event, handler);
            }
          }
          listeners3[event] = listeners3[event] || [];
          listeners3[event].push({
            event,
            feature,
            fn,
            handler
          });
          return self2;
        }
        function off(event, fn) {
          if (event === void 0) {
            Object.keys(listeners3).forEach(function(event2) {
              listeners3[event2].forEach(function(listener) {
                off(listener.event, listener.fn);
              });
            });
            listeners3 = {};
          } else {
            event = events[event] || event;
            if (listeners3[event]?.some(function(listener, i, listeners4) {
              if (listener.fn === fn) {
                if (!drag[event]) {
                  if (listener.feature) {
                    if (self2._m) {
                      self2._featureEventHandler.off(event, self2._layers, listener.feature, listener.handler);
                    }
                  } else {
                    self2._featureEventHandler?.mapOff(event, listener.handler);
                  }
                }
                listeners4.splice(i, 1);
                return true;
              }
            }) && !listeners3[event].length) {
              delete listeners3[event];
            }
          }
          return self2;
        }
        function fire(event, e) {
          if (listeners3[event]) {
            listeners3[event].forEach(function(listener) {
              listener.handler(e);
            });
          }
        }
        function add(map) {
          if (!self2._m) {
            self2._m = map._m;
            options.onadd(map);
            self2._featureEventHandler = map._featureEventHandler;
            Object.keys(listeners3).forEach(function(event) {
              if (!drag[event]) {
                listeners3[event].forEach(function(listener) {
                  if (listener.feature) {
                    self2._featureEventHandler.on(listener.event, self2._layers, listener.feature, listener.handler);
                  } else {
                    self2._featureEventHandler.mapOn(listener.event, listener.handler);
                  }
                });
              }
            });
          }
          return self2;
        }
        function remove() {
          if (self2._m) {
            Object.keys(listeners3).forEach(function(event) {
              if (!drag[event]) {
                listeners3[event].forEach(function(listener) {
                  if (listener.feature) {
                    self2._featureEventHandler.off(listener.event, self2._layers, listener.feature, listener.handler);
                  } else {
                    self2._featureEventHandler.mapOff(listener.event, listener.handler);
                  }
                });
              }
            });
            delete self2._featureEventHandler;
            options.onremove();
            delete self2._m;
          }
          return self2;
        }
        self2.on = on;
        self2.off = off;
        self2.fire = fire;
        self2.ll = self2.ll || ll;
        if (options) {
          if (options.onadd) {
            self2.add = add;
          }
          if (options.onremove) {
            self2.remove = remove;
          }
        }
        return self2;
      }
    }
  });

  // ../lib/feature/index.js
  var require_feature = __commonJS({
    "../lib/feature/index.js"(exports, module) {
      var { addToSource, removeFromSource } = require_source3();
      var animation = require_animation();
      var draggable = require_draggable();
      var { findPoint, mll2ll } = require_util2();
      var object = require_object2();
      module.exports = init;
      var featureId = 0;
      function margin(_m, p, margin2) {
        const p1 = _m.unproject(p);
        const p2 = _m.unproject({
          x: p.x + margin2,
          y: p.y + margin2
        });
        return [Math.abs(p1.lng - p2.lng), Math.abs(p1.lat - p2.lat)];
      }
      function init(options) {
        function onadd(map) {
          options.map = map;
          addToSource(map, self2._source, self2._data);
          self2._layers.splice(
            0,
            self2._layers.length,
            ...self2._m.getStyle().layers.filter(({ source }) => source === options.source).map(({ id }) => id)
          );
        }
        function onremove() {
          removeFromSource(options.map, self2._source, self2._data.id);
        }
        function position(p) {
          if (p === void 0) {
            return self2._data.geometry?.coordinates;
          }
          if (self2._data.geometry) {
            self2._data.geometry.coordinates = p;
            data(self2._data);
          }
        }
        function data(data2) {
          if (data2 === void 0) {
            return self2._data;
          }
          const { map } = options;
          self2.remove();
          data2.id ??= self2._data.id;
          self2._data = data2;
          if (map && data2.type) {
            self2.add(map);
          }
        }
        function ll(e) {
          if (!e?.lngLat) {
            return;
          }
          e.ll = mll2ll(e.lngLat);
          if (e.drag || self2._data.geometry?.type !== "LineString") {
            return;
          }
          const path = self2._data.geometry?.coordinates;
          if (!path) {
            return;
          }
          const point = findPoint(e.ll, path, margin(self2._m, e.point, self2._margin));
          if (!point) {
            return;
          }
          e.ll = point.p;
          e.pointOnPath = point;
          e.featurePoint = self2._m.project(e.ll);
          if (point.idx || point.pol) {
            e.featurePoint.prev = self2._m.project(path[point.pol ? point.idx : point.idx - 1]);
          }
          if (point.idx < path.length - 1) {
            e.featurePoint.next = self2._m.project(path[point.idx + 1]);
          }
        }
        if (!options.data.id) {
          featureId += 1;
          options.data.id = featureId;
        }
        let self2 = object(
          {
            _source: options.source,
            _data: options.data,
            _margin: options.margin ?? 10,
            _layers: [],
            data,
            ll,
            position
          },
          {
            onadd,
            onremove
          }
        );
        if (!options.stationary) {
          self2 = draggable(self2, options);
        }
        if (options.animation) {
          self2 = animation(self2, options);
        }
        if (options.map && options.data.type) {
          self2.add(options.map);
        }
        return self2;
      }
    }
  });

  // ../lib/images.js
  var require_images = __commonJS({
    "../lib/images.js"(exports, module) {
      module.exports = create;
      var pixelRatio = globalThis.devicePixelRatio || 1;
      function create() {
        const images = /* @__PURE__ */ new Map();
        const imageQueue = /* @__PURE__ */ new Map();
        function removeEventListener(cached) {
          if (!cached?.img) {
            return;
          }
          cached.img.removeEventListener("load", cached.handler);
          delete cached.img;
          delete cached.handler;
        }
        function destroy() {
          images.forEach(removeEventListener);
          images.clear();
          imageQueue.clear();
        }
        function addImage(map, name, fn) {
          function handler() {
            const cached2 = images.get(name);
            const { img: img2 } = cached2;
            if (map._m) {
              map._m.addImage(name, img2);
              if (fn) {
                fn();
              }
            }
            removeEventListener(cached2);
          }
          const cached = images.get(name);
          if (!cached) {
            return;
          }
          const { img, url } = cached;
          img.addEventListener("load", handler);
          cached.handler = handler;
          img.setAttribute("src", url);
        }
        function add(map, name, url, size) {
          let resolve;
          const promise = new Promise((res) => {
            resolve = res;
          });
          if (images.get(name)) {
            resolve();
            return promise;
          }
          if (map._m && map.ready) {
            const img = document.createElement("img");
            if (size) {
              img.setAttribute("width", size[0] * pixelRatio + "px");
              img.setAttribute("height", size[1] * pixelRatio + "px");
            }
            images.set(name, {
              img,
              // keep element while waiting for loading to complete
              url,
              size
            });
            addImage(map, name, () => resolve());
          } else {
            imageQueue.set(name, {
              url,
              size
            });
            resolve();
          }
          return promise;
        }
        function init(map) {
          if (!imageQueue.size) {
            return;
          }
          imageQueue.forEach(({ url, size }, name) => {
            add(map, name, url, size);
          });
          imageQueue.clear();
        }
        async function refresh(map) {
          if (!images.size) {
            return;
          }
          const cachedImages = Array.from(images);
          destroy();
          return Promise.all(cachedImages.map(([name, { url, size }]) => add(map, name, url, size)));
        }
        return {
          add,
          destroy,
          init,
          refresh
        };
      }
    }
  });

  // ../lib/feature-event-handler/feature-collector.js
  var require_feature_collector = __commonJS({
    "../lib/feature-event-handler/feature-collector.js"(exports, module) {
      module.exports = featureCollector;
      function featureCollector(_m) {
        let oldFeatures = /* @__PURE__ */ new Map();
        let layers;
        function getLayers() {
          if (!layers) {
            layers = new Map(_m.getStyle().layers.map(({ id }, i) => [id, i]));
          }
          return layers;
        }
        function getZIndex(id) {
          return getLayers().get(id) ?? 0;
        }
        function onmove(newFeatures) {
          let mouseenter = [];
          let mouseover = [];
          let zindexEnter = 0;
          let zindexOver = 0;
          for (const f of newFeatures) {
            const {
              layer: { id }
            } = f;
            const zindex = getZIndex(id);
            if (oldFeatures.delete(f.id)) {
              mouseover.push(f);
              zindexOver = Math.max(zindex, zindexOver);
            } else {
              mouseenter.push(f);
              zindexEnter = Math.max(zindex, zindexEnter);
            }
          }
          const mouseleave = Array.from(oldFeatures.values());
          if (zindexOver > zindexEnter) {
            mouseenter = [];
          } else {
            mouseleave.push(...mouseover);
            mouseover = [];
          }
          oldFeatures = new Map(newFeatures.map((f) => [f.id, f]));
          return { mouseenter, mouseover, mouseleave };
        }
        function onout() {
          const mouseleave = Array.from(oldFeatures.values());
          oldFeatures = /* @__PURE__ */ new Map();
          return { mouseleave };
        }
        return {
          onmove,
          onout
        };
      }
    }
  });

  // ../lib/feature-event-handler/listeners-bag.js
  var require_listeners_bag = __commonJS({
    "../lib/feature-event-handler/listeners-bag.js"(exports, module) {
      module.exports = listenersBag;
      function isEmpty(o) {
        return Object.keys(o).length === 0;
      }
      function listenersBag() {
        const bag = /* @__PURE__ */ Object.create(null);
        const types2layers = /* @__PURE__ */ Object.create(null);
        function getListeners(type, featureId) {
          const features = bag[type];
          if (!features) {
            return [];
          }
          return features[featureId] || [];
        }
        function forType(type) {
          const layers = types2layers[type];
          return layers ? Object.keys(layers) : [];
        }
        function addLayer(type, layerId) {
          let layers = types2layers[type];
          if (!layers) {
            types2layers[type] = layers = /* @__PURE__ */ Object.create(null);
          }
          if (!layers[layerId]) {
            layers[layerId] = 1;
            return true;
          }
          layers[layerId] += 1;
        }
        function removeLayer(type, layerId) {
          const layers = types2layers[type];
          if (0 === --layers[layerId]) {
            delete layers[layerId];
            return true;
          }
        }
        function addListener(type, featureId, listener) {
          let features = bag[type];
          if (!features) {
            bag[type] = features = /* @__PURE__ */ Object.create(null);
          }
          let listeners3 = features[featureId];
          if (!listeners3) {
            features[featureId] = listeners3 = [];
          }
          listeners3.push(listener);
        }
        function removeListener(type, featureId, listener) {
          const listeners3 = bag[type][featureId];
          const index = listeners3.indexOf(listener);
          if (index >= 0) {
            listeners3.splice(index, 1);
          }
          if (listeners3.length === 0) {
            const features = bag[type];
            delete features[featureId];
            if (isEmpty(features)) {
              delete bag[type];
            }
          }
        }
        function add(type, layerId, featureId, listener) {
          addListener(type, featureId, listener);
          if (!Array.isArray(layerId)) {
            return addLayer(type, layerId);
          }
          layerId.forEach((layerId2) => addLayer(type, layerId2));
        }
        function remove(type, layerId, featureId, listener) {
          removeListener(type, featureId, listener);
          if (!Array.isArray(layerId)) {
            return removeLayer(type, layerId);
          }
          layerId.forEach((layerId2) => removeLayer(type, layerId2));
        }
        return {
          getListeners,
          add,
          remove,
          forType
        };
      }
    }
  });

  // ../lib/feature-event-handler/map-listeners-bag.js
  var require_map_listeners_bag = __commonJS({
    "../lib/feature-event-handler/map-listeners-bag.js"(exports, module) {
      module.exports = mapListenersBag;
      function mapListenersBag() {
        const bag = /* @__PURE__ */ Object.create(null);
        function getListeners(type) {
          return bag[type] || [];
        }
        function add(type, listener) {
          let listeners3 = bag[type];
          if (!listeners3) {
            bag[type] = listeners3 = [listener];
            return true;
          }
          listeners3.push(listener);
        }
        function remove(type, listener) {
          const listeners3 = bag[type];
          const index = listeners3.indexOf(listener);
          if (index >= 0) {
            listeners3.splice(index, 1);
          }
          if (listeners3.length === 0) {
            delete bag[type];
            return true;
          }
        }
        return {
          add,
          remove,
          getListeners
        };
      }
    }
  });

  // ../lib/feature-event-handler/counting-set.js
  var require_counting_set = __commonJS({
    "../lib/feature-event-handler/counting-set.js"(exports, module) {
      module.exports = countingSet;
      function countingSet() {
        const set = /* @__PURE__ */ Object.create(null);
        function inc(item) {
          if (!set[item]) {
            set[item] = 1;
            return true;
          }
          set[item] += 1;
        }
        function dec(item) {
          if (0 === --set[item]) {
            delete set[item];
            return true;
          }
        }
        return {
          inc,
          dec
        };
      }
    }
  });

  // ../lib/query.js
  var require_query = __commonJS({
    "../lib/query.js"(exports, module) {
      module.exports = queryRenderedFeatures;
      function createQueryGeometry(point, fat, transform) {
        if (fat === 0) {
          return {
            viewport: [point],
            worldCoordinate: [transform.pointCoordinate(point)]
          };
        }
        const pointMin = { x: point.x - fat, y: point.y - fat };
        const pointMax = { x: point.x + fat, y: point.y + fat };
        const worldMin = transform.pointCoordinate(pointMin);
        const worldMax = transform.pointCoordinate(pointMax);
        const viewport = [
          pointMin,
          { x: pointMax.x, y: pointMin.y },
          // like world1
          pointMax,
          { x: pointMin.x, y: pointMax.y },
          // like world3
          pointMin
        ];
        const world1 = worldMax.clone();
        world1.column = worldMin.column;
        const world3 = worldMin.clone();
        world3.row = worldMax.row;
        const worldCoordinate = [worldMin, world1, worldMax, world3, worldMin];
        return { viewport, worldCoordinate };
      }
      function queryRenderedFeatures(_m, point, fat, options) {
        const geometry = createQueryGeometry(point, fat, _m.transform);
        return _m.style.queryRenderedFeatures(geometry, options, _m.transform) || [];
      }
    }
  });

  // ../lib/feature-event-handler/index.js
  var require_feature_event_handler = __commonJS({
    "../lib/feature-event-handler/index.js"(exports, module) {
      var makeFeatureCollector = require_feature_collector();
      var makeListenersBag = require_listeners_bag();
      var makeMapListenersBag = require_map_listeners_bag();
      var makeCountingSet = require_counting_set();
      var query = require_query();
      module.exports = featureEventHandler;
      var mouseEvents = asMap(["mouseenter", "mouseover", "mouseleave"]);
      var touchEvents = asMap(["touchstart", "touchend", "touchmove", "touchcancel"]);
      function translateEventType(type) {
        switch (type) {
          case "mousemove":
            return "mouseover";
          case "mouseout":
            return "mouseleave";
          default:
            return type;
        }
      }
      function featureEventHandler(_m) {
        const listenersBag = makeListenersBag();
        const mapListenersBag = makeMapListenersBag();
        const activeTypes = makeCountingSet();
        const featureCollector = makeFeatureCollector(_m);
        function on(type, layers, featureId, listener) {
          type = translateEventType(type);
          listenersBag.add(type, layers, featureId, listener);
          addMapListener(type);
        }
        function off(type, layers, featureId, listener) {
          type = translateEventType(type);
          listenersBag.remove(type, layers, featureId, listener);
          removeMapListener(type);
        }
        function mapOn(type, listener) {
          if (mapListenersBag.add(type, listener)) {
            addMapListener(type);
          }
        }
        function mapOff(type, listener) {
          if (mapListenersBag.remove(type, listener)) {
            removeMapListener(type);
          }
        }
        function addMapListener(type) {
          if (mouseEvents[type]) {
            addMapListener("mousemove");
            addMapListener("mouseout");
          } else {
            if (activeTypes.inc(type)) {
              _m.on(type, getHandler(type));
            }
          }
        }
        function removeMapListener(type) {
          if (mouseEvents[type]) {
            removeMapListener("mousemove");
            removeMapListener("mouseout");
          } else {
            if (activeTypes.dec(type)) {
              _m.off(type, getHandler(type));
            }
          }
        }
        function getHandler(type) {
          switch (type) {
            case "mousemove":
              return onmousemove;
            case "mouseout":
              return onmouseout;
            default:
              return onevent;
          }
        }
        function getCurrentLayers(type) {
          return listenersBag.forType(type).filter((l) => _m.getLayer(l));
        }
        function getCurrentMouseLayers() {
          const all = {};
          return Object.keys(mouseEvents).reduce((all2, type) => all2.concat(listenersBag.forType(type)), []).filter(function(l) {
            if (!_m.getLayer(l)) {
              return false;
            }
            if (all[l]) {
              return false;
            }
            all[l] = true;
            return true;
          });
        }
        function filterByZIndex(features) {
          if (features.length <= 1) {
            return features;
          }
          return [features[0]];
        }
        function fireEvent(type, e, features, filterByZ) {
          if (features.length === 0) {
            return;
          }
          if (filterByZ) {
            features = filterByZIndex(features);
          }
          features.forEach(function(feature) {
            const { id } = feature;
            e.feature = feature;
            listenersBag.getListeners(type, id).forEach((listener) => listener.call(_m, e));
            delete e.feature;
          });
        }
        function fireMapEvent(type, e) {
          mapListenersBag.getListeners(type).forEach((listener) => listener.call(_m, e));
        }
        function onmousemove(e) {
          const { point } = e;
          const layers = getCurrentMouseLayers();
          const features = queryRenderedFeatures("mousemove", point, { layers });
          const result = featureCollector.onmove(features);
          Object.entries(result).forEach(function([type, features2]) {
            e.type = type;
            fireEvent(type, e, features2, type !== "mouseleave");
          });
          if (0 === features.length) {
            fireMapEvent("mousemove", e);
          }
        }
        function onmouseout(e) {
          const result = featureCollector.onout();
          Object.entries(result).forEach(function([type, features]) {
            e.type = type;
            fireEvent(type, e, features);
          });
          fireMapEvent("mouseout", e);
        }
        function onevent(e) {
          const { type, point } = e;
          const layers = getCurrentLayers(type);
          const features = layers.length > 0 ? queryRenderedFeatures(type, point, { layers }) : [];
          if (features.length > 0) {
            fireEvent(type, e, features, true);
          } else {
            fireMapEvent(type, e);
          }
        }
        function queryRenderedFeatures(type, point, options) {
          const fat = touchEvents[type] ? 10 : 3;
          return query(_m, point, fat, options);
        }
        return {
          on,
          off,
          mapOn,
          mapOff
        };
      }
      function asMap(arr) {
        return arr.reduce(function(obj, type) {
          obj[type] = true;
          return obj;
        }, /* @__PURE__ */ Object.create(null));
      }
    }
  });

  // ../../mapwhit/map-gestures/node_modules/@mapwhit/events/lib/events.js
  function listeners2({ once } = {}) {
    const bag = /* @__PURE__ */ new Map();
    return {
      add,
      remove,
      fire,
      listens
    };
    function add(type, listener) {
      const list = bag.get(type);
      if (!list) {
        bag.set(type, [listener]);
      } else if (!list.includes(listener)) {
        list.push(listener);
      }
    }
    function remove(type, listener) {
      const list = bag.get(type);
      if (!list) {
        return;
      }
      const index = list.indexOf(listener);
      if (index !== -1) {
        list.splice(index, 1);
      }
      if (list.length === 0) {
        bag.delete(type);
      }
    }
    function fire(type, thisArg, data) {
      let list = bag.get(type);
      if (!list || list.length === 0) {
        return;
      }
      if (once) {
        bag.delete(type);
      } else {
        list = list.slice();
      }
      for (const listener of list) {
        listener.call(thisArg, data);
      }
    }
    function listens(type) {
      return bag.get(type)?.length > 0;
    }
  }
  var Event2, ErrorEvent2, Evented2;
  var init_events2 = __esm({
    "../../mapwhit/map-gestures/node_modules/@mapwhit/events/lib/events.js"() {
      Event2 = class {
        constructor(type, data) {
          Object.assign(this, data);
          this.type = type;
        }
      };
      ErrorEvent2 = class extends Event2 {
        constructor(error, data) {
          super("error", Object.assign({ error }, data));
        }
      };
      Evented2 = class {
        #listeners;
        #oneTimeListeners;
        #parent;
        #parentData;
        /**
         * Adds a listener to a specified event type.
         *
         * @param {string} type The event type to add a listen for.
         * @param {Function} listener The function to be called when the event is fired.
         *   The listener function is called with the data object passed to `fire`,
         *   extended with `target` and `type` properties.
         * @returns {Object} `this`
         */
        on(type, listener) {
          this.#listeners ??= listeners2();
          this.#listeners.add(type, listener);
          return this;
        }
        /**
         * Removes a previously registered event listener.
         *
         * @param {string} type The event type to remove listeners for.
         * @param {Function} listener The listener function to remove.
         * @returns {Object} `this`
         */
        off(type, listener) {
          this.#listeners?.remove(type, listener);
          this.#oneTimeListeners?.remove(type, listener);
          return this;
        }
        /**
         * Adds a listener that will be called only once to a specified event type.
         *
         * The listener will be called first time the event fires after the listener is registered.
         *
         * @param {string} type The event type to listen for.
         * @param {Function} listener The function to be called when the event is fired the first time.
         * @returns {Object} `this`
         */
        once(type, listener) {
          this.#oneTimeListeners ??= listeners2({ once: true });
          this.#oneTimeListeners.add(type, listener);
          return this;
        }
        fire(event, ...args) {
          if (typeof event === "string") {
            event = new Event2(event, ...args);
          }
          const { type } = event;
          if (this.listens(type)) {
            event.target = this;
            this.#listeners?.fire(type, this, event);
            this.#oneTimeListeners?.fire(type, this, event);
            const parent = this.#parent;
            if (parent) {
              const data = typeof this.#parentData === "function" ? this.#parentData() : this.#parentData;
              Object.assign(event, data);
              parent.fire(event);
            }
          } else if (event instanceof ErrorEvent2) {
            console.error(event.error);
          }
          return this;
        }
        /**
         * Returns a true if this instance of Evented or any forwardeed instances of Evented have a listener for the specified type.
         *
         * @param {string} type The event type
         * @returns {boolean} `true` if there is at least one registered listener for specified event type, `false` otherwise
         */
        listens(type) {
          return this.#listeners?.listens(type) || this.#oneTimeListeners?.listens(type) || this.#parent?.listens(type);
        }
        /**
         * Bubble all events fired by this instance of Evented to this parent instance of Evented.
         *
         * @returns {Object} `this`
         */
        setEventedParent(parent, data) {
          this.#parent = parent;
          this.#parentData = data;
          return this;
        }
      };
    }
  });

  // ../../mapwhit/map-gestures/node_modules/@mapbox/point-geometry/index.js
  function Point2(x, y) {
    this.x = x;
    this.y = y;
  }
  var init_point_geometry2 = __esm({
    "../../mapwhit/map-gestures/node_modules/@mapbox/point-geometry/index.js"() {
      Point2.prototype = {
        /**
         * Clone this point, returning a new point that can be modified
         * without affecting the old one.
         * @return {Point} the clone
         */
        clone() {
          return new Point2(this.x, this.y);
        },
        /**
         * Add this point's x & y coordinates to another point,
         * yielding a new point.
         * @param {Point} p the other point
         * @return {Point} output point
         */
        add(p) {
          return this.clone()._add(p);
        },
        /**
         * Subtract this point's x & y coordinates to from point,
         * yielding a new point.
         * @param {Point} p the other point
         * @return {Point} output point
         */
        sub(p) {
          return this.clone()._sub(p);
        },
        /**
         * Multiply this point's x & y coordinates by point,
         * yielding a new point.
         * @param {Point} p the other point
         * @return {Point} output point
         */
        multByPoint(p) {
          return this.clone()._multByPoint(p);
        },
        /**
         * Divide this point's x & y coordinates by point,
         * yielding a new point.
         * @param {Point} p the other point
         * @return {Point} output point
         */
        divByPoint(p) {
          return this.clone()._divByPoint(p);
        },
        /**
         * Multiply this point's x & y coordinates by a factor,
         * yielding a new point.
         * @param {number} k factor
         * @return {Point} output point
         */
        mult(k) {
          return this.clone()._mult(k);
        },
        /**
         * Divide this point's x & y coordinates by a factor,
         * yielding a new point.
         * @param {number} k factor
         * @return {Point} output point
         */
        div(k) {
          return this.clone()._div(k);
        },
        /**
         * Rotate this point around the 0, 0 origin by an angle a,
         * given in radians
         * @param {number} a angle to rotate around, in radians
         * @return {Point} output point
         */
        rotate(a) {
          return this.clone()._rotate(a);
        },
        /**
         * Rotate this point around p point by an angle a,
         * given in radians
         * @param {number} a angle to rotate around, in radians
         * @param {Point} p Point to rotate around
         * @return {Point} output point
         */
        rotateAround(a, p) {
          return this.clone()._rotateAround(a, p);
        },
        /**
         * Multiply this point by a 4x1 transformation matrix
         * @param {[number, number, number, number]} m transformation matrix
         * @return {Point} output point
         */
        matMult(m) {
          return this.clone()._matMult(m);
        },
        /**
         * Calculate this point but as a unit vector from 0, 0, meaning
         * that the distance from the resulting point to the 0, 0
         * coordinate will be equal to 1 and the angle from the resulting
         * point to the 0, 0 coordinate will be the same as before.
         * @return {Point} unit vector point
         */
        unit() {
          return this.clone()._unit();
        },
        /**
         * Compute a perpendicular point, where the new y coordinate
         * is the old x coordinate and the new x coordinate is the old y
         * coordinate multiplied by -1
         * @return {Point} perpendicular point
         */
        perp() {
          return this.clone()._perp();
        },
        /**
         * Return a version of this point with the x & y coordinates
         * rounded to integers.
         * @return {Point} rounded point
         */
        round() {
          return this.clone()._round();
        },
        /**
         * Return the magnitude of this point: this is the Euclidean
         * distance from the 0, 0 coordinate to this point's x and y
         * coordinates.
         * @return {number} magnitude
         */
        mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        /**
         * Judge whether this point is equal to another point, returning
         * true or false.
         * @param {Point} other the other point
         * @return {boolean} whether the points are equal
         */
        equals(other) {
          return this.x === other.x && this.y === other.y;
        },
        /**
         * Calculate the distance from this point to another point
         * @param {Point} p the other point
         * @return {number} distance
         */
        dist(p) {
          return Math.sqrt(this.distSqr(p));
        },
        /**
         * Calculate the distance from this point to another point,
         * without the square root step. Useful if you're comparing
         * relative distances.
         * @param {Point} p the other point
         * @return {number} distance
         */
        distSqr(p) {
          const dx = p.x - this.x, dy = p.y - this.y;
          return dx * dx + dy * dy;
        },
        /**
         * Get the angle from the 0, 0 coordinate to this point, in radians
         * coordinates.
         * @return {number} angle
         */
        angle() {
          return Math.atan2(this.y, this.x);
        },
        /**
         * Get the angle from this point to another point, in radians
         * @param {Point} b the other point
         * @return {number} angle
         */
        angleTo(b) {
          return Math.atan2(this.y - b.y, this.x - b.x);
        },
        /**
         * Get the angle between this point and another point, in radians
         * @param {Point} b the other point
         * @return {number} angle
         */
        angleWith(b) {
          return this.angleWithSep(b.x, b.y);
        },
        /**
         * Find the angle of the two vectors, solving the formula for
         * the cross product a x b = |a||b|sin() for .
         * @param {number} x the x-coordinate
         * @param {number} y the y-coordinate
         * @return {number} the angle in radians
         */
        angleWithSep(x, y) {
          return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y
          );
        },
        /** @param {[number, number, number, number]} m */
        _matMult(m) {
          const x = m[0] * this.x + m[1] * this.y, y = m[2] * this.x + m[3] * this.y;
          this.x = x;
          this.y = y;
          return this;
        },
        /** @param {Point} p */
        _add(p) {
          this.x += p.x;
          this.y += p.y;
          return this;
        },
        /** @param {Point} p */
        _sub(p) {
          this.x -= p.x;
          this.y -= p.y;
          return this;
        },
        /** @param {number} k */
        _mult(k) {
          this.x *= k;
          this.y *= k;
          return this;
        },
        /** @param {number} k */
        _div(k) {
          this.x /= k;
          this.y /= k;
          return this;
        },
        /** @param {Point} p */
        _multByPoint(p) {
          this.x *= p.x;
          this.y *= p.y;
          return this;
        },
        /** @param {Point} p */
        _divByPoint(p) {
          this.x /= p.x;
          this.y /= p.y;
          return this;
        },
        _unit() {
          this._div(this.mag());
          return this;
        },
        _perp() {
          const y = this.y;
          this.y = this.x;
          this.x = -y;
          return this;
        },
        /** @param {number} angle */
        _rotate(angle) {
          const cos = Math.cos(angle), sin = Math.sin(angle), x = cos * this.x - sin * this.y, y = sin * this.x + cos * this.y;
          this.x = x;
          this.y = y;
          return this;
        },
        /**
         * @param {number} angle
         * @param {Point} p
         */
        _rotateAround(angle, p) {
          const cos = Math.cos(angle), sin = Math.sin(angle), x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y), y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);
          this.x = x;
          this.y = y;
          return this;
        },
        _round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        },
        constructor: Point2
      };
      Point2.convert = function(p) {
        if (p instanceof Point2) {
          return (
            /** @type {Point} */
            p
          );
        }
        if (Array.isArray(p)) {
          return new Point2(+p[0], +p[1]);
        }
        if (p.x !== void 0 && p.y !== void 0) {
          return new Point2(+p.x, +p.y);
        }
        throw new Error("Expected [x, y] or {x, y} point format");
      };
    }
  });

  // ../../mapwhit/map-gestures/lib/util/dom.js
  function initEnableDisableDrag() {
    docStyle = window.document?.documentElement.style;
    selectProp = docStyle && ["userSelect", "WebkitUserSelect"].find((prop) => prop in docStyle);
  }
  function disableDrag() {
    if (docStyle && selectProp) {
      userSelect = docStyle[selectProp];
      docStyle[selectProp] = "none";
    }
  }
  function enableDrag() {
    if (docStyle && selectProp) {
      docStyle[selectProp] = userSelect;
    }
  }
  function supressClickHandler(e) {
    e.preventDefault();
    e.stopPropagation();
    window.removeEventListener("click", supressClickHandler, true);
  }
  function suppressClick() {
    window.addEventListener("click", supressClickHandler, true);
    window.setTimeout(() => {
      if (typeof window === "object" && window) {
        window.removeEventListener("click", supressClickHandler, true);
      }
    }, 0);
  }
  function mousePos(el, e) {
    const rect = el.getBoundingClientRect();
    e = e.touches ? e.touches[0] : e;
    return new Point2(e.clientX - rect.left - el.clientLeft, e.clientY - rect.top - el.clientTop);
  }
  function touchPos(el, e) {
    const rect = el.getBoundingClientRect();
    const points = [];
    const touches = e.type === "touchend" ? e.changedTouches : e.touches;
    for (let i = 0; i < touches.length; i++) {
      points.push(
        new Point2(touches[i].clientX - rect.left - el.clientLeft, touches[i].clientY - rect.top - el.clientTop)
      );
    }
    return points;
  }
  function mouseButton(e) {
    if (typeof window.InstallTrigger !== "undefined" && e.button === 2 && e.ctrlKey && window.navigator.platform.toUpperCase().includes("MAC")) {
      return 0;
    }
    return e.button;
  }
  var docStyle, selectProp, userSelect;
  var init_dom = __esm({
    "../../mapwhit/map-gestures/lib/util/dom.js"() {
      init_point_geometry2();
    }
  });

  // ../../mapwhit/map-gestures/lib/handler/box_zoom.js
  function boxZoomHandler(map, options = {}) {
    const el = map.getCanvasContainer();
    const container = map.getContainer();
    const { fireEvent } = options;
    let enabled = false;
    let active = false;
    let startPos;
    let box;
    initEnableDisableDrag();
    return {
      isEnabled,
      isActive,
      enable,
      disable,
      onMouseDown
    };
    function isEnabled() {
      return enabled;
    }
    function isActive() {
      return active;
    }
    function enable() {
      enabled = true;
    }
    function disable() {
      enabled = false;
    }
    function onMouseDown(e) {
      if (!enabled) return;
      if (!(e.shiftKey && e.button === 0)) return;
      window.document.addEventListener("mousemove", onMouseMove, false);
      window.document.addEventListener("keydown", onKeyDown, false);
      window.document.addEventListener("mouseup", onMouseUp, false);
      disableDrag();
      startPos = mousePos(el, e);
      active = true;
    }
    function onMouseMove(e) {
      const p0 = startPos;
      const p1 = mousePos(el, e);
      if (!box) {
        box = window.document.createElement("div");
        box.className = "mapbox-boxzoom";
        container.appendChild(box);
        container.classList.add("mapboxgl-crosshair");
        fireEvent("boxzoomstart", e);
      }
      const minX = Math.min(p0.x, p1.x);
      const maxX = Math.max(p0.x, p1.x);
      const minY = Math.min(p0.y, p1.y);
      const maxY = Math.max(p0.y, p1.y);
      box.style.transform = `translate(${minX}px,${minY}px)`;
      box.style.width = `${maxX - minX}px`;
      box.style.height = `${maxY - minY}px`;
    }
    function onMouseUp(e) {
      if (e.button !== 0) return;
      const p0 = startPos;
      const p1 = mousePos(el, e);
      finish();
      suppressClick();
      if (p0.x === p1.x && p0.y === p1.y) {
        fireEvent("boxzoomcancel", e);
      } else {
        const sw = map.unproject(p0);
        const ne = map.unproject(p1);
        if (sw.lng > ne.lng) {
          [sw.lng, ne.lng] = [ne.lng, sw.lng];
        }
        if (sw.lat > ne.lat) {
          [sw.lat, ne.lat] = [ne.lat, sw.lat];
        }
        const bounds2 = [sw, ne];
        map.fitBounds(bounds2, { linear: true });
        fireEvent("boxzoomend", e, { boxZoomBounds: bounds2 });
      }
    }
    function onKeyDown(e) {
      if (e.keyCode === 27) {
        finish();
        fireEvent("boxzoomcancel", e);
      }
    }
    function finish() {
      active = false;
      window.document.removeEventListener("mousemove", onMouseMove, false);
      window.document.removeEventListener("keydown", onKeyDown, false);
      window.document.removeEventListener("mouseup", onMouseUp, false);
      container.classList.remove("mapboxgl-crosshair");
      if (box) {
        box.remove();
        box = void 0;
      }
      startPos = void 0;
      enableDrag();
    }
  }
  var init_box_zoom = __esm({
    "../../mapwhit/map-gestures/lib/handler/box_zoom.js"() {
      init_dom();
    }
  });

  // ../../mapwhit/map-gestures/lib/handler/dblclick_zoom.js
  function doubleClickZoomHandler(map) {
    let enabled = false;
    let active = false;
    let tapped;
    return {
      isEnabled,
      isActive,
      enable,
      disable,
      onDblClick,
      onTouchStart
    };
    function isEnabled() {
      return enabled;
    }
    function isActive() {
      return active;
    }
    function enable() {
      enabled = true;
    }
    function disable() {
      enabled = false;
    }
    function onTouchStart(e) {
      if (!enabled) return;
      if (e.points.length > 1) return;
      if (!tapped) {
        tapped = setTimeout(() => {
          tapped = void 0;
        }, 300);
      } else {
        clearTimeout(tapped);
        tapped = void 0;
        zoom(e);
      }
    }
    function onDblClick(e) {
      if (!enabled) return;
      e.originalEvent.preventDefault();
      zoom(e);
    }
    function zoom(e) {
      active = true;
      map.on("zoomend", onZoomEnd);
      map.zoomTo(map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1), { around: e.lngLat }, e);
    }
    function onZoomEnd() {
      active = false;
      map.off("zoomend", onZoomEnd);
    }
  }
  var init_dblclick_zoom = __esm({
    "../../mapwhit/map-gestures/lib/handler/dblclick_zoom.js"() {
    }
  });

  // ../../mapwhit/map-gestures/node_modules/@mapbox/unitbezier/index.js
  var require_unitbezier2 = __commonJS({
    "../../mapwhit/map-gestures/node_modules/@mapbox/unitbezier/index.js"(exports, module) {
      "use strict";
      module.exports = UnitBezier2;
      function UnitBezier2(p1x, p1y, p2x, p2y) {
        this.cx = 3 * p1x;
        this.bx = 3 * (p2x - p1x) - this.cx;
        this.ax = 1 - this.cx - this.bx;
        this.cy = 3 * p1y;
        this.by = 3 * (p2y - p1y) - this.cy;
        this.ay = 1 - this.cy - this.by;
        this.p1x = p1x;
        this.p1y = p1y;
        this.p2x = p2x;
        this.p2y = p2y;
      }
      UnitBezier2.prototype = {
        sampleCurveX: function(t) {
          return ((this.ax * t + this.bx) * t + this.cx) * t;
        },
        sampleCurveY: function(t) {
          return ((this.ay * t + this.by) * t + this.cy) * t;
        },
        sampleCurveDerivativeX: function(t) {
          return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
        },
        solveCurveX: function(x, epsilon) {
          if (epsilon === void 0) epsilon = 1e-6;
          if (x < 0) return 0;
          if (x > 1) return 1;
          var t = x;
          for (var i = 0; i < 8; i++) {
            var x2 = this.sampleCurveX(t) - x;
            if (Math.abs(x2) < epsilon) return t;
            var d2 = this.sampleCurveDerivativeX(t);
            if (Math.abs(d2) < 1e-6) break;
            t = t - x2 / d2;
          }
          var t0 = 0;
          var t1 = 1;
          t = x;
          for (i = 0; i < 20; i++) {
            x2 = this.sampleCurveX(t);
            if (Math.abs(x2 - x) < epsilon) break;
            if (x > x2) {
              t0 = t;
            } else {
              t1 = t;
            }
            t = (t1 - t0) * 0.5 + t0;
          }
          return t;
        },
        solve: function(x, epsilon) {
          return this.sampleCurveY(this.solveCurveX(x, epsilon));
        }
      };
    }
  });

  // ../../mapwhit/map-gestures/lib/util/easing.js
  function bezier(p1x, p1y, p2x, p2y) {
    const bezier2 = new import_unitbezier.default(p1x, p1y, p2x, p2y);
    return (t) => bezier2.solve(t);
  }
  var import_unitbezier, ease;
  var init_easing = __esm({
    "../../mapwhit/map-gestures/lib/util/easing.js"() {
      import_unitbezier = __toESM(require_unitbezier2(), 1);
      ease = bezier(0.25, 0.1, 0.25, 1);
    }
  });

  // ../../mapwhit/map-gestures/lib/util/frame.js
  function frame(map, fn) {
    let id;
    let args;
    function callback() {
      id = void 0;
      fn(...args);
    }
    function request(..._args) {
      args = _args;
      if (id) return;
      id = map._requestRenderFrame(callback);
    }
    function cancel() {
      if (!id) return;
      map._cancelRenderFrame(id);
      id = void 0;
    }
    return {
      request,
      cancel
    };
  }
  var init_frame = __esm({
    "../../mapwhit/map-gestures/lib/util/frame.js"() {
    }
  });

  // ../../mapwhit/map-gestures/lib/util/inertia.js
  function inertia(calculateInertia) {
    const states = [];
    return {
      update,
      calculate
    };
    function update(value) {
      const now = performance.now();
      const data = { time: now, value };
      const len = states.push(data);
      if (len > MAX_LEN) {
        let first = getFirst(now);
        if (first < 0) {
          first = len - 1;
        } else if (first < MIN_REMOVE) {
          first = MIN_REMOVE;
        }
        states.splice(0, first);
      }
    }
    function getFirst(now = performance.now()) {
      return states.findIndex((item) => now - item.time < INERTIA_CUTOFF);
    }
    function calculate() {
      const first = getFirst();
      const last = states.length - 1;
      if (first < 0 || first >= last) {
        return EMPTY;
      }
      return calculateInertia(states[first], states[last]);
    }
  }
  var INERTIA_CUTOFF, EMPTY, MAX_LEN, MIN_REMOVE;
  var init_inertia = __esm({
    "../../mapwhit/map-gestures/lib/util/inertia.js"() {
      INERTIA_CUTOFF = 160;
      EMPTY = { empty: true };
      MAX_LEN = 1e3;
      MIN_REMOVE = Math.floor(MAX_LEN / 2);
    }
  });

  // ../../mapwhit/map-gestures/lib/handler/drag_pan.js
  function dragPanHandler(map, options = {}) {
    const { fireEvent } = options;
    const _el = map.getCanvasContainer();
    const frame2 = frame(map, onDragFrame);
    let state = "disabled";
    let inertia2;
    let previousPos;
    return {
      isActive,
      isEnabled,
      enable,
      disable,
      onMouseDown,
      onTouchStart
    };
    function isEnabled() {
      return state !== "disabled";
    }
    function isActive() {
      return state === "active";
    }
    function enable() {
      if (isEnabled()) return;
      map.getCanvasContainer().classList.add("mapboxgl-touch-drag-pan");
      state = "enabled";
    }
    function disable() {
      if (!isEnabled()) return;
      map.getCanvasContainer().classList.remove("mapboxgl-touch-drag-pan");
      switch (state) {
        case "active":
          state = "disabled";
          unbind();
          deactivate();
          fireEvent("dragend");
          map.fire("moveend");
          break;
        case "pending":
          state = "disabled";
          unbind();
          break;
        default:
          state = "disabled";
          break;
      }
    }
    function onMouseDown(e) {
      if (state !== "enabled") return;
      if (e.ctrlKey || mouseButton(e) !== 0) return;
      window.document.addEventListener("mousemove", onMove, { capture: true });
      window.document.addEventListener("mouseup", onMouseUp);
      start(e);
    }
    function onTouchStart(e) {
      if (state !== "enabled") return;
      if (e.touches.length > 1) return;
      window.document.addEventListener("touchmove", onMove, { capture: true, passive: false });
      window.document.addEventListener("touchend", onTouchEnd);
      start(e);
    }
    function start(e) {
      window.addEventListener("blur", onBlur);
      state = "pending";
      previousPos = mousePos(_el, e);
      inertia2 = inertia(calculateInertia);
      inertia2.update(previousPos);
    }
    function onMove(e) {
      e.preventDefault();
      const pos = mousePos(_el, e);
      inertia2.update(pos);
      frame2.request(e, pos);
      if (state === "pending") {
        state = "active";
        fireEvent("dragstart", e);
        map.fire("movestart", { originalEvent: e });
      }
    }
    function onDragFrame(e, pos) {
      const tr = map.transform;
      tr.setLocationAtPoint(tr.pointLocation(previousPos), pos);
      fireEvent("drag", e);
      map.fire("move", { originalEvent: e });
      previousPos = pos;
    }
    function onMouseUp(e) {
      if (mouseButton(e) !== 0) return;
      switch (state) {
        case "active":
          state = "enabled";
          suppressClick();
          unbind();
          deactivate();
          inertialPan(e);
          break;
        case "pending":
          state = "enabled";
          unbind();
          break;
        default:
          break;
      }
    }
    function onTouchEnd(e) {
      switch (state) {
        case "active":
          state = "enabled";
          unbind();
          deactivate();
          inertialPan(e);
          break;
        case "pending":
          state = "enabled";
          unbind();
          break;
        default:
          break;
      }
    }
    function onBlur(e) {
      switch (state) {
        case "active":
          state = "enabled";
          unbind();
          deactivate();
          fireEvent("dragend", e);
          map.fire("moveend", { originalEvent: e });
          break;
        case "pending":
          state = "enabled";
          unbind();
          break;
        default:
          break;
      }
    }
    function unbind() {
      window.document.removeEventListener("touchmove", onMove, { capture: true, passive: false });
      window.document.removeEventListener("touchend", onTouchEnd);
      window.document.removeEventListener("mousemove", onMove, { capture: true });
      window.document.removeEventListener("mouseup", onMouseUp);
      window.removeEventListener("blur", onBlur);
    }
    function deactivate() {
      frame2.cancel();
      previousPos = void 0;
    }
    function calculateInertia(first, last) {
      const flingOffset = last.value.sub(first.value);
      const flingDuration = (last.time - first.time) / 1e3;
      if (flingDuration === 0 || last.value.equals(first.value)) {
        return { empty: true };
      }
      const velocity = flingOffset.mult(inertiaLinearity / flingDuration);
      let speed = velocity.mag();
      if (speed > inertiaMaxSpeed) {
        speed = inertiaMaxSpeed;
        velocity._unit()._mult(speed);
      }
      const duration = speed / (inertiaDeceleration * inertiaLinearity);
      const offset = velocity.mult(-duration / 2);
      return {
        duration: duration * 1e3,
        offset
      };
    }
    function inertialPan(e) {
      fireEvent("dragend", e);
      const { empty, duration, offset } = inertia2.calculate();
      inertia2 = void 0;
      if (empty) {
        map.fire("moveend", { originalEvent: e });
        return;
      }
      map.panBy(
        offset,
        {
          duration,
          easing: inertiaEasing,
          noMoveStart: true
        },
        { originalEvent: e }
      );
    }
  }
  var inertiaLinearity, inertiaEasing, inertiaMaxSpeed, inertiaDeceleration;
  var init_drag_pan = __esm({
    "../../mapwhit/map-gestures/lib/handler/drag_pan.js"() {
      init_dom();
      init_easing();
      init_frame();
      init_inertia();
      inertiaLinearity = 0.3;
      inertiaEasing = bezier(0, 0, inertiaLinearity, 1);
      inertiaMaxSpeed = 1400;
      inertiaDeceleration = 2500;
    }
  });

  // ../../mapwhit/map-gestures/lib/handler/drag_rotate.js
  function dragRotateHandler(map, options = {}) {
    const { element, button = "right", bearingSnap = 0, pitchWithRotate = true } = options;
    const el = element || map.getCanvasContainer();
    const frame2 = frame(map, onDragFrame);
    let eventButton;
    let inertia2;
    let state = "disabled";
    let previousPos;
    let previousBearing;
    function isEnabled() {
      return state !== "disabled";
    }
    function isActive() {
      return state === "active";
    }
    function enable() {
      if (isEnabled()) return;
      state = "enabled";
    }
    function disable() {
      if (!isEnabled()) return;
      switch (state) {
        case "active":
          state = "disabled";
          unbind();
          deactivate();
          map.fire("rotateend");
          if (pitchWithRotate) {
            map.fire("pitchend");
          }
          map.fire("moveend");
          break;
        case "pending":
          state = "disabled";
          unbind();
          break;
        default:
          state = "disabled";
          break;
      }
    }
    function onMouseDown(e) {
      if (state !== "enabled") return;
      if (button === "right") {
        eventButton = mouseButton(e);
        if (eventButton !== (e.ctrlKey ? 0 : 2)) return;
      } else {
        if (e.ctrlKey || mouseButton(e) !== 0) return;
        eventButton = 0;
      }
      disableDrag();
      window.document.addEventListener("mousemove", onMouseMove, { capture: true });
      window.document.addEventListener("mouseup", onMouseUp);
      window.addEventListener("blur", onBlur);
      state = "pending";
      previousPos = mousePos(el, e);
      previousBearing = map.getBearing();
      inertia2 = inertia(calculateInertia);
      inertia2.update(previousBearing);
      e.preventDefault();
    }
    function onMouseMove(e) {
      const pos = mousePos(el, e);
      frame2.request(e, pos);
      if (state === "pending") {
        state = "active";
        map.fire("rotatestart", { originalEvent: e });
        map.fire("movestart", { originalEvent: e });
        if (pitchWithRotate) {
          map.fire("pitchstart", { originalEvent: e });
        }
      }
    }
    function onDragFrame(e, pos) {
      const tr = map.transform;
      const bearingDiff = (pos.x - previousPos.x) * -0.8;
      const pitchDiff = (pos.y - previousPos.y) * 0.5;
      const bearing = tr.bearing - bearingDiff;
      const pitch = tr.pitch - pitchDiff;
      const normalizedBearing = map._normalizeBearing(bearing, previousBearing);
      inertia2.update(normalizedBearing);
      tr.bearing = bearing;
      if (pitchWithRotate) {
        map.fire("pitch", { originalEvent: e });
        tr.pitch = pitch;
      }
      map.fire("rotate", { originalEvent: e });
      map.fire("move", { originalEvent: e });
      previousBearing = normalizedBearing;
      previousPos = pos;
    }
    function onMouseUp(e) {
      if (mouseButton(e) !== eventButton) return;
      switch (state) {
        case "active":
          state = "enabled";
          suppressClick();
          unbind();
          deactivate();
          inertialRotate(e);
          break;
        case "pending":
          state = "enabled";
          unbind();
          break;
        default:
          break;
      }
    }
    function onBlur(e) {
      switch (state) {
        case "active":
          state = "enabled";
          unbind();
          deactivate();
          map.fire("rotateend", { originalEvent: e });
          if (pitchWithRotate) {
            map.fire("pitchend", { originalEvent: e });
          }
          map.fire("moveend", { originalEvent: e });
          break;
        case "pending":
          state = "enabled";
          unbind();
          break;
        default:
          break;
      }
    }
    function unbind() {
      window.document.removeEventListener("mousemove", onMouseMove, { capture: true });
      window.document.removeEventListener("mouseup", onMouseUp);
      window.removeEventListener("blur", onBlur);
      enableDrag();
    }
    function deactivate() {
      frame2.cancel();
      previousPos = void 0;
      previousBearing = void 0;
      eventButton = void 0;
    }
    function calculateInertia(first, last) {
      const mapBearing = map.getBearing();
      let bearing = map._normalizeBearing(mapBearing, previousBearing);
      const flingDiff = last.value - first.value;
      const sign2 = flingDiff < 0 ? -1 : 1;
      const flingDuration = (last.time - first.time) / 1e3;
      if (flingDiff === 0 || flingDuration === 0) {
        return { empty: true };
      }
      let speed = Math.abs(flingDiff * (inertiaLinearity2 / flingDuration));
      if (speed > inertiaMaxSpeed2) {
        speed = inertiaMaxSpeed2;
      }
      const duration = speed / (inertiaDeceleration2 * inertiaLinearity2);
      const offset = sign2 * speed * (duration / 2);
      bearing += offset;
      if (Math.abs(map._normalizeBearing(bearing, 0)) < bearingSnap) {
        bearing = map._normalizeBearing(0, bearing);
      }
      return {
        duration: duration * 1e3,
        bearing
      };
    }
    function inertialRotate(e) {
      map.fire("rotateend", { originalEvent: e });
      const { empty, bearing, duration } = inertia2.calculate();
      if (empty) {
        if (Math.abs(map.getBearing()) < bearingSnap) {
          map.resetNorth({ noMoveStart: true }, { originalEvent: e });
        } else {
          map.fire("moveend", { originalEvent: e });
        }
        if (pitchWithRotate) {
          map.fire("pitchend", { originalEvent: e });
        }
        return;
      }
      map.rotateTo(
        bearing,
        {
          duration,
          easing: inertiaEasing2,
          noMoveStart: true
        },
        { originalEvent: e }
      );
    }
    initEnableDisableDrag();
    return {
      isActive,
      isEnabled,
      enable,
      disable,
      onMouseDown
    };
  }
  var inertiaLinearity2, inertiaEasing2, inertiaMaxSpeed2, inertiaDeceleration2, drag_rotate_default;
  var init_drag_rotate = __esm({
    "../../mapwhit/map-gestures/lib/handler/drag_rotate.js"() {
      init_dom();
      init_easing();
      init_frame();
      init_inertia();
      inertiaLinearity2 = 0.25;
      inertiaEasing2 = bezier(0, 0, inertiaLinearity2, 1);
      inertiaMaxSpeed2 = 180;
      inertiaDeceleration2 = 720;
      drag_rotate_default = dragRotateHandler;
    }
  });

  // ../../mapwhit/map-gestures/lib/handler/keyboard.js
  function keyboardHandler(map) {
    const el = map.getCanvasContainer();
    let enabled = false;
    return {
      isEnabled,
      enable,
      disable
    };
    function isEnabled() {
      return enabled;
    }
    function enable() {
      if (enabled) return;
      el.addEventListener("keydown", onKeyDown, false);
      enabled = true;
    }
    function disable() {
      if (!enabled) return;
      el.removeEventListener("keydown", onKeyDown);
      enabled = false;
    }
    function onKeyDown(e) {
      if (e.altKey || e.ctrlKey || e.metaKey) return;
      let zoomDir = 0;
      let bearingDir = 0;
      let pitchDir = 0;
      let xDir = 0;
      let yDir = 0;
      switch (e.keyCode) {
        case 61:
        case 107:
        case 171:
        case 187:
          zoomDir = 1;
          break;
        case 189:
        case 109:
        case 173:
          zoomDir = -1;
          break;
        case 37:
          if (e.shiftKey) {
            bearingDir = -1;
          } else {
            e.preventDefault();
            xDir = -1;
          }
          break;
        case 39:
          if (e.shiftKey) {
            bearingDir = 1;
          } else {
            e.preventDefault();
            xDir = 1;
          }
          break;
        case 38:
          if (e.shiftKey) {
            pitchDir = 1;
          } else {
            e.preventDefault();
            yDir = -1;
          }
          break;
        case 40:
          if (e.shiftKey) {
            pitchDir = -1;
          } else {
            yDir = 1;
            e.preventDefault();
          }
          break;
        default:
          return;
      }
      const zoom = map.getZoom();
      const easeOptions = {
        duration: 300,
        delayEndEvents: 500,
        easing: easeOut,
        zoom: zoomDir ? Math.round(zoom) + zoomDir * (e.shiftKey ? 2 : 1) : zoom,
        bearing: map.getBearing() + bearingDir * bearingStep,
        pitch: map.getPitch() + pitchDir * pitchStep,
        offset: [-xDir * panStep, -yDir * panStep],
        center: map.getCenter()
      };
      map.easeTo(easeOptions, { originalEvent: e });
    }
  }
  function easeOut(t) {
    return t * (2 - t);
  }
  var panStep, bearingStep, pitchStep;
  var init_keyboard = __esm({
    "../../mapwhit/map-gestures/lib/handler/keyboard.js"() {
      panStep = 100;
      bearingStep = 15;
      pitchStep = 10;
    }
  });

  // ../../mapwhit/map-gestures/lib/util/interpolate.js
  function interpolate(a, b, t) {
    return a * (1 - t) + b * t;
  }
  var init_interpolate = __esm({
    "../../mapwhit/map-gestures/lib/util/interpolate.js"() {
    }
  });

  // ../../mapwhit/map-gestures/lib/handler/scroll_zoom.js
  function computeSmoothOutEasing() {
    let _prevEase;
    function compute(duration) {
      let easing = ease;
      if (_prevEase) {
        const t = (performance.now() - _prevEase.start) / _prevEase.duration;
        const speed = _prevEase.easing(t + 0.01) - _prevEase.easing(t);
        const x = 0.27 / Math.sqrt(speed * speed + 1e-4) * 0.01;
        const y = Math.sqrt(0.27 * 0.27 - x * x);
        easing = bezier(x, y, 0.25, 1);
      }
      _prevEase = {
        start: performance.now(),
        duration,
        easing
      };
      return easing;
    }
    return compute;
  }
  function scrollZoomHandler(map) {
    let _delta = 0;
    let enabled = false;
    let active = false;
    let zooming = false;
    let aroundCenter;
    let _lastWheelEvent;
    let _lastWheelEventTime = 0;
    let _lastValue = 0;
    let _timeout;
    let _finishTimeout;
    let _type;
    let _around;
    let _aroundPoint;
    let _startZoom;
    let _targetZoom;
    let _easing;
    const frame2 = frame(map, onScrollFrame);
    const smoothOutEasing = computeSmoothOutEasing();
    return {
      isActive,
      isZooming,
      isEnabled,
      enable,
      disable,
      onWheel
    };
    function isEnabled() {
      return enabled;
    }
    function isActive() {
      return active;
    }
    function isZooming() {
      return zooming;
    }
    function enable(options) {
      if (enabled) return;
      enabled = true;
      aroundCenter = options?.around === "center";
    }
    function disable() {
      enabled = false;
    }
    function onWheel(e) {
      if (!enabled) return;
      let value = e.deltaMode === window.WheelEvent.DOM_DELTA_LINE ? e.deltaY * 40 : e.deltaY;
      const now = performance.now();
      const timeDelta = now - _lastWheelEventTime;
      _lastWheelEventTime = now;
      _lastWheelEvent = e;
      if (value !== 0 && value % wheelZoomDelta === 0) {
        _type = "wheel";
      } else if (value !== 0 && Math.abs(value) < 4) {
        _type = "trackpad";
      } else if (timeDelta > 400) {
        _type = void 0;
        _lastValue = value;
        _timeout = setTimeout(onTimeout, 40);
      } else if (!_type) {
        _type = Math.abs(timeDelta * value) < 200 ? "trackpad" : "wheel";
        if (_timeout) {
          clearTimeout(_timeout);
          _timeout = void 0;
          value += _lastValue;
        }
      }
      if (e.shiftKey && value) value = value / 4;
      if (_type) {
        _delta -= value;
        if (!active) {
          start(e);
        }
      }
      e.preventDefault();
    }
    function onTimeout() {
      _timeout = void 0;
      _type = "wheel";
      _delta -= _lastValue;
      if (!active) {
        start();
      }
    }
    function start() {
      if (!_delta) return;
      frame2.cancel();
      active = true;
      if (!zooming) {
        zooming = true;
        map.fire("movestart", { originalEvent: _lastWheelEvent });
        map.fire("zoomstart", { originalEvent: _lastWheelEvent });
      }
      if (_finishTimeout) {
        clearTimeout(_finishTimeout);
      }
      if (aroundCenter) {
        _around = map.getCenter();
        _aroundPoint = map.transform.locationPoint(_around);
      } else {
        _aroundPoint = mousePos(map.getCanvasContainer(), _lastWheelEvent);
        _around = map.unproject(_aroundPoint);
      }
      frame2.request();
    }
    function onScrollFrame() {
      if (!active) return;
      const tr = map.transform;
      if (_delta !== 0) {
        const zoomRate = _type === "wheel" && Math.abs(_delta) > wheelZoomDelta ? wheelZoomRate : defaultZoomRate;
        let scale = maxScalePerFrame / (1 + Math.exp(-Math.abs(_delta * zoomRate)));
        if (_delta < 0 && scale !== 0) {
          scale = 1 / scale;
        }
        const fromScale = typeof _targetZoom === "number" ? tr.zoomScale(_targetZoom) : tr.scale;
        _targetZoom = Math.min(tr.maxZoom, Math.max(tr.minZoom, tr.scaleZoom(fromScale * scale)));
        if (_type === "wheel") {
          _startZoom = tr.zoom;
          _easing = smoothOutEasing(200);
        }
        _delta = 0;
      }
      const targetZoom = typeof _targetZoom === "number" ? _targetZoom : tr.zoom;
      let finished = false;
      if (_type === "wheel" && _startZoom && _easing) {
        const t = Math.min((performance.now() - _lastWheelEventTime) / 200, 1);
        const k = _easing(t);
        tr.zoom = interpolate(_startZoom, targetZoom, k);
        if (t < 1) {
          frame2.request();
        } else {
          finished = true;
        }
      } else {
        tr.zoom = targetZoom;
        finished = true;
      }
      tr.setLocationAtPoint(_around, _aroundPoint);
      map.fire("move", { originalEvent: _lastWheelEvent });
      map.fire("zoom", { originalEvent: _lastWheelEvent });
      if (finished) {
        active = false;
        _finishTimeout = setTimeout(() => {
          zooming = false;
          _finishTimeout = void 0;
          map.fire("zoomend", { originalEvent: _lastWheelEvent });
          map.fire("moveend", { originalEvent: _lastWheelEvent });
          _targetZoom = void 0;
        }, 200);
      }
    }
  }
  var wheelZoomDelta, defaultZoomRate, wheelZoomRate, maxScalePerFrame;
  var init_scroll_zoom = __esm({
    "../../mapwhit/map-gestures/lib/handler/scroll_zoom.js"() {
      init_dom();
      init_easing();
      init_frame();
      init_interpolate();
      wheelZoomDelta = 4.000244140625;
      defaultZoomRate = 1 / 100;
      wheelZoomRate = 1 / 450;
      maxScalePerFrame = 2;
    }
  });

  // ../../mapwhit/map-gestures/lib/handler/touch_zoom_rotate.js
  function makeMovement(map, { rotationDisabled, aroundCenter }, e) {
    const el = map.getCanvasContainer();
    const frame2 = frame(map, onFrame);
    const { vector: startVector, center } = getVector(e);
    const startScale = map.transform.scale;
    const startBearing = map.transform.bearing;
    const inertia2 = inertia(calculateInertia);
    let gestureIntent;
    let lastCenter = center;
    const around = map.transform.pointLocation(center);
    return {
      onMove,
      onFrame,
      onEnd
    };
    function onMove(e2) {
      const { vector, center: center2 } = getVector(e2);
      lastCenter = center2;
      const scale = vector.mag() / startVector.mag();
      inertia2.update(scale);
      frame2.request(e2, { vector, scale, center: center2 });
      if (gestureIntent) return;
      if (!rotationDisabled) {
        const bearing = vector.angleWith(startVector) * 180 / Math.PI;
        if (Math.abs(bearing) > SIGNIFICANT_ROTATE_THRESHOLD) {
          gestureIntent = "rotate";
        }
      }
      if (!gestureIntent) {
        if (rotationDisabled && scale !== 1) {
          gestureIntent = "zoom";
        } else if (Math.abs(1 - scale) > SIGNIFICANT_SCALE_THRESHOLD) {
          gestureIntent = "zoom";
        }
      }
      if (gestureIntent) {
        map.fire(`${gestureIntent}start`, { originalEvent: e2 });
        map.fire("movestart", { originalEvent: e2 });
      }
    }
    function onFrame(e2, { vector, scale, center: center2 }) {
      if (!gestureIntent) return;
      if (gestureIntent === "rotate") {
        const bearing = vector.angleWith(startVector) * 180 / Math.PI;
        map.transform.bearing = startBearing + bearing;
      }
      map.transform.zoom = map.transform.scaleZoom(startScale * scale);
      map.transform.setLocationAtPoint(around, center2);
      map.fire(gestureIntent, { originalEvent: e2 });
      map.fire("move", { originalEvent: e2 });
    }
    function onEnd(e2) {
      frame2.cancel();
      if (!gestureIntent) return;
      map.fire(`${gestureIntent}end`, { originalEvent: e2 });
      const { zoom, duration, empty } = inertia2.calculate();
      if (empty) {
        map.snapToNorth({}, { originalEvent: e2 });
      } else {
        map.easeTo(
          {
            zoom,
            duration,
            easing: INERTIA_EASING,
            around: aroundCenter ? map.getCenter() : map.unproject(lastCenter),
            noMoveStart: true
          },
          { originalEvent: e2 }
        );
      }
    }
    function getVector({ touches: [t0, t1] }) {
      const p0 = mousePos(el, t0);
      const p1 = mousePos(el, t1);
      return {
        vector: p0.sub(p1),
        center: p0.add(p1).div(2)
      };
    }
    function calculateInertia(first, last) {
      const firstZoom = map.transform.scaleZoom(startScale * first.value);
      const lastZoom = map.transform.scaleZoom(startScale * last.value);
      const scaleDuration = (last.time - first.time) / 1e3;
      if (scaleDuration === 0 || lastZoom === firstZoom) {
        return { empty: true };
      }
      let speed = (lastZoom - firstZoom) * INERTIA_LINEARITY / scaleDuration;
      if (speed > INERTIA_MAX_SPEED) {
        speed = INERTIA_MAX_SPEED;
      } else if (speed < -INERTIA_MAX_SPEED) {
        speed = -INERTIA_MAX_SPEED;
      }
      const duration = Math.abs(speed / (INERTIA_DECELERATION * INERTIA_LINEARITY)) * 1e3;
      let zoom = lastZoom + speed * duration / 2e3;
      if (zoom < 0) {
        zoom = 0;
      }
      return { zoom, duration };
    }
  }
  function touchZoomRotateHandler(map) {
    let enabled = false;
    let aroundCenter = false;
    let rotationDisabled = false;
    let movement;
    return {
      isEnabled,
      isActive,
      enable,
      disable,
      enableRotation,
      disableRotation,
      onStart
    };
    function isEnabled() {
      return enabled;
    }
    function isActive() {
      return !!movement;
    }
    function enable(options) {
      if (enabled) return;
      map.getCanvasContainer().classList.add("mapboxgl-touch-zoom-rotate");
      enabled = true;
      aroundCenter = options && options.around === "center";
    }
    function disable() {
      if (!enabled) return;
      map.getCanvasContainer().classList.remove("mapboxgl-touch-zoom-rotate");
      enabled = false;
    }
    function disableRotation() {
      rotationDisabled = true;
    }
    function enableRotation() {
      rotationDisabled = false;
    }
    function onStart(e) {
      if (!enabled) return;
      if (e.touches.length !== 2) return;
      movement = makeMovement(map, { rotationDisabled, aroundCenter }, e);
      window.document.addEventListener("touchmove", onMove, { passive: false });
      window.document.addEventListener("touchend", onEnd);
    }
    function onMove(e) {
      if (e.touches.length !== 2) return;
      if (movement) {
        movement.onMove(e);
        e.preventDefault();
      }
    }
    function onEnd(e) {
      window.document.removeEventListener("touchmove", onMove, { passive: false });
      window.document.removeEventListener("touchend", onEnd);
      movement.onEnd(e);
      movement = void 0;
    }
  }
  var INERTIA_LINEARITY, INERTIA_EASING, INERTIA_DECELERATION, INERTIA_MAX_SPEED, SIGNIFICANT_SCALE_THRESHOLD, SIGNIFICANT_ROTATE_THRESHOLD;
  var init_touch_zoom_rotate = __esm({
    "../../mapwhit/map-gestures/lib/handler/touch_zoom_rotate.js"() {
      init_dom();
      init_easing();
      init_frame();
      init_inertia();
      INERTIA_LINEARITY = 0.15;
      INERTIA_EASING = bezier(0, 0, INERTIA_LINEARITY, 1);
      INERTIA_DECELERATION = 12;
      INERTIA_MAX_SPEED = 2.5;
      SIGNIFICANT_SCALE_THRESHOLD = 0.15;
      SIGNIFICANT_ROTATE_THRESHOLD = 10;
    }
  });

  // ../../mapwhit/map-gestures/lib/util/events.js
  var MapEvent, MapMouseEvent, MapTouchEvent, MapWheelEvent;
  var init_events3 = __esm({
    "../../mapwhit/map-gestures/lib/util/events.js"() {
      init_point_geometry2();
      init_events2();
      init_dom();
      MapEvent = class extends Event2 {
        #defaultPrevented = false;
        /**
         * @param {string} type
         * @param {Map} map The Map object that fired the event.
         * @param {object} data Additional data associated with the event.
         */
        constructor(type, map, data) {
          super(type, data);
          this.target = map;
        }
        /**
         * Prevents subsequent default processing of the event by the map.
         * Calling this method will prevent the following default map behaviors:
         *
         * - on `mousedown` events, the behavior of `DragPanHandler`
         * - on `mousedown` events, the behavior of `DragRotateHandler`
         * - on `mousedown` events, the behavior of `BoxZoomHandler`
         * - on `dblclick` events, the behavior of `DoubleClickZoomHandler`
         *
         * - on `touchstart` events, the behavior of `DragPanHandler`
         * - on `touchstart` events, the behavior of `TouchZoomRotateHandler`
         *
         * - on `mousewheel` events, the the behavior of `ScrollZoomHandler}`
         *
         */
        preventDefault() {
          this.#defaultPrevented = true;
        }
        /**
         * `true` if `preventDefault` has been called.
         */
        get defaultPrevented() {
          return this.#defaultPrevented;
        }
      };
      MapMouseEvent = class extends MapEvent {
        /**
         * @param {string} type
         * @param {Map} map The Map object that fired the event.
         * @param {object} originalEvent The DOM event which caused the map event.
         */
        constructor(type, map, originalEvent) {
          const point = mousePos(map.getCanvasContainer(), originalEvent);
          const lngLat = map.unproject(point);
          super(type, map, { point, lngLat, originalEvent });
        }
      };
      MapTouchEvent = class extends MapEvent {
        /**
         * @param {string} type
         * @param {Map} map The Map object that fired the event.
         * @param {object} originalEvent The DOM event which caused the map event.
         */
        constructor(type, map, originalEvent) {
          const points = touchPos(map.getCanvasContainer(), originalEvent);
          const lngLats = points.map((t) => map.unproject(t));
          const len = points.length;
          const point = points.reduce((prev, curr) => prev.add(curr.div(len)), new Point2(0, 0));
          const lngLat = map.unproject(point);
          super(type, map, { points, point, lngLats, lngLat, originalEvent });
        }
      };
      MapWheelEvent = class extends MapEvent {
        /**
         * @param {string} type
         * @param {Map} map The Map object that fired the event.
         * @param {object} originalEvent The DOM event which caused the map event.
         */
        constructor(type, map, originalEvent) {
          super(type, map, { originalEvent });
        }
      };
    }
  });

  // ../../mapwhit/map-gestures/lib/map-gestures.js
  var map_gestures_exports = {};
  __export(map_gestures_exports, {
    MapMouseEvent: () => MapMouseEvent,
    MapTouchEvent: () => MapTouchEvent,
    MapWheelEvent: () => MapWheelEvent,
    default: () => bindMapGestures
  });
  function bindMapGestures(map, options) {
    options = { ...defaultOptions, ...options, fireEvent };
    const el = map.getCanvasContainer();
    let contextMenuEvent = null;
    let mouseDown = false;
    let startPos = null;
    const gestures = new Evented2();
    if (options.bubbleEventsToMap) {
      gestures.setEventedParent(map);
    }
    Object.entries(handlers).forEach(([name, handler]) => {
      const bound = handler(map, options);
      if (options.interactive && options[name]) {
        bound.enable(options[name]);
      }
      gestures[name] = bound;
    });
    el.addEventListener("mouseout", onMouseOut);
    el.addEventListener("mousedown", onMouseDown);
    el.addEventListener("mouseup", onMouseUp);
    el.addEventListener("mousemove", onMouseMove);
    el.addEventListener("mouseover", onMouseOver);
    el.addEventListener("touchstart", onTouchStart, { passive: false });
    el.addEventListener("touchmove", onTouchMove, { passive: false });
    el.addEventListener("touchend", onTouchEnd);
    el.addEventListener("touchcancel", onTouchCancel);
    el.addEventListener("click", onClick);
    el.addEventListener("dblclick", onDblClick);
    el.addEventListener("contextmenu", onContextMenu);
    el.addEventListener("wheel", onWheel, { passive: false });
    map._mapGestures = {
      isMoving,
      isZooming,
      isRotating
    };
    return gestures;
    function onMouseDown(e) {
      mouseDown = true;
      startPos = mousePos(el, e);
      const mapEvent = new MapMouseEvent("mousedown", map, e);
      fireEvent(mapEvent);
      if (mapEvent.defaultPrevented) {
        return;
      }
      if (options.interactive && !gestures.doubleClickZoom.isActive()) {
        map.stop();
      }
      gestures.boxZoom.onMouseDown(e);
      if (!gestures.boxZoom.isActive() && !gestures.dragPan.isActive()) {
        gestures.dragRotate.onMouseDown(e);
      }
      if (!gestures.boxZoom.isActive() && !gestures.dragRotate.isActive()) {
        gestures.dragPan.onMouseDown(e);
      }
    }
    function onMouseUp(e) {
      const rotating = gestures.dragRotate.isActive();
      if (contextMenuEvent && !rotating) {
        fireEvent(new MapMouseEvent("contextmenu", map, contextMenuEvent));
      }
      contextMenuEvent = null;
      mouseDown = false;
      fireEvent(new MapMouseEvent("mouseup", map, e));
    }
    function onMouseMove(e) {
      if (gestures.dragPan.isActive()) return;
      if (gestures.dragRotate.isActive()) return;
      if (gestures.touchZoomRotate.isActive()) return;
      let target = e.target;
      while (target && target !== el) target = target.parentNode;
      if (target !== el) return;
      fireEvent(new MapMouseEvent("mousemove", map, e));
    }
    function onMouseOver(e) {
      let { target } = e;
      while (target && target !== el) target = target.parentNode;
      if (target !== el) return;
      fireEvent(new MapMouseEvent("mouseover", map, e));
    }
    function onMouseOut(e) {
      fireEvent(new MapMouseEvent("mouseout", map, e));
    }
    function onTouchStart(e) {
      const mapEvent = new MapTouchEvent("touchstart", map, e);
      fireEvent(mapEvent);
      if (mapEvent.defaultPrevented) {
        return;
      }
      if (options.interactive) {
        map.stop();
      }
      if (!gestures.boxZoom.isActive() && !gestures.dragRotate.isActive()) {
        gestures.dragPan.onTouchStart(e);
      }
      gestures.touchZoomRotate.onStart(e);
      gestures.doubleClickZoom.onTouchStart(mapEvent);
    }
    function onTouchMove(e) {
      if (gestures.dragPan.isActive()) return;
      if (gestures.dragRotate.isActive()) return;
      if (gestures.touchZoomRotate.isActive()) return;
      fireEvent(new MapTouchEvent("touchmove", map, e));
    }
    function onTouchEnd(e) {
      fireEvent(new MapTouchEvent("touchend", map, e));
    }
    function onTouchCancel(e) {
      fireEvent(new MapTouchEvent("touchcancel", map, e));
    }
    function onClick(e) {
      if (startPos) {
        const pos = mousePos(el, e);
        if (pos.dist(startPos) > options.clickTolerance) {
          return;
        }
      }
      fireEvent(new MapMouseEvent("click", map, e));
    }
    function onDblClick(e) {
      const mapEvent = new MapMouseEvent("dblclick", map, e);
      fireEvent(mapEvent);
      if (mapEvent.defaultPrevented) {
        return;
      }
      gestures.doubleClickZoom.onDblClick(mapEvent);
    }
    function onContextMenu(e) {
      const rotating = gestures.dragRotate.isActive();
      if (!mouseDown && !rotating) {
        fireEvent(new MapMouseEvent("contextmenu", map, e));
      } else if (mouseDown) {
        contextMenuEvent = e;
      }
      e.preventDefault();
    }
    function onWheel(e) {
      const mapEvent = new MapWheelEvent("wheel", map, e);
      fireEvent(mapEvent);
      if (mapEvent.defaultPrevented) {
        return;
      }
      gestures.scrollZoom.onWheel(e);
    }
    function isMoving() {
      return gestures.dragPan.isActive() || gestures.dragRotate.isActive() || gestures.touchZoomRotate.isActive() || gestures.scrollZoom.isActive();
    }
    function isZooming() {
      return gestures.touchZoomRotate.isActive() || gestures.scrollZoom.isZooming();
    }
    function isRotating() {
      return gestures.touchZoomRotate.isActive() || gestures.dragRotate.isActive();
    }
    function fireEvent(type, e, data = {}) {
      gestures.fire(type, e ? { originalEvent: e, ...data } : data);
    }
  }
  var defaultOptions, handlers;
  var init_map_gestures = __esm({
    "../../mapwhit/map-gestures/lib/map-gestures.js"() {
      init_events2();
      init_box_zoom();
      init_dblclick_zoom();
      init_drag_pan();
      init_drag_rotate();
      init_keyboard();
      init_scroll_zoom();
      init_touch_zoom_rotate();
      init_dom();
      init_events3();
      defaultOptions = {
        interactive: true,
        scrollZoom: true,
        boxZoom: true,
        dragRotate: true,
        dragPan: true,
        keyboard: true,
        doubleClickZoom: true,
        touchZoomRotate: true,
        clickTolerance: 3,
        bubbleEventsToMap: false
      };
      handlers = {
        scrollZoom: scrollZoomHandler,
        boxZoom: boxZoomHandler,
        dragRotate: drag_rotate_default,
        dragPan: dragPanHandler,
        keyboard: keyboardHandler,
        doubleClickZoom: doubleClickZoomHandler,
        touchZoomRotate: touchZoomRotateHandler
      };
    }
  });

  // ../lib/style/expression.js
  var require_expression3 = __commonJS({
    "../lib/style/expression.js"(exports, module) {
      module.exports = check;
      function checkSingleProperty(property, object) {
        return object[property];
      }
      function checkProperty(property) {
        return checkSingleProperty(property, this);
      }
      function checkAnyProperty(properties, object) {
        return properties.some(checkProperty, object);
      }
      function checkAllProperties(properties, object) {
        return properties.every(checkProperty, object);
      }
      function check(expr) {
        if (Array.isArray(expr)) {
          if (expr[0] === "all") {
            return checkAllProperties.bind(void 0, expr.slice(1));
          }
          return checkAnyProperty.bind(void 0, expr.slice(1));
        }
        return checkSingleProperty.bind(void 0, expr);
      }
    }
  });

  // ../lib/style/visibility.js
  var require_visibility = __commonJS({
    "../lib/style/visibility.js"(exports, module) {
      var expression = require_expression3();
      module.exports = {
        initVisibility,
        evalVisibility
      };
      function initVisibility(id, visibility) {
        if (!visibility) {
          return;
        }
        const check = expression(visibility);
        return {
          id,
          check
        };
      }
      function setVisibility(style) {
        const { _m, object } = this;
        if (_m.getLayer(style.id)) {
          _m.setLayoutProperty(style.id, "visibility", style.check(object) ? "visible" : "none");
        }
      }
      function evalVisibility(_m, visibility, object) {
        visibility.forEach(setVisibility, {
          _m,
          object
        });
      }
    }
  });

  // ../lib/zoom.js
  var require_zoom = __commonJS({
    "../lib/zoom.js"(exports, module) {
      function zoomIn() {
        this.zoom(this.zoom() + 1);
        return this;
      }
      function zoomOut() {
        this.zoom(this.zoom() - 1);
        return this;
      }
      module.exports = {
        zoomIn,
        zoomOut
      };
    }
  });

  // ../lib/map.js
  var require_map2 = __commonJS({
    "../lib/map.js"(exports, module) {
      var images = require_images();
      var object = require_object2();
      var util = require_util2();
      var makeFeatureEventHandler = require_feature_event_handler();
      var mapGestures = (init_map_gestures(), __toCommonJS(map_gestures_exports)).default;
      var query = require_query();
      var { initVisibility, evalVisibility } = require_visibility();
      var { refresh: refreshFeatures } = require_source3();
      module.exports = map;
      var SIZE = [16, 16];
      function getAttribution(result, attr) {
        attr = attr.slice(6).match(/(?:http:|https:)?\/\/([^\/?]+)/);
        if (attr) {
          attr = attr[1].split(".");
          if (attr.length > 1) {
            attr = attr[attr.length - 2];
          }
          if (attr) {
            result.push(attr);
          }
        }
        return result;
      }
      function preprocessDataEvent(event) {
        if (!(event.dataType === "source" && event.tile && (event.tile.state === "loaded" || event.tile.state === "unloaded"))) {
          return true;
        }
        let sourceAttribution;
        if (event.style?.sourceCaches && event.sourceId) {
          const source = event.style.sourceCaches[event.sourceId];
          if (source.used) {
            sourceAttribution = source.getSource().attribution;
            if (sourceAttribution) {
              const attribution = sourceAttribution.match(/href="[^"]+/g);
              if (attribution) {
                event.attribution = attribution.reduce(getAttribution, []);
                event.attribution.metadata = event.source?.metadata;
              }
            }
          }
        }
        if (event.source) {
          const source = event.source.url || event.source.tiles?.[0];
          if (source) {
            event.sourceHostname = new URL(source).hostname;
          }
          event.source.attribution = event.source.attribution || sourceAttribution;
        }
        return true;
      }
      async function map(node, options) {
        let mapTypeId;
        let styles;
        let resolve;
        const promise = new Promise((res) => {
          resolve = res;
        });
        options = Object.assign(
          {
            mapboxgl,
            container: node,
            style: {
              version: 8,
              sources: {},
              layers: []
            },
            visibility: {}
          },
          options
        );
        const self2 = object(
          {
            bounds: bounds2,
            center,
            destroy,
            element,
            ll,
            mapType,
            move,
            panBy,
            panToBounds,
            queryRenderedFeatures,
            refresh,
            visibility,
            zoom,
            registerImage
          },
          {
            preprocessEvent: {
              data: preprocessDataEvent
            }
          }
        );
        if (options.zoom) {
          options.zoom -= 1;
        }
        if (options.minZoom) {
          options.minZoom -= 1;
        }
        if (options.maxZoom) {
          options.maxZoom -= 1;
        }
        Object.assign(self2, require_zoom());
        self2._m = new options.mapboxgl.Map(options);
        const gestures = mapGestures(self2._m, options);
        gestures.touchZoomRotate.disableRotation();
        self2._featureEventHandler = makeFeatureEventHandler(self2._m);
        self2._images = images();
        wait4style();
        return promise;
        function element() {
          return node;
        }
        function center(c) {
          if (!c) {
            return util.mll2ll(self2._m.getCenter());
          }
          self2._m.setCenter(c);
        }
        function zoom(z) {
          if (z === void 0) {
            return Math.round(self2._m.getZoom() + 1);
          }
          self2._m[self2._m.isStyleLoaded() ? "zoomTo" : "setZoom"](z - 1);
        }
        function move(options2, animate = true) {
          if (options2.zoom) {
            options2 = { ...options2, zoom: options2.zoom - 1 };
          }
          self2._m[animate && self2._m.isStyleLoaded() ? "easeTo" : "jumpTo"](options2);
        }
        function bounds2(b) {
          if (b === void 0) {
            return util.mbounds2bounds(self2._m.getBounds());
          }
          const opt = {
            padding: 100
          };
          if (!self2._m.isStyleLoaded()) {
            opt.animate = false;
          }
          self2._m.fitBounds(b, opt);
        }
        function panToBounds(bounds3) {
          self2._m.panTo([bounds3[1][0], bounds3[0][1]]);
          return self2;
        }
        function panBy(x, y) {
          self2._m.panBy([x, y]);
          return self2;
        }
        function mapType() {
          return mapTypeId;
        }
        function wait4style(wait = true) {
          if (wait) {
            self2._m.on("styledata", callback);
            self2._m.on("data", callback);
            return;
          }
          self2._m.off("styledata", callback);
          self2._m.off("data", callback);
        }
        function refresh(style) {
          if (!style) {
            return self2._m.resize();
          }
          styles = void 0;
          wait4style();
          self2._m.setStyle(style);
        }
        function initStyles() {
          if (styles) {
            return;
          }
          const style = self2._m.getStyle();
          if (!style.layers) {
            return;
          }
          styles = style.layers.reduce(
            (result, layer) => {
              if (layer.metadata) {
                const visibility2 = initVisibility(layer.id, layer.metadata.visibility);
                if (visibility2) {
                  result.visibility.push(visibility2);
                }
              }
              if (layer["source-layer"] === "poi") {
                result.poi.push(layer.id);
              }
              return result;
            },
            {
              poi: [],
              visibility: []
            }
          );
          evalVisibility(self2._m, styles.visibility, options.visibility);
          self2._images.refresh({
            _m: self2._m,
            ready: true
          }).then(() => refreshFeatures(self2));
        }
        function callback() {
          if (!self2._m?.isStyleLoaded()) {
            return;
          }
          initStyles();
          resolve(self2);
          wait4style(false);
        }
        function ll(e) {
          if (e?.lngLat) {
            e.ll = util.mll2ll(e.lngLat);
          }
        }
        function queryRenderedFeatures(point, options2 = {}) {
          if (options2.layers === void 0 && styles) {
            options2.layers = styles.poi;
          }
          return query(self2._m, point, 3, options2).map(({ properties, geometry }) => {
            if (geometry && geometry.type === "Point") {
              return Object.assign(
                {
                  ll: geometry.coordinates
                },
                properties
              );
            }
            return properties;
          });
        }
        function visibility(key, value) {
          if (key === void 0) {
            return options.visibility;
          }
          if (typeof key === "object") {
            options.visibility = key;
          } else {
            options.visibility[key] = value;
          }
          evalVisibility(self2._m, styles.visibility, options.visibility);
        }
        function path2url(url) {
          if (typeof url === "string") {
            return url;
          }
          let { path, fillColor, strokeColor, strokeWeight, scale = 1, size = SIZE } = url;
          if (scale !== 1) {
            size = [Math.round(size[0] * scale), Math.round(size[1] * scale)];
          }
          url = '<svg xmlns="http://www.w3.org/2000/svg" width="' + size[0] + '" height="' + size[1] + '" viewBox="0 0 ' + size.join(" ") + '"><path d="' + path + '" stroke="' + strokeColor + '" stroke-width="' + strokeWeight + '"';
          if (fillColor) {
            url += ' fill="' + fillColor + '"';
          }
          if (scale !== 1) {
            url += ' transform="scale(' + scale + ')"';
          }
          url += "/></svg>";
          return "data:image/svg+xml;base64," + btoa(url);
        }
        function registerImage(name, url, size = SIZE) {
          const map2 = {
            _m: self2._m,
            ready: true
          };
          self2._images.init(map2);
          return self2._images.add(map2, name, path2url(url), size);
        }
        function destroy() {
          if (self2._m) {
            self2.off();
            self2._m.remove();
            self2._images.destroy();
            delete self2._m;
            delete self2._images;
          }
          styles = void 0;
        }
      }
    }
  });

  // ../lib/outline.js
  var require_outline = __commonJS({
    "../lib/outline.js"(exports, module) {
      module.exports = outline;
      function outline(points) {
        let se;
        let nw;
        const self2 = {
          include,
          bounds: bounds2
        };
        return include(points);
        function include(points2) {
          if (!points2 || !points2.length) {
            return self2;
          }
          se ??= points2[0].slice();
          nw ??= points2[0].slice();
          points2.forEach(function(point) {
            const x = point[0];
            const y = point[1];
            if (x < se[0]) {
              se[0] = x;
            }
            if (x > nw[0]) {
              nw[0] = x;
            }
            if (y < se[1]) {
              se[1] = y;
            }
            if (y > nw[1]) {
              nw[1] = y;
            }
          });
          return self2;
        }
        function bounds2() {
          return [se, nw];
        }
      }
    }
  });

  // ../lib/projection.js
  var require_projection2 = __commonJS({
    "../lib/projection.js"(exports, module) {
      var util = require_util2();
      module.exports = projection;
      function projection(options) {
        function position(p) {
          if (p.position) {
            p = p.position();
          }
          return options.map._m.project(p);
        }
        function location(x, y) {
          const p = y === void 0 ? x : [x, y];
          return options.map._m.unproject(p);
        }
        function toMap(x, y) {
          return util.mll2ll(options.map._m.unproject(y === void 0 ? x : [x, y]));
        }
        function toScreen(ll) {
          const xy = options.map._m.project(ll);
          return [xy.x, xy.y];
        }
        function isReady() {
          return true;
        }
        function remove() {
        }
        if (options.calculate) {
          setTimeout(options.calculate.bind(options.calculate), 0);
          options.map.on("bounds_changed", options.calculate.bind(options));
        }
        return {
          position,
          // obsolete, use toScreen
          location,
          // obsolete, use to Map
          toMap,
          toScreen,
          isReady,
          remove
        };
      }
    }
  });

  // ../lib/spread.js
  var require_spread = __commonJS({
    "../lib/spread.js"(exports, module) {
      var { distance } = require_util2();
      var posSeq = [
        [0, 0],
        [-1, 0],
        [-1, 1],
        [0, 1],
        [1, 1],
        [1, 0],
        [1, -1],
        [0, -1],
        [-1, -1],
        [-2, -1],
        [-2, 0],
        [-2, 1],
        [-2, 2],
        [-1, 2],
        [0, 2],
        [1, 2],
        [2, 2],
        [2, 1],
        [2, 0],
        [2, -1],
        [2, -2],
        [1, -2],
        [0, -2],
        [-1, -2],
        [-2, -2],
        [-3, -2],
        [-3, -1],
        [-3, 0],
        [-3, 1],
        [-3, 2],
        [-3, 3],
        [-2, 3],
        [-1, 3],
        [0, 3],
        [1, 3],
        [2, 3],
        [3, 3],
        [3, 2],
        [3, 1],
        [3, 0],
        [3, -1],
        [3, -2],
        [3, -3],
        [2, -3],
        [1, -3],
        [0, -3],
        [-1, -3],
        [-2, -3],
        [-3, -3],
        [-4, -3],
        [-4, -2],
        [-4, -1],
        [-4, 0],
        [-4, 1],
        [-4, 2],
        [-4, 3],
        [-4, 4],
        [-3, 4],
        [-2, 4],
        [-1, 4],
        [0, 4],
        [1, 4],
        [2, 4],
        [3, 4],
        [4, 4],
        [4, 3],
        [4, 2],
        [4, 1],
        [4, 0],
        [4, -1],
        [4, -2],
        [4, -3],
        [4, -4],
        [3, -4],
        [2, -4],
        [1, -4],
        [0, -4],
        [-1, -4],
        [-2, -4],
        [-3, -4],
        [-4, -4]
      ];
      module.exports = spread;
      function spread(options) {
        let regions;
        let markers = [];
        const threshold = options.threshold || 18;
        const proj = options.projection || this.projection({
          map: options.map,
          calculate
        });
        return {
          add,
          reset,
          calculate
        };
        function reset() {
          markers = [];
          regions = void 0;
        }
        function add(marker) {
          markers.push(marker);
        }
        function calculate() {
          if (!proj.isReady()) {
            return;
          }
          if (markers[0] && !markers[0].originalPosition) {
            markers.forEach(function(m) {
              m.originalPosition = m.position();
            });
          }
          regions = [];
          prepareRegions();
          combineRegions();
          moveMarkers();
        }
        function prepareRegions() {
          markers.forEach(function(m) {
            if (!regions.some(function(r) {
              if (addToRegion(r, m)) {
                return true;
              }
            })) {
              regions.push(createRegion(m));
            }
          });
        }
        function createRegion(m) {
          return {
            center: proj.position(m.originalPosition),
            threshold,
            markers: [m]
          };
        }
        function addToRegion(r, m) {
          if (distance(r.center, proj.position(m.originalPosition)) < r.threshold) {
            r.markers.push(m);
            r.threshold = calcThreshold(r.markers.length) * threshold;
            return true;
          }
        }
        function combineRegions() {
          regions.forEach(function(r, i) {
            for (i = i + 1; i < regions.length; i++) {
              if (distance(r.center, regions[i].center) < (r.threshold + regions[i].threshold) / 2) {
                regions[i].markers = regions[i].markers.concat(r.markers);
                regions[i].threshold = calcThreshold(regions[i].markers.length) * threshold;
                r.markers = [];
              }
            }
          });
        }
        function calcThreshold(len) {
          if (len < 2) {
            return 1;
          }
          if (len < 10) {
            return 2;
          }
          if (len < 26) {
            return 3;
          }
          if (len < 50) {
            return 4;
          }
          if (len < 82) {
            return 5;
          }
          return 6;
        }
        function moveMarkers() {
          regions.forEach(function(r) {
            r.markers.some(function(m, i) {
              let p;
              if (i === posSeq.length) {
                return true;
              }
              p = {
                x: r.center.x + posSeq[i][0] * threshold,
                y: r.center.y + posSeq[i][1] * threshold
              };
              p = proj.toMap(p.x, p.y);
              m.position(p);
            });
          });
        }
      }
    }
  });

  // ../lib/index.js
  var require_lib = __commonJS({
    "../lib/index.js"(exports, module) {
      function init() {
        return {
          collate: require_collate(),
          feature: require_feature(),
          isSupported,
          map: require_map2(),
          outline: require_outline(),
          projection: require_projection2(),
          spread: require_spread(),
          util: require_util2()
        };
      }
      function isSupported() {
        const attributes = {
          antialias: false,
          alpha: true,
          stencil: true,
          depth: true
        };
        const canvas = document.createElement("canvas");
        const gl = canvas.getContext("webgl", attributes) || canvas.getContext("experimental-webgl", attributes);
        return !!gl;
      }
      module.exports = {
        init
      };
    }
  });

  // ../index.js
  var require_index = __commonJS({
    "../index.js"(exports, module) {
      module.exports = require_lib();
    }
  });

  // map-style.json
  var require_map_style3 = __commonJS({
    "map-style.json"(exports, module) {
      module.exports = [
        {
          version: 8,
          name: "Demo",
          sources: {
            tiles: {
              type: "vector",
              url: "https://tiles.openfreemap.org/planet"
            }
          },
          sprite: "https://tiles.openfreemap.org/sprites/ofm_f384/ofm",
          glyphs: "https://tiles.openfreemap.org/fonts/{fontstack}/{range}.pbf",
          layers: [
            {
              id: "background",
              paint: {
                "background-color": "rgb(242,243,240)"
              },
              type: "background"
            },
            {
              filter: ["==", "$type", "Polygon"],
              id: "park",
              layout: {
                visibility: "visible"
              },
              paint: {
                "fill-color": "rgb(230, 233, 229)"
              },
              source: "tiles",
              "source-layer": "park",
              type: "fill"
            },
            {
              filter: ["==", "$type", "Polygon"],
              id: "water",
              layout: {
                visibility: "visible"
              },
              paint: {
                "fill-antialias": true,
                "fill-color": "rgb(194, 200, 202)"
              },
              source: "tiles",
              "source-layer": "water",
              type: "fill"
            },
            {
              filter: ["all", ["==", "$type", "Polygon"], ["==", "subclass", "ice_shelf"]],
              id: "landcover_ice_shelf",
              layout: {
                visibility: "visible"
              },
              maxzoom: 8,
              paint: {
                "fill-color": "hsl(0, 0%, 98%)",
                "fill-opacity": 0.7
              },
              source: "tiles",
              "source-layer": "landcover",
              type: "fill"
            },
            {
              filter: ["all", ["==", "$type", "Polygon"], ["==", "subclass", "glacier"]],
              id: "landcover_glacier",
              layout: {
                visibility: "visible"
              },
              maxzoom: 8,
              paint: {
                "fill-color": "hsl(0, 0%, 98%)",
                "fill-opacity": {
                  base: 1,
                  stops: [[0, 1], [8, 0.5]]
                }
              },
              source: "tiles",
              "source-layer": "landcover",
              type: "fill"
            },
            {
              filter: ["all", ["==", "$type", "Polygon"], ["==", "class", "residential"]],
              id: "landuse_residential",
              layout: {
                visibility: "visible"
              },
              maxzoom: 16,
              paint: {
                "fill-color": "rgb(234, 234, 230)",
                "fill-opacity": {
                  base: 0.6,
                  stops: [[8, 0.8], [9, 0.6]]
                }
              },
              source: "tiles",
              "source-layer": "landuse",
              type: "fill"
            },
            {
              filter: ["all", ["==", "$type", "Polygon"], ["==", "class", "wood"]],
              id: "landcover_wood",
              layout: {
                visibility: "visible"
              },
              minzoom: 10,
              paint: {
                "fill-color": "rgb(220,224,220)",
                "fill-opacity": {
                  base: 1,
                  stops: [[8, 0], [12, 1]]
                }
              },
              source: "tiles",
              "source-layer": "landcover",
              type: "fill"
            },
            {
              filter: ["==", "$type", "LineString"],
              id: "waterway",
              layout: {
                visibility: "visible"
              },
              paint: {
                "line-color": "hsl(195, 17%, 78%)"
              },
              source: "tiles",
              "source-layer": "waterway",
              type: "line"
            },
            {
              filter: ["==", "$type", "LineString"],
              id: "water_name",
              layout: {
                "symbol-placement": "line",
                "symbol-spacing": 500,
                "text-field": "{name}",
                "text-font": ["Noto Sans Italic"],
                "text-rotation-alignment": "map",
                "text-size": 12
              },
              paint: {
                "text-color": "rgb(157,169,177)",
                "text-halo-blur": 1,
                "text-halo-color": "rgb(242,243,240)",
                "text-halo-width": 1
              },
              source: "tiles",
              "source-layer": "water_name",
              type: "symbol"
            },
            {
              id: "building",
              minzoom: 12,
              paint: {
                "fill-antialias": true,
                "fill-color": "rgb(234, 234, 229)",
                "fill-outline-color": "rgb(219, 219, 218)"
              },
              source: "tiles",
              "source-layer": "building",
              type: "fill"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["==", "brunnel", "tunnel"], ["==", "class", "motorway"]],
              id: "tunnel_motorway_casing",
              layout: {
                "line-cap": "butt",
                "line-join": "miter",
                visibility: "visible"
              },
              minzoom: 6,
              paint: {
                "line-color": "rgb(213, 213, 213)",
                "line-opacity": 1,
                "line-width": {
                  base: 1.4,
                  stops: [[5.8, 0], [6, 3], [20, 40]]
                }
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["==", "brunnel", "tunnel"], ["==", "class", "motorway"]],
              id: "tunnel_motorway_inner",
              layout: {
                "line-cap": "round",
                "line-join": "round",
                visibility: "visible"
              },
              minzoom: 6,
              paint: {
                "line-color": "rgb(234,234,234)",
                "line-width": {
                  base: 1.4,
                  stops: [[4, 2], [6, 1.3], [20, 30]]
                }
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["in", "class", "taxiway"],
              id: "aeroway-taxiway",
              layout: {
                "line-cap": "round",
                "line-join": "round",
                visibility: "visible"
              },
              minzoom: 12,
              paint: {
                "line-color": "hsl(0, 0%, 88%)",
                "line-opacity": 1,
                "line-width": {
                  base: 1.55,
                  stops: [[13, 1.8], [20, 20]]
                }
              },
              source: "tiles",
              "source-layer": "aeroway",
              type: "line"
            },
            {
              filter: ["in", "class", "runway"],
              id: "aeroway-runway-casing",
              layout: {
                "line-cap": "round",
                "line-join": "round",
                visibility: "visible"
              },
              minzoom: 11,
              paint: {
                "line-color": "hsl(0, 0%, 88%)",
                "line-opacity": 1,
                "line-width": {
                  base: 1.5,
                  stops: [[11, 6], [17, 55]]
                }
              },
              source: "tiles",
              "source-layer": "aeroway",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "Polygon"], ["in", "class", "runway", "taxiway"]],
              id: "aeroway-area",
              layout: {
                visibility: "visible"
              },
              minzoom: 4,
              paint: {
                "fill-color": "rgba(255, 255, 255, 1)",
                "fill-opacity": {
                  base: 1,
                  stops: [[13, 0], [14, 1]]
                }
              },
              source: "tiles",
              "source-layer": "aeroway",
              type: "fill"
            },
            {
              filter: ["all", ["in", "class", "runway"], ["==", "$type", "LineString"]],
              id: "aeroway-runway",
              layout: {
                "line-cap": "round",
                "line-join": "round",
                visibility: "visible"
              },
              minzoom: 11,
              paint: {
                "line-color": "rgba(255, 255, 255, 1)",
                "line-opacity": 1,
                "line-width": {
                  base: 1.5,
                  stops: [[11, 4], [17, 50]]
                }
              },
              source: "tiles",
              "source-layer": "aeroway",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["==", "class", "path"]],
              id: "highway_path",
              layout: {
                "line-cap": "round",
                "line-join": "round",
                visibility: "visible"
              },
              paint: {
                "line-color": "rgb(234, 234, 234)",
                "line-opacity": 0.9,
                "line-width": {
                  base: 1.2,
                  stops: [[13, 1], [20, 10]]
                }
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["in", "class", "minor", "service", "track"]],
              id: "highway_minor",
              layout: {
                "line-cap": "round",
                "line-join": "round",
                visibility: "visible"
              },
              minzoom: 8,
              paint: {
                "line-color": "hsl(0, 0%, 88%)",
                "line-opacity": 0.9,
                "line-width": {
                  base: 1.55,
                  stops: [[13, 1.8], [20, 20]]
                }
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["in", "class", "primary", "secondary", "tertiary", "trunk"]],
              id: "highway_major_casing",
              layout: {
                "line-cap": "butt",
                "line-join": "miter",
                visibility: "visible"
              },
              minzoom: 11,
              paint: {
                "line-color": "rgb(213, 213, 213)",
                "line-dasharray": [12, 0],
                "line-width": {
                  base: 1.3,
                  stops: [[10, 3], [20, 23]]
                }
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["in", "class", "primary", "secondary", "tertiary", "trunk"]],
              id: "highway_major_inner",
              layout: {
                "line-cap": "round",
                "line-join": "round",
                visibility: "visible"
              },
              minzoom: 11,
              paint: {
                "line-color": "#fff",
                "line-width": {
                  base: 1.3,
                  stops: [[10, 2], [20, 20]]
                }
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["in", "class", "primary", "secondary", "tertiary", "trunk"]],
              id: "highway_major_subtle",
              layout: {
                "line-cap": "round",
                "line-join": "round",
                visibility: "visible"
              },
              maxzoom: 11,
              paint: {
                "line-color": "hsla(0, 0%, 85%, 0.69)",
                "line-width": 2
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: [
                "all",
                ["==", "$type", "LineString"],
                ["!in", "brunnel", "bridge", "tunnel"],
                ["==", "class", "motorway"]
              ],
              id: "highway_motorway_casing",
              layout: {
                "line-cap": "butt",
                "line-join": "miter",
                visibility: "visible"
              },
              minzoom: 6,
              paint: {
                "line-color": "rgb(213, 213, 213)",
                "line-dasharray": [2, 0],
                "line-opacity": 1,
                "line-width": {
                  base: 1.4,
                  stops: [[5.8, 0], [6, 3], [20, 40]]
                }
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: [
                "all",
                ["==", "$type", "LineString"],
                ["!in", "brunnel", "bridge", "tunnel"],
                ["==", "class", "motorway"]
              ],
              id: "highway_motorway_inner",
              layout: {
                "line-cap": "round",
                "line-join": "round",
                visibility: "visible"
              },
              minzoom: 6,
              paint: {
                "line-color": {
                  base: 1,
                  stops: [[5.8, "hsla(0, 0%, 85%, 0.53)"], [6, "#fff"]]
                },
                "line-width": {
                  base: 1.4,
                  stops: [[4, 2], [6, 1.3], [20, 30]]
                }
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["==", "class", "motorway"]],
              id: "highway_motorway_subtle",
              layout: {
                "line-cap": "round",
                "line-join": "round",
                visibility: "visible"
              },
              maxzoom: 6,
              paint: {
                "line-color": "hsla(0, 0%, 85%, 0.53)",
                "line-width": {
                  base: 1.4,
                  stops: [[4, 2], [6, 1.3]]
                }
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["==", "class", "transit"], ["!in", "brunnel", "tunnel"]],
              id: "railway_transit",
              layout: {
                "line-join": "round",
                visibility: "visible"
              },
              minzoom: 16,
              paint: {
                "line-color": "#dddddd",
                "line-width": 3
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["==", "class", "transit"], ["!in", "brunnel", "tunnel"]],
              id: "railway_transit_dashline",
              layout: {
                "line-join": "round",
                visibility: "visible"
              },
              minzoom: 16,
              paint: {
                "line-color": "#fafafa",
                "line-dasharray": [3, 3],
                "line-width": 2
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["==", "class", "rail"], ["has", "service"]],
              id: "railway_service",
              layout: {
                "line-join": "round",
                visibility: "visible"
              },
              minzoom: 16,
              paint: {
                "line-color": "#dddddd",
                "line-width": 3
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["==", "class", "rail"], ["has", "service"]],
              id: "railway_service_dashline",
              layout: {
                "line-join": "round",
                visibility: "visible"
              },
              minzoom: 16,
              paint: {
                "line-color": "#fafafa",
                "line-dasharray": [3, 3],
                "line-width": 2
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["!has", "service"], ["==", "class", "rail"]],
              id: "railway",
              layout: {
                "line-join": "round",
                visibility: "visible"
              },
              minzoom: 13,
              paint: {
                "line-color": "#dddddd",
                "line-width": {
                  base: 1.3,
                  stops: [[16, 3], [20, 7]]
                }
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["!has", "service"], ["==", "class", "rail"]],
              id: "railway_dashline",
              layout: {
                "line-join": "round",
                visibility: "visible"
              },
              minzoom: 13,
              paint: {
                "line-color": "#fafafa",
                "line-dasharray": [3, 3],
                "line-width": {
                  base: 1.3,
                  stops: [[16, 2], [20, 6]]
                }
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["==", "brunnel", "bridge"], ["==", "class", "motorway"]],
              id: "highway_motorway_bridge_casing",
              layout: {
                "line-cap": "butt",
                "line-join": "miter",
                visibility: "visible"
              },
              minzoom: 6,
              paint: {
                "line-color": "rgb(213, 213, 213)",
                "line-dasharray": [2, 0],
                "line-opacity": 1,
                "line-width": {
                  base: 1.4,
                  stops: [[5.8, 0], [6, 5], [20, 45]]
                }
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["all", ["==", "$type", "LineString"], ["==", "brunnel", "bridge"], ["==", "class", "motorway"]],
              id: "highway_motorway_bridge_inner",
              layout: {
                "line-cap": "round",
                "line-join": "round",
                visibility: "visible"
              },
              minzoom: 6,
              paint: {
                "line-color": {
                  base: 1,
                  stops: [[5.8, "hsla(0, 0%, 85%, 0.53)"], [6, "#fff"]]
                },
                "line-width": {
                  base: 1.4,
                  stops: [[4, 2], [6, 1.3], [20, 30]]
                }
              },
              source: "tiles",
              "source-layer": "transportation",
              type: "line"
            },
            {
              filter: ["all", ["!=", "class", "motorway"], ["==", "$type", "LineString"]],
              id: "highway_name_other",
              layout: {
                "symbol-placement": "line",
                "symbol-spacing": 350,
                "text-field": "{name}",
                "text-font": ["Noto Sans Regular"],
                "text-max-angle": 30,
                "text-pitch-alignment": "viewport",
                "text-rotation-alignment": "map",
                "text-size": 10,
                "text-transform": "uppercase",
                visibility: "visible"
              },
              paint: {
                "text-color": "#bbb",
                "text-halo-blur": 1,
                "text-halo-color": "#fff",
                "text-halo-width": 2,
                "text-translate": [0, 0]
              },
              source: "tiles",
              "source-layer": "transportation_name",
              type: "symbol"
            },
            {
              filter: [
                "all",
                ["<=", "ref_length", 8],
                ["==", "$type", "LineString"],
                ["!in", "network", "us-interstate", "us-highway", "us-state"]
              ],
              id: "highway-shield",
              layout: {
                "icon-image": ["concat", "road_", ["to-string", ["min", ["get", "ref_length"], 6]]],
                "icon-rotation-alignment": "viewport",
                "icon-size": 1,
                "symbol-avoid-edges": true,
                "symbol-placement": {
                  base: 1,
                  stops: [[10, "point"], [11, "line"]]
                },
                "symbol-spacing": 200,
                "text-field": "{ref}",
                "text-font": ["Noto Sans Regular"],
                "text-rotation-alignment": "viewport",
                "text-size": 9
              },
              minzoom: 8,
              paint: {
                "icon-opacity": 0.6,
                "text-color": "rgb(117, 129, 145)"
              },
              source: "tiles",
              "source-layer": "transportation_name",
              type: "symbol"
            },
            {
              filter: ["all", ["<=", "ref_length", 6], ["==", "$type", "LineString"], ["in", "network", "us-interstate"]],
              id: "highway-shield-us-interstate",
              layout: {
                "icon-image": "{network}_{ref_length}",
                "icon-rotation-alignment": "viewport",
                "icon-size": 1,
                "symbol-avoid-edges": true,
                "symbol-placement": {
                  base: 1,
                  stops: [[7, "point"], [7, "line"], [8, "line"]]
                },
                "symbol-spacing": 200,
                "text-field": "{ref}",
                "text-font": ["Noto Sans Regular"],
                "text-rotation-alignment": "viewport",
                "text-size": 9
              },
              minzoom: 6,
              paint: {
                "icon-opacity": 0.6,
                "text-color": "rgb(117, 129, 145)"
              },
              source: "tiles",
              "source-layer": "transportation_name",
              type: "symbol"
            },
            {
              filter: [
                "all",
                ["<=", "ref_length", 6],
                ["==", "$type", "LineString"],
                ["in", "network", "us-highway", "us-state"]
              ],
              id: "highway-shield-us-other",
              layout: {
                "icon-image": "{network}_{ref_length}",
                "icon-rotation-alignment": "viewport",
                "icon-size": 1,
                "symbol-avoid-edges": true,
                "symbol-placement": {
                  base: 1,
                  stops: [[10, "point"], [11, "line"]]
                },
                "symbol-spacing": 200,
                "text-field": "{ref}",
                "text-font": ["Noto Sans Regular"],
                "text-rotation-alignment": "viewport",
                "text-size": 9
              },
              minzoom: 9,
              paint: {
                "icon-opacity": 0.6,
                "text-color": "rgb(117, 129, 145)"
              },
              source: "tiles",
              "source-layer": "transportation_name",
              type: "symbol"
            },
            {
              filter: ["==", "admin_level", 4],
              id: "boundary_state",
              layout: {
                "line-cap": "round",
                "line-join": "round",
                visibility: "visible"
              },
              paint: {
                "line-blur": 0.4,
                "line-color": "rgb(230, 204, 207)",
                "line-dasharray": [2, 2],
                "line-opacity": 1,
                "line-width": {
                  base: 1.3,
                  stops: [[3, 1], [22, 15]]
                }
              },
              source: "tiles",
              "source-layer": "boundary",
              type: "line"
            },
            {
              filter: ["==", "admin_level", 2],
              id: "boundary_country",
              layout: {
                "line-cap": "round",
                "line-join": "round"
              },
              paint: {
                "line-blur": {
                  base: 1,
                  stops: [[0, 0.4], [22, 4]]
                },
                "line-color": "rgb(230, 204, 207)",
                "line-opacity": 1,
                "line-width": {
                  base: 1.1,
                  stops: [[3, 1], [22, 20]]
                }
              },
              source: "tiles",
              "source-layer": "boundary",
              type: "line"
            },
            {
              filter: [
                "all",
                ["in", "class", "continent", "hamlet", "neighbourhood", "isolated_dwelling"],
                ["==", "$type", "Point"]
              ],
              id: "place_other",
              layout: {
                "text-anchor": "center",
                "text-field": "{name}",
                "text-font": ["Noto Sans Regular"],
                "text-justify": "center",
                "text-offset": [0.5, 0],
                "text-size": 10,
                "text-transform": "uppercase",
                visibility: "visible"
              },
              maxzoom: 14,
              paint: {
                "text-color": "rgb(117, 129, 145)",
                "text-halo-blur": 1,
                "text-halo-color": "rgb(242,243,240)",
                "text-halo-width": 1
              },
              source: "tiles",
              "source-layer": "place",
              type: "symbol"
            },
            {
              filter: ["all", ["==", "$type", "Point"], ["==", "class", "suburb"]],
              id: "place_suburb",
              layout: {
                "text-anchor": "center",
                "text-field": "{name}",
                "text-font": ["Noto Sans Regular"],
                "text-justify": "center",
                "text-offset": [0.5, 0],
                "text-size": 10,
                "text-transform": "uppercase",
                visibility: "visible"
              },
              maxzoom: 15,
              paint: {
                "text-color": "rgb(117, 129, 145)",
                "text-halo-blur": 1,
                "text-halo-color": "rgb(242,243,240)",
                "text-halo-width": 1
              },
              source: "tiles",
              "source-layer": "place",
              type: "symbol"
            },
            {
              filter: ["all", ["==", "$type", "Point"], ["==", "class", "village"]],
              id: "place_village",
              layout: {
                "icon-size": 0.4,
                "text-anchor": "left",
                "text-field": "{name}",
                "text-font": ["Noto Sans Regular"],
                "text-justify": "left",
                "text-offset": [0.5, 0.2],
                "text-size": 10,
                "text-transform": "uppercase",
                visibility: "visible"
              },
              maxzoom: 14,
              paint: {
                "icon-opacity": 0.7,
                "text-color": "rgb(117, 129, 145)",
                "text-halo-blur": 1,
                "text-halo-color": "rgb(242,243,240)",
                "text-halo-width": 1
              },
              source: "tiles",
              "source-layer": "place",
              type: "symbol"
            },
            {
              filter: ["all", ["==", "$type", "Point"], ["==", "class", "town"]],
              id: "place_town",
              layout: {
                "icon-image": {
                  base: 1,
                  stops: [[0, "circle_11"], [8, ""]]
                },
                "icon-size": 0.4,
                "text-anchor": {
                  base: 1,
                  stops: [[0, "left"], [8, "center"]]
                },
                "text-field": "{name}",
                "text-font": ["Noto Sans Regular"],
                "text-justify": "left",
                "text-offset": [0.5, 0.2],
                "text-size": 10,
                "text-transform": "uppercase",
                visibility: "visible"
              },
              maxzoom: 15,
              paint: {
                "icon-opacity": 0.7,
                "text-color": "rgb(117, 129, 145)",
                "text-halo-blur": 1,
                "text-halo-color": "rgb(242,243,240)",
                "text-halo-width": 1
              },
              source: "tiles",
              "source-layer": "place",
              type: "symbol"
            },
            {
              filter: ["all", ["==", "$type", "Point"], ["!=", "capital", 2], ["==", "class", "city"], [">", "rank", 3]],
              id: "place_city",
              layout: {
                "icon-image": {
                  base: 1,
                  stops: [[0, "circle_11"], [8, ""]]
                },
                "icon-size": 0.4,
                "text-anchor": {
                  base: 1,
                  stops: [[0, "left"], [8, "center"]]
                },
                "text-field": "{name}",
                "text-font": ["Noto Sans Regular"],
                "text-justify": "left",
                "text-offset": [0.5, 0.2],
                "text-size": 10,
                "text-transform": "uppercase",
                visibility: "visible"
              },
              maxzoom: 14,
              paint: {
                "icon-opacity": 0.7,
                "text-color": "rgb(117, 129, 145)",
                "text-halo-blur": 1,
                "text-halo-color": "rgb(242,243,240)",
                "text-halo-width": 1
              },
              source: "tiles",
              "source-layer": "place",
              type: "symbol"
            },
            {
              filter: ["all", ["==", "$type", "Point"], ["==", "capital", 2], ["==", "class", "city"]],
              id: "place_capital",
              layout: {
                "icon-image": {
                  base: 1,
                  stops: [[0, "star_11"], [8, ""]]
                },
                "icon-size": 0.6,
                "text-anchor": {
                  base: 1,
                  stops: [[0, "left"], [8, "center"]]
                },
                "text-field": "{name}",
                "text-font": ["Noto Sans Regular"],
                "text-justify": "left",
                "text-offset": [0.5, 0.2],
                "text-size": 12,
                "text-transform": "uppercase",
                visibility: "visible"
              },
              maxzoom: 12,
              paint: {
                "icon-opacity": 0.7,
                "text-color": "rgb(117, 129, 145)",
                "text-halo-blur": 1,
                "text-halo-color": "rgb(242,243,240)",
                "text-halo-width": 1
              },
              source: "tiles",
              "source-layer": "place",
              type: "symbol"
            },
            {
              filter: ["all", ["==", "$type", "Point"], ["!=", "capital", 2], ["<=", "rank", 3], ["==", "class", "city"]],
              id: "place_city_large",
              layout: {
                "icon-image": {
                  base: 1,
                  stops: [[0, "circle_11"], [8, ""]]
                },
                "icon-size": 0.6,
                "text-anchor": {
                  base: 1,
                  stops: [[0, "left"], [8, "center"]]
                },
                "text-field": "{name}",
                "text-font": ["Noto Sans Regular"],
                "text-justify": "left",
                "text-offset": [0.5, 0.2],
                "text-size": 12,
                "text-transform": "uppercase",
                visibility: "visible"
              },
              maxzoom: 12,
              paint: {
                "icon-opacity": 0.7,
                "text-color": "rgb(117, 129, 145)",
                "text-halo-blur": 1,
                "text-halo-color": "rgb(242,243,240)",
                "text-halo-width": 1
              },
              source: "tiles",
              "source-layer": "place",
              type: "symbol"
            },
            {
              filter: ["all", ["==", "$type", "Point"], ["==", "class", "state"]],
              id: "place_state",
              layout: {
                "text-field": "{name}",
                "text-font": ["Noto Sans Regular"],
                "text-size": 10,
                "text-transform": "uppercase",
                visibility: "visible"
              },
              maxzoom: 12,
              paint: {
                "text-color": "rgb(113, 129, 144)",
                "text-halo-blur": 1,
                "text-halo-color": "rgb(242,243,240)",
                "text-halo-width": 1
              },
              source: "tiles",
              "source-layer": "place",
              type: "symbol"
            },
            {
              filter: ["all", ["==", "$type", "Point"], ["==", "class", "country"], ["!has", "iso_a2"]],
              id: "place_country_other",
              layout: {
                "text-field": "{name}",
                "text-font": ["Noto Sans Italic"],
                "text-size": {
                  base: 1,
                  stops: [[0, 9], [6, 11]]
                },
                "text-transform": "uppercase",
                visibility: "visible"
              },
              maxzoom: 8,
              paint: {
                "text-color": {
                  base: 1,
                  stops: [[3, "rgb(157,169,177)"], [4, "rgb(153, 153, 153)"]]
                },
                "text-halo-color": "rgba(236,236,234,0.7)",
                "text-halo-width": 1.4
              },
              source: "tiles",
              "source-layer": "place",
              type: "symbol"
            },
            {
              filter: ["all", ["==", "$type", "Point"], ["==", "class", "country"], [">=", "rank", 2], ["has", "iso_a2"]],
              id: "place_country_minor",
              layout: {
                "text-field": "{name}",
                "text-font": ["Noto Sans Regular"],
                "text-size": {
                  base: 1,
                  stops: [[0, 10], [6, 12]]
                },
                "text-transform": "uppercase",
                visibility: "visible"
              },
              maxzoom: 8,
              paint: {
                "text-color": {
                  base: 1,
                  stops: [[3, "rgb(157,169,177)"], [4, "rgb(153, 153, 153)"]]
                },
                "text-halo-color": "rgba(236,236,234,0.7)",
                "text-halo-width": 1.4
              },
              source: "tiles",
              "source-layer": "place",
              type: "symbol"
            },
            {
              filter: ["all", ["==", "$type", "Point"], ["<=", "rank", 1], ["==", "class", "country"], ["has", "iso_a2"]],
              id: "place_country_major",
              layout: {
                "text-anchor": "center",
                "text-field": "{name}",
                "text-font": ["Noto Sans Regular"],
                "text-size": {
                  base: 1.4,
                  stops: [[0, 10], [3, 12], [4, 14]]
                },
                "text-transform": "uppercase",
                visibility: "visible"
              },
              maxzoom: 6,
              paint: {
                "text-color": {
                  base: 1,
                  stops: [[3, "rgb(157,169,177)"], [4, "rgb(153, 153, 153)"]]
                },
                "text-halo-color": "rgba(236,236,234,0.7)",
                "text-halo-width": 1.4
              },
              source: "tiles",
              "source-layer": "place",
              type: "symbol"
            }
          ]
        },
        {
          sources: {
            _data: {
              data: {
                features: [],
                type: "FeatureCollection"
              },
              type: "geojson"
            }
          },
          layers: [
            {
              filter: ["==", "type", "polyline"],
              id: "polyline_data",
              layout: {
                "line-join": "round",
                "line-cap": "round"
              },
              metadata: {},
              paint: {
                "line-color": "#a21bab",
                "line-opacity": 0.8,
                "line-width": 4
              },
              source: "_data",
              type: "line"
            },
            {
              filter: ["all", ["==", "type", "marker"], ["has", "icon"]],
              id: "marker_symbol",
              layout: {
                "icon-image": "marker_icon",
                "icon-offset": [0, -30],
                "icon-size": 0.5
              },
              metadata: {},
              paint: {
                "icon-opacity": ["get", "opacity"]
              },
              source: "_data",
              type: "symbol"
            },
            {
              filter: ["all", ["==", "type", "marker"], ["!has", "icon"]],
              id: "marker_circle",
              layout: {},
              metadata: {},
              paint: {
                "circle-color": ["coalesce", ["get", "color"], "#000000"],
                "circle-opacity": ["case", ["boolean", ["has", "color"], true], ["get", "opacity"], 0],
                "circle-radius": 6,
                "circle-stroke-color": "#555555",
                "circle-stroke-opacity": ["get", "opacity"],
                "circle-stroke-width": 2
              },
              source: "_data",
              type: "circle"
            }
          ]
        },
        {
          sources: {
            _spreader: {
              data: {
                features: [],
                type: "FeatureCollection"
              },
              type: "geojson"
            }
          },
          layers: [
            {
              filter: ["==", "type", "polyline"],
              id: "polyline_spreader",
              layout: {
                "line-join": "round",
                "line-cap": "round"
              },
              metadata: {},
              paint: {
                "line-color": "#a21bab",
                "line-opacity": 0.8,
                "line-width": 4
              },
              source: "_spreader",
              type: "line"
            },
            {
              filter: ["==", "type", "circle_label"],
              id: "circle_label",
              layout: {
                "icon-allow-overlap": true,
                "icon-image": "circle_label",
                "icon-size": 0.7,
                "text-allow-overlap": true,
                "text-field": "{label}",
                "text-font": ["Noto Sans Regular"],
                "text-size": 10
              },
              metadata: {},
              paint: {
                "text-color": "#FFFFFF",
                "text-halo-width": 0.25,
                "text-halo-color": "rgba(255,255,255,1)"
              },
              source: "_spreader",
              type: "symbol"
            }
          ]
        },
        {
          sources: {
            _collator: {
              data: {
                features: [],
                type: "FeatureCollection"
              },
              type: "geojson"
            }
          },
          layers: [
            {
              filter: ["==", "type", "polyline"],
              id: "polyline_collator",
              layout: {
                "line-join": "round",
                "line-cap": "round"
              },
              metadata: {},
              paint: {
                "line-color": "#a21bab",
                "line-opacity": 0.8,
                "line-width": 4
              },
              source: "_collator",
              type: "line"
            },
            {
              filter: ["==", "type", "circle"],
              id: "circle",
              layout: {},
              metadata: {},
              paint: {
                "circle-color": "orange",
                "circle-radius": 6,
                "circle-stroke-color": "#555555",
                "circle-stroke-width": 2
              },
              source: "_collator",
              type: "circle"
            }
          ]
        },
        {
          sources: {
            _collator_spreader: {
              data: {
                features: [],
                type: "FeatureCollection"
              },
              type: "geojson"
            }
          },
          layers: [
            {
              filter: ["==", "type", "polyline"],
              id: "polyline_collator_spreader",
              layout: {
                "line-join": "round",
                "line-cap": "round"
              },
              metadata: {},
              paint: {
                "line-color": "#a21bab",
                "line-opacity": 0.8,
                "line-width": 4
              },
              source: "_collator_spreader",
              type: "line"
            },
            {
              filter: ["==", "type", "circle_orange"],
              id: "circle_orange",
              layout: {},
              metadata: {},
              paint: {
                "circle-color": "orange",
                "circle-radius": 6,
                "circle-stroke-color": "#555555",
                "circle-stroke-width": 2
              },
              source: "_collator_spreader",
              type: "circle"
            },
            {
              filter: ["==", "type", "circle_teal"],
              id: "circle_teal",
              layout: {},
              metadata: {},
              paint: {
                "circle-color": "teal",
                "circle-radius": 6,
                "circle-stroke-color": "#555555",
                "circle-stroke-width": 2
              },
              source: "_collator_spreader",
              type: "circle"
            }
          ]
        },
        {
          sources: {
            _markers: {
              data: {
                features: [],
                type: "FeatureCollection"
              },
              type: "geojson"
            }
          },
          layers: [
            {
              filter: ["==", "type", "markers_symbol"],
              id: "markers_symbol",
              layout: {
                "icon-image": ["get", "image"],
                "icon-offset": ["get", "offset"],
                "icon-size": ["get", "size"]
              },
              metadata: {},
              paint: {},
              source: "_markers",
              type: "symbol"
            }
          ]
        },
        {
          sources: {
            _china: {
              data: {
                features: [],
                type: "FeatureCollection"
              },
              type: "geojson"
            }
          },
          layers: [
            {
              filter: ["==", "type", "china_line"],
              id: "china_line",
              layout: {
                "line-join": "round",
                "line-cap": "round"
              },
              metadata: {},
              paint: {
                "line-color": "#a21bab",
                "line-dasharray": [2, 3],
                "line-width": 4
              },
              source: "_china",
              type: "line"
            },
            {
              filter: ["==", "type", "china_polygon"],
              id: "china_polygon",
              layout: {},
              metadata: {},
              paint: {
                "fill-color": "#A21BAB",
                "fill-opacity": 0.5,
                "fill-outline-color": "#0074D9"
              },
              source: "_china",
              type: "fill"
            },
            {
              filter: ["==", "type", "china_circle"],
              id: "china_circle",
              layout: {},
              metadata: {},
              paint: {
                "circle-opacity": 0,
                "circle-radius": 6,
                "circle-stroke-color": "#0074D9",
                "circle-stroke-width": 5
              },
              source: "_china",
              type: "circle"
            }
          ]
        }
      ];
    }
  });

  // index.js
  var mapboxgl2 = require_src();
  var { decode } = require_google_polyline();
  var { bounds } = require_common();
  var {
    addedDirectly,
    addedWithCollator,
    addedWithCollatorAndSpreader,
    addedWithSpreader,
    sampleChina,
    sampleMarkers
  } = require_samples();
  var { mapStyle } = require_map_style2();
  var maps = require_index().init();
  globalThis.mapboxgl = mapboxgl2;
  mapboxgl2.config.WORKER_URL = "build/worker.js";
  if (maps) {
    const dataEl = document.querySelector("#data");
    const points = JSON.parse(dataEl.getAttribute("data-markers"));
    const bnds = bounds(points);
    const path = decode(dataEl.getAttribute("data-polyline"));
    const onReady = [
      [addedDirectly, "_data"],
      [addedWithSpreader, "_spreader"],
      [addedWithCollator, "_collator"],
      [addedWithCollatorAndSpreader, "_collator_spreader"],
      [sampleMarkers, "_markers"],
      [sampleChina, "_china"]
    ];
    const styleArray = require_map_style3();
    Array.prototype.slice.call(document.querySelectorAll(".example .map")).forEach(async (mapEl, i, els) => {
      const { layers, sources } = styleArray[i + 1];
      const style = Object.assign(styleArray[i + 1], styleArray[0]);
      style.layers = style.layers.concat(layers);
      style.sources = Object.assign(style.sources, sources);
      const map = await maps.map(mapEl, {
        mapboxgl: mapboxgl2,
        style: await mapStyle(createUrl(style)),
        backgroundColor: "#e5c7e6"
      });
      onReady[i][0](maps, map, onReady[i][1], points, path);
      if (i > els.length - 3) {
        return;
      }
      map.bounds(bnds);
    });
  }
  function createUrl(obj) {
    return `data:text/plain;base64,${btoa(JSON.stringify(obj))}`;
  }
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
